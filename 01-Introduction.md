# 第一章 介紹

## 1.1 高層次綜合(HLS)

硬件設計與處理近幾年來發展迅速。 過去我們的電路相對簡單，硬件設計師們可以很方便的畫出每一個晶體管，規劃他們的連接方式，甚至他們的板上位置。可以説所有工作都是人工完成的。但隨着越來越多晶體管的設計需要，硬件工程師也越來越需要依賴自動化設計工具來幫助他們完成設計，而這些設計工具也相對應的變得越來越精密。工程師在這些設計工具的協助下也更具效率。他們不再具體操作每一個晶體管，而只需要設計數字電路，電子設計自動化工具（EDA）把這些抽象而概括的電路自動轉換成實際的部件構造版圖。

米德和康威（Mead&Conway）的方法[[50](./BIBLIOGRAPHY.md#50)]，也就是使用一種硬件描述語言（Verilog, VHDL），並把其編譯成片上設計的方法在上世紀80年代開始廣為使用。但這之後硬件的複雜度還在以指數函數的增長速度發展，硬件工程師們只好尋求更加概括而高層次的編程語言，RTL應運而生。在RTL裏，設計師不需要考慮怎麼構造一個寄存器或怎樣安置這些寄存器，而只需要考慮這些寄存器在設計中起到怎樣的作用。EDA工具可以先把RTL轉化成數電模型，再由模型轉換成一個設備上的具體電路實施方案。這些"方案"對器件的製造來説必不可少，可以用於規定某個自定義設備，也可以用於編程一些現有的設備，比如FPGA。如我們現在所見，新的設計方法確實幫助工程師們的設計思路變得更加清晰。更多關於這方面的探討參考註釋[[42](./BIBLIOGRAPHY.md#42)].

HLS則是在這基礎上更高層的一種方法，設計師們在HLS下需要更多的考慮大的架構而非某個單獨部件或逐週期運行。設計師在HLS下需要注重的是系統的運行模式，HLS工具會負責產生具體的RTL微結構。最早大多數HLS工具是基於Verilog的，用户需要使用Verilog[[35](./BIBLIOGRAPHY.md#35)]語言進行描述，工具也通過Verilog產生RTL。現如今很多HLS工具開始使用C/C++作為設計師端的語言。當然，選擇HLS工具最重要的還是看它能否綜合我們需要的程序，而不是它使用什麼語言。

總體來説，HLS可以自動完成以下曾經需要手動完成的工作：

- HLS自動分析並利用一個算法中潛在的併發性
- HLS自動在需要的路徑上插入寄存器，並自動選擇最理想的時鐘
- HLS自動產生控制數據在一個路徑上出入方向的邏輯
- HLS自動完成設計的部分與系統中其他部分的接口
- HLS自動映射數據到儲存單位以平衡資源使用與帶寬
- HLS自動將程序中計算的部分對應到邏輯單位，在實現等效計算的前提下自動選取最有效的實施方式

HLS的目標是根據用户提供的輸入和限制自動替用户做出很多決定。每個HLS工具在實際施行的效率上相差甚遠，這其中我們有一些非常不錯的選擇，例如賽靈思Vivado HLS, LegUp, Mentor Catapult HLS。他們出眾的特性在於可以支持更多更廣泛的程序轉換。我們在本書中將使用Vivado HLS作為演示軟件，但是設計的思路與技巧在各個軟件中應當是通用的，讀者只需要在各自的軟件中對語法進行稍微的調整。

大多數HLS工具需要用户提供功能的規範，交互的描述，一個對接的計算設備，和目標優化方向。而對於Vivado HLS來説，用户需要：

- 一個用C/C++/System C編寫的函數
- 一個測試平台用於驗證結果
- 一個FPGA開發版
- 期望的時鐘週期
- 一個簡單的實施指導

HLS工具沒有強大到可以處理任何代碼。很多我們平時在軟件編程中常用的概念在硬件實施中很難實現，所以硬件描述語言對於具體實施會更加靈活。通常這些HLS工具需要用户提供一些附加信息（通過suggestion或#pagma）來幫助完善程序，因此我們説HLS工具會同時"限制"又"加強"了一門語言。舉例而言，HLS工具一般無法處理動態內存分配，大部分工具對標準庫的支持也非常有限。用户也應當避免系統調用和遞歸以儘量降低複雜程度。除去這些設計限制之外，HLS工具的處理範圍非常的廣（包括直接內存訪問，流，片上內存），優化效率也很高。

根據Vivado HLS的使用指南，我們將對我們的輸入程序作出以下規範：

- 不使用動態內存分配（不使用malloc(),free(),new和delete()）
- 減少使用指針對指針的操作
- 不使用系統調用（例如abort(),exit(),printf()），我們可以在其他代碼例如測試平台上使用這些指令，但是綜合的時候這些指令會被無視（或直接刪掉）
- 減少使用其他標準庫裏的內容（支持math.h裏常用的內容，但還是有一些不兼容）
- 減少使用C++中的函數指針和虛擬函數
- 不使用遞歸方程
- 精準的表達我們的交互接口

當RTL級的設計可用時，大多數HLS工具會進行標準RTL設計流。而在賽靈思Xilinx Vivado設計套裝裏進行的是邏輯綜合，將RTL級設計轉換成一個FPGA邏輯部件的連線表，這份連線表不僅包含需要的邏輯部件還包含他們的連接方式。Vivado之後將連線表和目標設備中的可用資源相關聯，這個過程被稱作佈局及佈線（PAR）。產出的FPGA配置被附在比特流（bitstream）上，用户可以將比特流上傳到FPGA以實現想要的功能。比特流實質上是用二進制表示FPGA上每一個可用資源的配置，包括邏輯部件的使用，連線的方式，和片上的內存。大型FPGA例如賽靈思UltraScale FPGA擁有超過十億個可配置比特，較小的FPGA上也至少有幾億個可配置比特[[64](./BIBLIOGRAPHY.md#64)]。

## 1.2 FPGA構造

瞭解HLS的第一步是熟悉FPGA的構造，因為很多HLS的優化都是和這些構造特點息息相關的。過去幾十年來，FPGA變得越發大而複雜，也加入了片上內存、自定義數據路徑，高速I/O，和多核處理器等等精密結構。在這一節，我們只討論FPGA中與HLS相關的結構特點，其他無關內容不會被詳細描述。瞭解FPGA的現代結構後再學習HLS會有助於讀者對於其理解。

FPGA由一個可編程邏輯模塊的矩陣和與之相連的內存組成，通常這些模塊是以查找表（LUT）的形式存在，也就是説把地址信號輸入進去，對應內存位置的內容會直接被輸出出來。一個N位查找表可以以一個N位輸入真值表的方式來表示。

![圖1.1：a)部分是一個兩位輸入查找表，寫作2-LUT。每一個configuration bit，即備置比特，可以根據查找表的功能變化而變化，這樣的特性讓它具有了可編寫的特性。b)部分是AND門的編寫方式，out一列的數值從上到下依次對應了配置比特0-3的數值。c)部分是一個由查找表和觸發器組成的簡單的slice。這個查找表擁有九個配置比特，其中八個決定查找表的功能，剩下一個決定直接使用查找表的輸出或使用觸發器中儲存的輸出。slice的性質見下文。](/images/lut.jpg)

上圖中的a)部分是一個2位輸入查找表，共有$${2}^{2}$$個配置比特。使用者通過編寫程序來控制這些比特以實現某種功能。b)部分是一個2位輸入AND門的真值表，通過對應4個可能的結果產出（out一列），我們可以把a中的2位查找表編寫成b中的AND門，即四個查找表輸入依次對應b中的00，01，10，11。按照這個模式編寫查找表，我們可以輕鬆的改變它的功能，讓它充當我們需要的部件。對於小的布爾邏輯（Boolean），這樣的編寫方式更加的靈活高效。實際中的FPGA大多使用4-6位輸入的查找表作為運算基礎，一些大型FPGA內甚至有幾百萬個這一級別的查找表。

{% hint style ='info' %} 怎樣將圖1.1中的查找表編寫成一個XOR門呢？一個OR門？我們需要一個幾位輸入的查找表？ {% endhint %}

{% hint style ='info' %} 一個2位輸入的查找表最多可以被編寫出多少種形態？一個n位輸入的查找表呢？ {% endhint %}

觸發器（FF）是FPGA最基本的內存單位，通常觸發器是配有查找表的，這樣是為方便查找表之間的複製與組合。在這基礎上再加入一個規定它們的函數（例如全加器），就可以創建一個更為複雜的邏輯單位，稱為可配置邏輯塊（CLB）或邏輯矩陣塊（LAB）。有些設計工具中還會把它稱作片（Slice）。為避免歧義，我們將在下文中用slice作描述，這樣讀者可以對在Vivado設計工具中出現的Slice更加熟悉。一個slice是幾個查找表，觸發器，和多路複用器（MUX）組合到一起而形成的更強大的可編程邏輯單位。每個slice需要的小部件數視FPGA的架構而變，但總體來説每個slice真的只包含不多的幾個部件。圖1.1中的c部分就是由1個三位輸入查找表和1個觸發器組成的slice。slice可以變得更加複雜一點，比如加入全加器。FPGA內部通常有一些定義好的全加器slice，這看起來有點違背FPGA的"可編寫性"--它只可以執行加法操作。但實際上使用全加器在硬件設計中太過於常見，把所有的全加器每次重新編寫成一個slice會降低效率。靈活性和高效綜合考慮，一些被配置好的slice是一個對整個系統有益的設計。

![圖1.2:由查找表和觸發器組成的slice，通常slice比圖上結構更加複雜一點，slice之間通過連線通道（routing channel）和開關盒（switchbox）相連，這兩個用於連接的設備提供了一個同樣可編寫的互聯和自定義的數據傳輸方向。開關盒是一個包含很多開關（傳輸晶體管制成）的部分，提供了編寫傳輸路徑的能力](images/slice_channel.jpg)

可編寫的互聯是FPGA最關鍵的特性之一，它能提供一個slice之間更靈活的連線網絡。slice的輸入與輸出全都與連線通道相連，連線通道也是通過配置比特來決定每個slice的輸入輸出通向哪裏，而通道本身則與開關盒相連。開關盒由很多傳輸晶體管充當的開關所組成，它的工作便是連接通道與通道。

圖1.2展示了一個slice，連線通道和開關盒之間的連接方式。slice的每個輸入輸出都應與通道中的一條路線相連。所謂路線，我們可以簡單的把它想成一跟比特層級的跳線，在物理層級上這條線路是由傳輸晶體管構成的，同樣具有可編寫性。

開關盒像是一個連接矩陣，溝通不同連接通道中的各個路線。FPGA一般有一個2D的形式，能給使用者一個大概的2D計算模型，我們稱之為島狀結構。在島狀結構裏，每個slice都是一個邏輯島，島與島之間通過連線通道和開關盒相連。在這裏每個開關盒在上下左右四個方向連接了四個連線通道。

連線通道和開關盒中的所有開關都通過使用者的編寫控制着邏輯部件之間的聯繫。現如今業界對於電路層級的FPGA架構已經瞭解的很深了，連線通道的數量，開關盒的連接方式，slice的結構等等都有很詳盡的資料。我們在註釋中附上了一些書籍[[12](./BIBLIOGRAPHY.md#12), [10](./BIBLIOGRAPHY.md#10), [30](./BIBLIOGRAPHY.md#30)]，有興趣的讀者可以參考一下。當然使用HLS工具時並不需要了解那麼多細節，這方面的知識只是作為理解HLS優化工作的輔助。

![圖1.3:2D的FPGA島狀結構。每個slice內的邏輯與內存通過連接通道和開關盒相連。IO模塊有一個對外接口，可以通往內存，處理器，傳感器等等。一些FPGA上IO直接與芯片引腳相連，一些FPGA則用起連接邏輯架構和片上的一些資源。](images/fpga.jpg)

圖1.3提供的是一個更概括性的結構互聯，可以比較清楚的看到各部分之間的物理連接方式。FPGA的邏輯部分通過一些IO模塊與外部設備相聯繫，像微控制器（通過AXI接口連接片上ARM處理器 ），傳感器（通過A/D接口連接天線），作動器（通過D/A接口連接電機）都是可以實現的。近來發展的FPGA又集成了自定義片上I/O處理器，像內存控制，無線收發，模擬與數字轉換器這類的裝置。

![圖1.4:現代FPGA變得更加異構化，一些FPGA除了可編程部分之外，加入了很多預配好的結構比如寄存器堆，自定義數據路徑，高速互聯等等。現如今FPGA通常配有一個或多個處理器，比如ARM或x86核，兩者協同控制系統。](images/heterogenous_fpga.jpg)

我們説到FPGA上要承載的晶體管變得越來越多，這也是FPGA上多了很多預配好的資源的原因。這部分硬件用於完成特定工作。很多設計都需要大量的加法和乘法，因此FPGA廠商把這部分的內容預配好以直接使用。像DSP48數據路徑已經被用一種高效的方法預配好，添加了乘法、加法、乘積、邏輯操作等一系列算數。對於DSP48這樣的模塊來説，它們依舊保留了一定的可編寫性，但不像其他可編程邏輯那樣完全靈活。這樣綜合而言，用户在DSP48這樣的模塊上進行乘法這樣的操作會比重新編寫高效的多。所以我們説靈活性和效率有時候是此消彼長的。現代FPGA會含有成百上千個DSP48模塊，如圖1.4所示。

{% hint style ='info' %} 比較自搭乘積和DSP48基礎上乘積的性能，兩種情況下可獲得的最高頻率分別是多少？FPGA資源利用上有什麼變化嗎？ {% endhint %}

塊RAM（BRAM）是另一個預配好的模塊。BRAM是一個支持多種內存形式和接口的可配置隨機儲存器，可以儲存字節，對字，全字，雙字等等等。BRAM還可以把這些數據傳給本地片上總線（與可編程邏輯交流）或處理器總線（與片上處理器交流）等等接口。總體來説它有兩個功能，一是芯片上各部分的數據轉移，二是儲存大一些的數據集。slice經過編寫也可以儲存數據（通過觸發器），但這樣做會增加額外消耗。


 屬性 | 外部內存 | BRAM | 觸發器
---- | ---- | ---- | -------
數量 | 1-4 | 幾千 | 幾百萬
單個大小 | GB級 | KB級 | bit級
總量 | GB級 | MB級 | 100KB級
寬度 | 8-64 | 1-16 | 1
總帶寬 | GB每秒 | TB每秒 | 100TB每秒

表1.5:三種形式內存存儲比較。外部內存存儲密度最高但帶寬有限，觸發器擁有最好的帶寬但儲存容量太小，BRAM則像是兩者之間的中間值。

一塊BRAM通常有大約32000比特的儲存容量，可以以32000 x 1比特，16000 x 2比特，8000 x 4比特等等形式存在。串聯在一起可以擁有更大的容量，Vivado工具可以完成這方面的配置，而Vivado HLS的優勢也在於這裏，設計者不再需要考慮這一層級的細節。通常BRAM和DSP48放置在一起，對於HLS設計來説，我們可以直接把BRAM想成一個寄存器堆，它可以直接輸出到一個自定義的數據路徑（DSP48），可以與處理器交流，也可以像可編程邏輯上的數據路徑傳輸數據。

{% hint style ='info' %}思考怎樣把一個很大的數組存在BRAM和可編程邏輯裏。它的性能如何變化？資源使用呢？{% endhint %}

表1.5是一個不同內存形式比較的表格。如表格所示，所有觸發器最後可以形成一個幾百KB的儲存，它們每個週期都可以被讀寫所以總帶寬非常的大，但很顯然他們的儲存容量不盡如人意。BRAM在不犧牲很大帶寬的前提下，提供了更大的儲存密度。帶寬的犧牲主要在於每個週期BRAM只有1-2個入口可以被接通。外部內存對於帶寬的犧牲更大，但提供了最大的容量。把應用數據放在哪裏是非常關鍵的一個設計決定，我們會在整本書裏經常提到。Vivado HLS工具也允許設計者清楚指明到底要將這段數據放在哪裏。

片上晶管的繁多也豐富了我們的預配資源，片上的處理器其實就是一個很好的代表。現如今的高端FPGA會含有4個甚至更多的微處理器（比如ARM核心），小型的FPGA上附有一個處理器也變得很常見。處理器使芯片有了運行操作系統（比如Linux）的能力，它可以通過驅動和外部設備交流，可以運行更大的軟件包比如OpenCV，可以運行更高級的語言（比如python）並以更快的速度運行。處理器經常成為了整個系統的控制者，協調了各方之間的數據轉移，也協調了各個IP核心（包括用HLS自定義的IP核和第三方IP核）和板上資源的關係。

## 1.3 FPGA設計與處理

![圖1.6:設想中的嵌入式FPGA設計結構圖，包括接口核心（藍色框），標準核（綠色框），和應用加速核（紫色框）。注意應用加速核也可能自帶流接口，內存對應接口。](images/embedded_design_template.jpg)

由於FPGA大小和複雜度的不斷提升，設計師更傾向於從高層建造自己的設計。這樣一來，FPGA設計更多是由一個個大組件，或IP核組建而成，如圖1.6。在整個設計的外圍臨近I/O引腳的地方通常是一些少量的邏輯，它們一般用來完成關鍵時序和協議，比如內存控制模塊，視頻接口核心或模擬數字轉換器。這部分邏輯我們稱之為**I/O接口核**，通常以RTL的形式構架並需要加上其他的時序限制。時序限制的目的是闡明信號本身與信號變化規則之間的時序關係。設置限制的時候必須要考慮信號蔓延到電路板和連接裝置的影響。使用I/O引腳附近邏輯的考慮是為了高速接口的實施需要，這些邏輯更適合在"高速"前提下實現數據的序列化和反序列化，時鐘的恢復與分佈，和精準延遲某些信號以不斷從寄存器獲取數據。I/O接口核心在不同的FPGA架構上差別比較大，FPGA供應商一般會有設計參考或成品部件，因此我們不會展開太多細節。

除了I/O引腳，FPGA一般會有**標準核**，處理器核心，片上內存核連接開關都屬於標準核。標準核另外還包括原生的函數處理部件比如濾波器，FFT，編解碼器等等。這些核心的參數和接入方式在不同的設計中相差很大，但它們並不是在設計中真正造成差異的部件，相反他們是相對"水平的"技術部分，可以被插入到各類不同的應用領域。FPGA廠商同樣也提供這些模塊，但設計師其實很少情況下接觸到它們。不像IO接口核心，標準核心主要是同步電路，它除了時鐘時序限制之外不大有限制。這些特點讓標準核更容易在不同FPGA中兼容，當然，被轉移到另一種FPGA結構中時還是需要一定優化的。

最後一種核心是針對應用的**加速器核**，同標準核一樣，加速核通常是由時鐘限制而規定的同步電路，但這些核卻是系統設計師們在具體應用中不可避免要接觸的部分。如果把一個設計的系統比做一道菜，那加速器核就像是祕製配方，它是讓每個人的菜餚各有風味的關鍵。最理想的情況是設計師又快又輕鬆地設計出了這樣的高性能核然後把它們以很快的速度集成到整個系統裏，這也是我們這本書的主要目標，用HLS設計出快而高效的核。

圖1.6中的系統通過兩種方法可以實現。第一種方法是把HLS產生的加速器核當作一個普通的核。用HLS創造出這種核之後把他們與IO接口核和標準核組合到一起（可以通過Vivado IP Inegrator這樣的軟件），這樣我們就得到了完整的設計。這個方法叫做**以核為基礎的設計方法**，與使用HLS之前的FPGA設計方法十分相似。第二種方法則着重於設計樣板或平台，稱為**平台為基礎的設計方法**，這種方法下設計師先用IO接口核和標準核組合出一個樣板，然後再用HLS通過**殼**（shell）的接口將各式算法或**對象**組合進去。只要殼支持雙邊的接口，加速器核在平台與平台之間的移動也非常容易。

## 1.4 設計優化

### 1.4.1 性能特點

在開始討論怎麼去優化之前，我們先要討論一下判斷一個設計特點的標準。計算時間就是一個衡量設計好壞的重要標準。很多人把時鐘週期數作為一個同步電路性能的指標，但實際上對於兩個使用不同時鐘的電路這是不得當的，而時針不同又是HLS下的絕大多數情況。比如説，我們現在已經規定好了Vivado HLS的輸入時鐘限制，那麼工具根據時鐘的不同會從同一段代碼中產生不同的結構，所以這不是一個很恰當的比較方式。秒數是一個更好的對應比較指標。Vivado HLS工具會提供一個週期數和週期頻率的報告，用户可以用此得出某段代碼的操作時間。

{% hint style ='tip' %} 改變時鐘頻率有時候可以優化設計。Vivado HLS工具把時鐘頻率作為一個輸入，所以改變一個輸入可以導致產出的結構完全不同。我們會在後文繼續討論。書中章節2.4描述了根據時鐘週期決定限制。書中章節2.5討論了改變時鐘週期如何通過操作鏈提升產力。 {% endhint %}

我們用任務（task）這個術語來表示一個行為的基本單位，用户可以在Vivado HLS中發現與之對應的是調用函數。任務延遲就是任務開始到任務完成中間的這段時間。任務間隔則是任務開始到下一個任務開始之間的這段時間。所有的任務輸入，輸出和計算的時間都被算在任務延遲裏，但是任務的開始並不等同於讀取輸入，同樣任務的結束也不等同於寫出輸出。在很多設計中，數據率是一個很重要的東西，它同時取決於任務間隔和函數參數的多少。

![圖1.7:兩種不同設計的任務間隔和任務延遲，上方的弧線指示的是任務間隔，下方的弧線指示的是任務延遲。左右兩個設計的區別在於，左邊是流水線（pipeline），右邊使用了更順序化的設計。](images/intervalduration.jpg)

圖1.7表示的是兩種設計的實施設想，橫向軸是時間軸（從左到右增大），縱向是設計中不同的函數單位。紅色表示的是輸入有關的操作，橙色表示的是輸出有關的操作，正在活躍的運算符用深藍表示，不活躍的則用淺藍表示。每一個進入的箭頭表示的是一個任務的開始，而出去的箭頭表示任務的完成。左側的圖表示的是一個每個週期都執行新任務的結構設計。與之對應的是完全流水（fully-pipelined）結構。右側表示的則是一個完全不一樣的結構，系統每次讀取四段輸入，處理數據，然後再合成一個4段數據的輸出。這種結構的任務延遲和任務間隔是一樣的（13個週期），並且每一週期內只有一個任務在執行。這個結構和左邊的流水形成了鮮明對比，左邊的結構在同一週期內顯然有多個任務在執行。HLS中的流水和處理器中的流水概念相似，但是不再使用處理器中操作分5個階段並把結果寫入寄存器堆的方法，Vivado HLS工具構造的是一個只適用於特定板子，可以完成特定程序的電路，所以它能更好的調整流水的階段數量，初始間隔（連續兩組數據提供給流水之間的間隔），函數單位的數量和種類，還有所有部件之間的互聯。

Vivado HLS工具通過計算一個任務輸出到輸入之間這個過程需要最大的寄存器數來決定週期。因此，0週期的任務延遲是可以實現的，也就是組合邏輯下路徑上沒有任何寄存器。另一個常用的工作是計算輸入輸出並把結果存到寄存器裏，通過這些數據找到路徑上的寄存器數。這樣的計算要花費很多的週期。

{% hint style ='tip' %} 很多工具把任務間隔稱為生產力（throughput）。這個詞語聽起來和間隔沒什麼關係。一個任務間隔的變長不可避免的會減少一段固定時間內能完成的任務數，也就是"生產的力度"。還有一些工具用延遲來描述讀輸入和寫輸出的關係。非常不幸的是，在一些複雜的設計中，任務的特點很難僅僅用輸入輸出來分析，比如有時候一個任務需要讀很多次數據。 {% endhint %}

### 1.4.2 面積和產力的取捨

為了更深入的討論使用HLS工具過程中的問題，我們需要分析一個簡單但很常見的硬件函數----有限脈衝響應（FIR）濾波器。FIR會對輸入做固定係數下的卷積，它可以被用作充當各式濾波器（高通，低通，帶通），最簡單的FIR可能就是一個移動平均濾波器。有關FIR的具體內容會在第二章展開，在這裏我們從高層簡要的談一下。

```c
#include "stdio.h"

#define NUM_TAPS 4
void fir(int input, int *output, int taps[NUM_TAPS]);

const int SIZE = 256;

int main() {
    int taps[] = {1, 2, 0, -3, 0, 4, -5, 0, 1, -2, 0, -3, 0, 4, -5, 0};
    int out = 0;
    for (int i = 0; i < SIZE; i++) {
        fir(i, &out, taps);
    }
    printf("result = %d\n", out);
    if (out == -1452) {
        return 0;
    } else {
        return 1;
    }
}
```

![（代碼樣例）圖1.8:四抽頭FIR濾波器的代碼](images/placeholder.png)

圖1.8中的C代碼可以作為一個HLS的任務描述。這段代碼可以直接作為Vivado HLS工具的輸入，工具會自動分析併產生一個等效的RTL電路。這個過程具體細節比較複雜，我們暫時不做深究，只需要把它當作一個編譯器去理解，像是gcc，只不過這個編譯器輸出的是RTL硬件描述。編譯器的複雜性是它非常關鍵的原因之一，因為它不需要用户理解每一個細節。但理解編譯器如何工作其實有助於設計師寫出更高效的代碼，這點對於HLS尤其重要，因為綜合電路的構建方式有很多種，只理解它軟件流是不夠的。比如HLS設計師需要考慮流水，內存排布，I/O接口這些軟件設計師不需要考慮的內容。

回到編譯器，理解它的關鍵問題在於：這段代碼中產生的是什麼電路？這個問題的答案分多鐘，還和你所用的HLS工具有關。那麼通常工具有以下幾種合成方式：

第一種可能的產出電路是按照順序執行每行代碼產出的電路，這時候工具就像一個簡單的RISC處理器。下面的圖1.9中的代碼是圖1.8中的代碼在賽靈思Microblaze處理器下的彙編代碼版本。雖然已經經過了優化，但還是有很多指令用來執行計算數組索引（array index）和控制循環。這樣的指令我們假設它每個循環都要執行一次，那麼我們在49個循環之後才能得到濾波器得出的結果。我們可以很明瞭地得到一個結果，那就是一個週期內執行的指令數是影響性能的一個重要的壁壘。有時候對於一個架構的提升就是讓它處理的指令變得更復雜，讓同一個指令能做的事情變得更多。HLS的一個特點就是在決定結構上的一些此消彼長的設計時，不再需要考慮讓它適用於指令集的結構限制。在HLS設計中，設計出一個在同週期內執行成百上千個RISC級指令外加幾百個週期程度流水的系統是非常常見的。

```asm
fir:
        .frame  r1,0,r15                # vars= 0, regs= 0, args= 0
        .mask   0x00000000
        addik   r3,r0,delay_line.1450
        lwi     r4,r3,8           # Unrolled loop to shift the delay line
        swi     r4,r3,12
        lwi     r4,r3,4
        swi     r4,r3,8
        lwi     r4,r3,0
        swi     r4,r3,4
        swi     r5,r3,0           # Store the new input sample into the delay line
        addik   r5,r0,4       # Initialize the loop counter
        addk    r8,r0,r0          # Initialize accumulator to zero
        addk    r4,r8,r0          # Initialize index expression to zero
$L2:
        muli    r3,r4,4           # Compute a byte offset into the delay_line array
        addik   r9,r3,delay_line.1450
        lw      r3,r3,r7          # Load filter tap
        lwi     r9,r9,0           # Load value from delay line
        mul     r3,r3,r9      # Filter Multiply
        addk    r8,r8,r3      # Filter Accumulate
        addik   r5,r5,-1          # update the loop counter
        bneid   r5,$L2
        addik   r4,r4,1           # branch delay slot, update index expression

        rtsd    r15, 8
        swi     r8,r6,0          # branch delay slot, store the output
        .end    fir
```

![（代碼樣例）圖1.9:RISC風格下圖1.8中的代碼的彙編版。在賽靈思Microblaze處理器下施行。這段代碼由microblazeel-xilinx-linux-gnu-gcc -01 -mno -xl -soft -mul S fir.c 指令產生](images/filter_asm_behavior.jpg)

這是Vivado HLS默認下產出的是非常順序化的結構。所謂順序化的結構，是指循環和分支都被寫作控制邏輯以控制寄存器、功能單元等部件。這其實和RISC處理器的概念相同，除了我們提到過產出的結果是RTL結構下的狀態機。這種結構更傾向於限制那些使用資源去並行的功能單元。順序化結構可以從大多數程序中生成，無需對原代碼做太多的修改和優化，所以對HLS初學者非常的簡單。但它同樣存在一些缺陷。順序化的結構很難解析碼流，主要出於控制邏輯的複雜度。另外，控制邏輯負責規定任務延遲和任務間隔。順序化結構的性能有時取決於處理的數據。

Vivado HLS可以產出更加流水，平行，性能上也更好的結構。其中之一叫做**函數流水**。函數流水結構是把函數內所有的代碼都當作計算數據路徑的一部分，再加上少量的控制邏輯。循環和分支被轉換成無限制的結構。這種結構特點分明，容易分析，一般用於處理連續而簡單的高碼率數據。函數流水結構可以在更大的設計中充當組件，因為它的行為比較簡單，方便共享資源，但這種結構的缺點在於適用範圍相對較小，不是所有代碼都可以被設計成平行結構。

用户可以通過在代碼中添加**#pagma HLS pipeline**來指導Vivado HLS工具產生函數流水結構。這段指令需要一個參數來規劃流水的起始間隔，也就是一個函數流水的任務間隔。圖1.10展示了一個可行的設計----每週期一拍的架構。任務用到了一個乘法器和一個加法器完成濾波器。這種設計的任務間隔和任務延遲都是4個週期。圖1.11展示的是一個每週期一樣本的結構，它使用了4個乘法器和3個加法器。這種設計的任務延遲和任務間隔都是1個週期，所以它每個週期都接受一個新的輸入。當然這兩種之外還有很多可行的設計，比如每週期兩抽頭設計，或每週期兩樣本設計，在一些特定應用中各自有各自的優勢，我們將在第二章中討論更多優化。

![](images/filter_one_sample.jpg)

![圖1.10:每週期一拍設計。可以由圖1.8中的代碼產出](images/filter_one_sample_behavior.jpg)

![](images/filter_one_tap.jpg)

![圖1.11:每週期一樣本設計。可以由圖1.8中的代碼加入函數流水指令產出](images/filter_one_tap_behavior.jpg)

實際應用中，複雜的設計在順序化和並行化的結構之間會有很多取捨的考慮。這些取捨在Vivado HLS中很大程度上取決於設計者的決定和代碼內容。

### 1.4.3 處理速率的限制

我們看到了很多改變架構會改變任務間隔的例子，這樣做通常來講可以提升處理速率。但是讀者需要意識到任何結構的任務間隔都是有一定的限度的。最關鍵的限制來自於遞歸和反饋循環，還有一些其他的例如資源限制也很重要。

**遞歸**（recurrence），這裏是指某個部件的計算需要這個部件之前一輪計算的結果， 遞歸是限制產力的重要因素，即使在流水結構中也是如此[[56](./BIBLIOGRAPHY.md#56)，[43](./BIBLIOGRAPHY.md#43)]。分析算法中的遞歸併產出正確的硬件設計是非常關鍵的一步，同樣，選擇一個儘量避免很多遞歸的算法也是設計中非常關鍵的一步。

遞歸在很多代碼結構中都會出現，比如靜態變量（圖1.8），順序的循環（圖1.10）。它存在於很多順序化結構中，也有很多會隨着改編成流水結構而消失。對於順序化結構遞歸有時候不影響處理速率，但是在流水結構中是一個很不理想的狀況。

另一個影響速率的關鍵因素就是**資源限制**，其中一種形式是設計邊緣線路，因為一個同步電路中的每根跳線在每週期只能傳送抓取1個比特的數據。因此，如果 int32_t f(int32_t x)這樣形式的函數作為一個單獨模塊在100MHz的頻率和1的任務間隔下運行，它最大的數據處理量就是3.2G比特。另一種資源限制來自於內存，因為大多數內存每週期只支持一定次數的訪問。還有一種資源限制來自於用户所給的限制，如果用户規定了在綜合中可用的操作數，這其實是給處理率添加了限制條件。

```c
#define NUM_TAPS 4

void block_fir(int input[256], int output[256], int taps[NUM_TAPS],
                             int delay_line[NUM_TAPS]) {
    int i, j;
    for (j = 0; j < 256; j++) {
        int result = 0;
        for (i = NUM_TAPS - 1; i > 0; i--) {
#pragma HLS unroll
            delay_line[i] = delay_line[i - 1];
        }
        delay_line[0] = input;

        for (i = 0; i < NUM_TAPS; i++) {
#pragma HLS pipeline
            result += delay_line[i] * taps[i];
        }
        output[j] = result;
    }
}
```

![（代碼樣例）圖1.12：另一種FIR濾波器代碼](images/placeholder.png)

### 1.4.4 代碼風格

每個工程師在設計時都該問自己：我寫的這段代碼有最好的利用算法嗎？在很多情況下，我們追求的不是結果質量達到極致，而是代碼更易於更改更靈活。雖然這其實是個因人而異的風格問題，但有些代碼風格確實會限制HLS工具產出的結構的質量。

舉例而言，在不同的工具中輸入圖1.8的代碼，圖1.10和圖1.11都是可能的產出結果。但是加入了圖1.12中的那些指令之後就會一定產出特定的一種結果。這個情況下延遲線被展開，乘積的for循環都被用流水的方式實施，產出的結構會於圖1.11中的結構相似。

{% hint style ='info' %} 本章介紹了很多不同處理率的方法，其中最快的甚至到了每週期一樣本的結構。但是，還有很多的應用需要更高的處理率，比如每週期多個樣本。這樣的設計需要怎樣的代碼呢？以設計一個每週期四樣本的FIR濾波器為例，這樣的設計需要多少資源（加法器和乘法器的數量）？與每週期一樣本相比哪個資源使用更多？ {% endhint %}

我們將會在第二章具體討論每種優化怎樣影響性能和資源使用。

## 1.5 重建代碼

寫出一個非常優化的HLS代碼不是一兩步就可以完成的工作，設計者必須對程序的應用有很深的理解，才能讓HLS工具利用指令產生最高效的結構。

在這本書接下來內容裏，我們會以應用為主題，討論幾個常見應用的綜合的過程，包括數字信號處理，排序，矩陣操作，視頻處理。理解算法是非常重要的一步，因為對代碼的調整經常不止於加幾句指令，有時候還需要重寫整段。

**重建代碼**，對於工具鏈來説經常變成很難讀懂的行為，需要與硬件對應好關係，所以它不僅要求對算法的理解還要求對硬件微結構有比較深的理解。一般來説現成的算法原代碼產出的結構比普通的CPU程序還低效，即使使用流水，展開等方法也沒起到太大的作用。所以最好的方法還是自己寫出一個等效但適合高層次綜合的算法。

重建代碼與它原來的軟件版本通常區別很大。一些研究指明重建是提升效率的非常重要的一步[[46](./BIBLIOGRAPHY.md#46),[47](./BIBLIOGRAPHY.md#47),[15](./BIBLIOGRAPHY.md#15),[14](./BIBLIOGRAPHY.md#14),[39](./BIBLIOGRAPHY.md#39)]。用户在寫重建代碼時一定要時刻分析潛在的硬件設計。

在本書接下來的內容裏，我們會展示之前提到的幾個應用程序用於產出硬件結構的代碼，具體包括FIR，離散傅里葉變換（DFT），快速傅里葉變換（FFT），稀疏矩陣乘矢量（SpMV)，矩陣相乘，排序，哈夫曼編碼。我們會討論重建代碼對最終硬件結構的影響，具體來説，針對每一章我們計劃：

1. 強調重建代碼對於高質量設計的重要性，比如在高性能和低使用面積上。
2. 對常見的內容提供重建的代碼
3. 討論重建對於硬件的影響
4. 使用必要的HLS指令以實現最好的設計

整本書來説，我們的示例會引導讀者從最基礎的設計到更有效的設計，因為我們相信理解來自於對示例的研究。每一章會採用不一樣的優化策略，包括流水，數據流，循環優化，數組分離，帶寬優化等等。另外，我們也會提供對於重建代碼必要的洞察訓練和知識。

## 1.6 本書結構

就像我們之前所説的，這本書的宗旨是以示例教學。每章將展示一個應用，逐步構建HLS，並一層層的優化。每章都只會用到一小部分優化策略，每章內容的難度也是逐步增加的。第二章我們會分析相對簡單的FIR濾波器，而到了第九章我們會分析複雜的視頻處理系統。

我們這樣的教學方法當然也是會有弊有利，我們認為好處主要體現在 ： 1）讀者可以清晰的看到優化是如何具體實施的 2）每一章都會展示怎麼具體的寫HLS代碼 3） 有些應用解釋起來比較簡單，但實際實施卻是另外一回事，簡單不完整的示例經常不夠讀者學習。

相對的，缺點主要在於：1）大多數應用還是要求讀者對計算和背景有一定的理解，而真正理解計算部分又有時需要比較深的數學背景。例如，FFT的最好結構需要讀者深入理解DFT和FFT的數學背景。出於這個原因，有一些章節（比如第四章DFT第五章FFT）以一些數學介紹為開頭。有些讀者認為這些數學知識對於具體實施HLS沒什麼幫助，但我們認為這部分內容對於代碼重建是非常必需的。 2）有時候一件沒那麼具體的示例其實能更好的概括代碼，具體示例中細枝末節反而會讓讀者很疑惑。

每章的結構大致相同，一般會以一些必要的背景介紹開始。對於大多數章節程序的背景介紹沒有程序本身聽上去那麼複雜，比如第七章矩陣相乘，但是還是有例如第四章DFT這樣的章節我們會介紹大量的數學知識。介紹之後我們會提供一個基準方法----一個不經過任何優化但是結果正確的HLS構建方法。然後我們就會開始介紹不同的優化。每章內容包含的優化內容也有多有少，像第三章只比較強調帶寬，第二章就描述了很多優化方法。一些非常關鍵的優化策略會貫穿全書被多次提到。

我們建議讀者按順序閲讀本書。像我們在第二章會介紹後面出現的大多數優化策略，然後在後續的章節才會對其中的一些策略深入講解。還有應用的難度也是逐漸增長的。但其實從各應用本身的內容上來説，各章交叉不大，所以如果讀者已經是一個比較有經驗的HLS設計師，那麼完全可以根據需要只讀某幾章某一章。比如説第十章排序，讀者如果已經有一定的HLS基礎就不需要從頭開始讀這本書。

下面的表1.1提供了一個各優化的總覽表，讀者可以看到每章使用了哪些優化，其中第二章除了各種對於FIR濾波器的優化之外，還簡單的介紹了一下HLS的設計過程。總體來説後面的章節會更注重某幾個優化並詳細介紹。

章節   | FIR | CORDIC | DFT | FFT | SpMV | 矩陣 | 直方圖 | 視頻 | 排序 | 哈夫曼
---- | --- | ------ | --- | --- | ---- | -- | --- | -- | -- | ---
展開循環 | x   |        | x   | x   | x    |    | x   |    | x  |
循環流水 | x   |        | x   | x   | x    |    | x   | x  | x  | x
帶寬優化 | x   | x      |     |     |      |    |     |    |    | x
函數內嵌 | x   |        |     |     |      |    |     |    |    | x
分層   | x   |        |     | x   |      |    | x   | x  | x  | x
數組優化 |     |        | x   | x   | x    | x  | x   | x  | x  | x
任務流水 |     |        |     | x   |      |    | x   | x  | x  | x
測試平台 |     |        |     |     | x    | x  |     |    | x  | x
一同仿真 |     |        |     |     | x    |    |     |    |    |
實時計算 |     |        |     |     |      | x  |     | x  | x  |
接口交互 |     |        |     |     |      |    |     | x  |    |

![表1.1:一個優化策略和章節的對照表](images/placeholder.png)

第三章到第五章可以算作一個系列，這個系列着重於建造數字信號處理模塊（CORDIC，DFT，FFT）。這些章節都側重於某一個優化策略，比如第三章的帶寬優化，第四章的數組優化，第五章的數組優化和任務流水。以第四章DFT為例，第四章介紹了數組優化，特別介紹了怎樣利用數組分離來提升片上內存帶寬。這一章也提到了展開循環和循環流水，並且講述了讓這些優化共存的方法。

第五章描述了快速傅立葉變換的優化，它其實本身就是DFT的一個重構代碼。FFT本身就是一個階段化很明顯的算法，所以非常適合任務流水。最終版優化代碼需要一些其他優化包括循環流水，展開，數組優化等。每一章其實都在附錄中的項目有所關聯，他們最終的集成到一起可以組成一個無線交流系統。

第六章到第十一章對更多的應用做出了講解。第六章講述瞭如何使用測試平台和RTL同仿真，還討論了一下數組和循環的優化。這些基本的優化策略很常見，在大多數程序中都有使用。第七章介紹了數據流的實時計算這個策略。第八章展示了兩種應用（前綴和，直方圖），這兩個應用本身相對簡單，但重建他們的代碼需要很小心的實行優化。第九章會用很大篇幅講述不同接口與交互的使用，比如視頻直播需要某種特定的總線與內存接口。除此之外還需要一些數組和循環的優化。第十章介紹了幾種排序算法，所以自然需要很大量的優化。最後一章則是建立了一個複雜的數據壓縮結構，會包含大量複雜的模塊。
