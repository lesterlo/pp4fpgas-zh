# 第二章 FIR濾波器

## 2.1 概述

​有限脈衝響應(FIR)濾波器在數字信號處理(DSP)領域中很常用——它們可能是這個領域應用最廣泛的運算。因為它們可以採用高度優化的體系結構，所以它們非常適合於硬件實現。它有一個關鍵特性：可對連續信號元素進行線性變換。這個特性可以很好的映射成一種數據結構（例如，FIFOs或者抽頭延時線），這些數據結構可以在硬件中高效實現。一般來説，流處理很適合在FPGA中映射實現，例如，在本書中介紹的大多數例子都包含某種形式的流處理。

​濾波器的兩個基本應用是信號重建和信號分離。信號分離更常用到:將輸入信號分離到不同部分。通常，我們認為它們是頻率範圍不同的信號。例如，我們可能設計低通濾波器，用來去除不感興趣的高頻信號。或者，我們為了解調某特定信號，設計一個帶通濾波器來篩選該特定信號頻率。例如，在頻移鍵控解調過程中隔離頻率。信號重建則是指濾除可能混入有用信號的噪聲和其他失真。例如，通過無線信道傳輸數據。信號重建包括平滑信號和移除直流分量。

​數字FIR濾波器經常處理由採樣連續信號產生的離散信號。最熟悉的是在時間上抽樣，即在離散信號下進行處理。這些處理都是在固定採樣間隔的條件下進行的。例如，我們用模數轉換器以固定時間間隔採樣天線的電壓。或者，也可以通過採樣光電二極管電流來測量光的強度。或者，在空間中採樣。例如，我們可以採樣一個由光電二極管組成的圖像傳感器不同位置的值，來創建一個數字圖像。在文檔[[41](./BIBLIOGRAPHY.md#41)]中可以找到對信號和採樣更深入的描述。

​採樣數據格式取決於應用場景。數字通信領域通常使用複數(in-phase和quadrature或I/Q值)來表示一個採樣數據。在本章後續，我們將設計一個複數FIR濾波器來處理這樣的數據。在圖像處理領域，我們經常把每個像素看作一個樣本。一個像素可以有多個字段，例如紅色、綠色和藍色(RGB)顏色通道。我們希望根據應用以不同的方式對這些通道進行濾波。

​本章目的是提供一個從選用算法到應用高級語言綜合進行算法硬件實現的基本流程。這個流程的第一步是對算法本身有深刻的理解。這使我們做代碼重構和設計優化更加容易。下一節介紹FIR濾波器的理論和計算。本章的其餘部分介紹對FIR濾波器進行各種基於HLS的優化。這是為了讓讀者對這些優化方式的有全面的認識。在後續章節中，每種優化方式都將進行詳細介紹。

## 2.2 背景                                                                           

​對濾波器輸入脈衝信號得到的輸出信號為該濾波器的 *脈衝響應* 。線性時不變濾波器的脈衝響應包含關於濾波器的完整信息。顧名思義，FIR濾波器（嚴格的線性時不變系統）的脈衝響應是有限的。在已知濾波器脈衝響應的前提下，我們可以通過*卷積*的方法算出該濾波器任意輸入的輸出響應。這個運算過程結合濾波器脈衝響應（又可稱為係數或階)和輸入信號用來計算輸出信號。濾波器的輸出也可以通過其他方式進行計算(例如，通過頻域計算)，而在本章中，我們關注時域計算。

​ N-階FIR濾波器的係數h[j]與輸入信號x[i]的卷積可由差分方程表示：

$$
y[i]=\sum_{j=0}^{N-1}h[j]\cdot x[i-j]\quad(2.1)
$$                                                                                   

注意，要計算一個N-階濾波器的輸出值，需要N個乘法和N-1個加法。

​ *滑動均值濾波器* 是低通FIR濾波器的一種簡單形式，其所有係數都是相同的且和為1。例如3點滑動濾波器，其係數h =[1/3, 1/3, 1/3]。同時由於它卷積核的形狀特點，它也被稱為矩形濾波器。或者你可以想象一個滑動均值濾波器，它將輸入信號的幾個相鄰樣本相加並求平均值。在上面卷積方程中，用1/N代替h[j]並對公式重新排布整理，達到對N個元素求平均值相似的效果:

 $$
 y[i]=\frac{1}{N}\sum_{j=0}^{N-1}x[i-j]\quad(2.2)
 $$       

​每個輸出信號可以按照上面公式計算，上面公式總共使用N−1次加法和一次乘數為1 / N的乘法。很多時候最後的乘法也可以被其它運算操作重新組合併合並。因此滑動均值濾波器比常規FIR濾波器更簡單。例如，當N = 3時，我們這樣運算來計算y[12]:

$$
y[12]=\frac{1}{3}\cdot (x[12]+x[11]+x[10])\quad(2.3)
$$

​這個過濾器是因果系統，這意味着輸出數據與當前輸入值及以前的數據有關。系統的因果特性是可以改變的，例如以當前樣本為數據中心時刻的處理，即y[12] = 1/3·(x[11] + x[12] + x[13])。雖然從根本上來説因果特性是系統分析的一個重要屬性，但是對於硬件實現來説它沒有那麼重要，一個有限非因果濾波器可以通過數據緩衝或者重排列來實現轉因果系統的轉換。

​滑動均值濾波器可以用來平滑信號，例如去除隨機(大部分是高頻)噪聲。隨着N的階數越高，我們會平均更多的樣本，相應的我們必須進行更多的計算。對於滑動均值濾波器，N值的增大等效於減小輸出信號帶寬。根本上講，它就像一個低通濾波器(雖然不是非常理想)。直覺上，這樣解釋是有意義的。當我們對越來越多的樣本進行平均時，我們消除了輸入信號中更高的頻率分量。也就是説，“平滑”等同於降低高頻分量。滑動濾波器是最優的減少白噪聲且同時保持最陡峭階躍響應的濾波器，即在給定邊緣鋭度的情況下把噪聲壓到最低。

​注意，通常來説濾波器係數可以用來精確地創建許多不同類型的濾波器:低通濾波器, 高通濾波器，帶通濾波器等等。一般來説，設計濾波器時，階數越大提供的自由度越多，設計濾波器的性能越好。有大量的文獻致力於為特定應用需求設計濾波器係數。在實現濾波器時，這些係數數值基本上是無關的，我們可以忽略係數本身是如何求得。但是，正如我們看到的滑動均值濾波器，濾波器的結構和特定係數對實現該濾波器需要執行的操作數可能會產生很大影響。例如，對稱濾波器有多個相同係數，我們可以將係數分組來減少乘法次數。在其他情況下，可以將固定濾波係數轉換為移位和加法運算[[34](./BIBLIOGRAPHY.md#34)]。在這種情況下，濾波器係數可以極大改變濾波器實現性能和所消耗資源[[52](./BIBLIOGRAPHY.md#52)]。但是我們要暫時忽略這一點，重點關注設計具有固定係數的濾波器結構特點，而不是單純利用固定係數濾波器運算。  

## 2.3 FIR結構基礎
​編程實現11階FIR濾波器代碼如圖2.1。這個函數有兩個端口，一個端口是輸入數據x和另一個端口是輸出結果y。由於每次執行該函數會提供一個函數輸入數據並接收一個函數輸出數據，多次調用這個函數後，完成整個輸出信號的計算。因為我們在獲取更多信號時這段代碼可以根據需求調用很多次，所以這段代碼可以方便地用流模式架構進行建模。

{% hint style='info' %}

​濾波器係數存儲在函數內部聲明的數組c[]中，定義為靜態常數。注意係數是對稱的。即它們以中心值c[5] = 500為鏡像對稱。許多FIR濾波器具有這種對稱性。我們可以利用這個特點來減少數組c[]所需的存儲容量。

{% endhint %}

​代碼對不同變量類型使用 **typedef**。雖然這不是必需的，但是可以方便地更改數據類型。正如我們後續要討論的位寬優化——特別是針對每個變量設定整數和分數位數——其在性能和資源方面優化顯著。

​ 重寫代碼利用濾波器係數的對稱性，也就是説優化C[]，使它含有6個因素(C[0]到C[5])，代碼的其餘部分還有那些改變？這些改變對資源有什麼影響？它如何改變性能？
```c++
#define N 11
#include "ap_int.h"  

typedef int coef_t;
typedef int data_t;
typedef int acc_t;

void fir(data_t *y,data_t x){
    coef_t C[N] = {
        53,0,-91,0,313,500,313,0,-91,0,53
    };
    static
    data_t shift_reg[N];
    acc_t acc;
    int i;
    acc = 0;
    Shift_Accum_Loop:
    for(i = N - 1;i >= 0;i--){
        if(i == 0){
            acc += x * C[0];
            shift_reg[0] = X;
        }else {
            shift_reg[i] = shift_reg[i - 1];
            acc += shift_reg[i] * C[i];
        }
    }
    * y = acc;
}
```

圖2.1：11階FIR濾波器代碼，該代碼功能正確但完全沒有優化。

​該代碼設計為流函數。它一次只接收一個數據，因此它必須存儲以前的數據。由於這是一個11階濾波器，我們必須存儲之前的10個數據。 這是shift\_reg[]矩陣的作用。因為矩陣數據在函數中被多次調用，所以該矩陣聲明為靜態類型。

​每次 **for** 循環有兩個基本運算。首先，它對輸入數據執行乘累加操作(當前輸入數據x和存儲在shift\_reg[]中之前輸入的數據)。每次循環執行一個常量與一個輸入數據的乘法，並將求和結果存儲在變量acc中。同時該循環通過shift\_array來實現數值移動，它的操作行為像FIFO。它存儲輸入數據x到shift\_reg[0]中，並通過shift\_reg將之前的元素“向前”移動:

``` c++
shift_array[10] = shift_array[9]
shift_array[9] = shift_array[8]
shift_array[8] = shift_array[7]
...
shift_array[2] = shift_array[1]
shift_array[1] = shift_array[0]
shift_array[0] = x
```

{% hint style='tip' %}

​Shift_Accum_Loop的標籤不是必需的，但是它對調試很有幫助。Vivado HLS工具將這些標籤添加到代碼視圖中。

{% endhint %}

​在for循環完成後，acc變量是所有輸入數據和FIR係數卷積運算的結果。最後的結果賦值到FIR濾波器函數輸出端口y。這就完成了按照流處理流程計算得到的FIR濾波器的一個輸出結果。

​這個函數沒有高效地實現FIR濾波器。它是串行執行的，並且使用了大量不必要的控制邏輯。後續部分將提供一些優化手段來提高它的性能。

## 2.4 計算性能

​在我們進行優化之前，有必要定義精確的度量。當評價設計性能時，必須仔細地説明度量。例如，有許多不同的方法來説明設計運行的“快速”。例如，你可以説運算速度為X 位/秒。或者它可以執行Y 操作/秒。 針對FIR濾波器運行速度的度量方法為濾波操作數/秒。然而，另一種度量方法是乘累加操作:MACs/秒。在某種程度上説每種度量方法都是相互關聯的，但是當比較不同的實現方法時同類比較就變得很重要。例如，將一個採用位/秒度量方法的設計與另一個使用濾波操作數/秒的設計直接進行比較，很可能會產生誤導;充分了解不同設計的相對優勢，需要我們使用相同的度量方法來比較它們，而這可能需要額外的信息。例如，從濾波操作數/秒等效成位/秒，需要了解關於輸入和輸出數據位寬的信息。

​前面提到的所有指標單位都是秒。高級語言綜合工具以時鐘週期數和時鐘頻率為評價單位。頻率與時鐘週期成反比。應用它們統計1秒內運算數量。時鐘週期數和頻率都很重要:一個工作頻率很低只需要一個時鐘週期的設計，不一定比工作頻率很高但需要10個時鐘週期的設計更好。

​優化時鐘週期的同時還要對時鐘頻率進行優化，這是Vivado HLS工具的一個複雜功能。注意可以使用TCL指令為為Vivado HLS工具指定目標運行頻率。例如,creat_clock -period 5 指令設置代碼運行時鐘週期5ns，即時鐘頻率200 MHz。請注意這只是一個目標時鐘頻率，它主要影響工具優化代碼為多少個運算操作。在生成RTL之後，Vivado HLS工具在這個時鐘頻率進行目標初始時序估計。然而電路性能還有一些不確定性存在，只有當設計在全部佈局佈線之後電路性能才能確定。

​雖然更高頻率在通常情況下是能達到更高性能的關鍵，但對於整個系統來説提高時鐘頻率並不一定是在整個系統中最優的優化方式。較低的時鐘頻率為工具在單個週期中組合多個相關操作提供了更多的時間餘量，這個過程叫做 *操作鏈接* 。在這個過程中，有些情況下可以通過提高邏輯綜合優化效果和增加適配器件的代碼規模來提高性能。改進的操作鏈接可以提高(或者降低)流水處理數據輸入間隔。一般來説，提供一個頻率約束但該頻率值不超過實際運行時鐘頻率。將時鐘週期約束在5−10ns的範圍內通常是一個好的開始。一旦你開始優化設計，你可以改變時鐘週期並觀察優化結果。我們將在下一節中詳細介紹操作鏈接。

​因為Vivado HLS處理的是時鐘頻率估計值，在估計中它確實包含了一些可能使估算出錯的餘量。這個餘量是保證在生成RTL電路時有足夠的時序餘量可以成功完成佈局佈線。這個餘量可以使用set_clock_uncertainty 的TCL腳本進行直接設置。注意此指令隻影響HLS生成RTL，與RTL級時序約束中時鐘不確定性不同。由Vivado HLS生成的對RTL實現流程的時序約束完全是基於目標時鐘週期的約束。

​把你的任務需求和計算性能度量結合起來是很有必要的。在我們示例中，fir濾波器每次執行都會有一個數據輸出。但是對於每一次fir運算我們執行的是N = 11次乘累加操作。因此如果你的度量指標單位是 乘累加/秒，你應該計算fir運算延遲秒數，然後除以11，得到一次乘累加操作需要的時間。

​當我們進行流水線和其他優化時，性能統計變得更加複雜。在這種情況下，理解處理間隔和處理延遲之間的區別是很重要的。現在是更新你對這兩個性能指標理解的好時機。關於這兩個指標我們已經在1.4章中討論過。後續我們將繼續討論不同優化策略如何對不同性能指標產生影響。

## 2.5 操作鏈接

​ *操作鏈接* 是Vivado HLS為了優化最終設計而進行地一項重要優化。儘管設計人員沒有太多控制權，但設計人員要明白它的工作原理尤其是在性能方面的影響，這是尤為重要的。考慮FIR濾波器在各階運算中做的是乘法累加操作。假設加法運算需要2個ns，乘法運算需要3個ns。如果我們把時鐘週期設為1ns（或者等效時鐘頻率1Ghz），那麼它要花費5個時鐘週期來完成乘累加操作。如圖2.2 a所示。乘法操作需要3個週期，加法操作需要兩個週期。乘累加操作總時間為5個時鐘週期×1ns = 5ns。因此我們處理性能為1/5ns = 2億次乘累加/秒。

![mac](/images/mac.jpg)

圖2.2:隨着時鐘週期的延長，乘累加操作的性能也會發生變化。假設乘法運算需要3個ns，加法運算需要2個ns。圖a)時鐘週期為1ns時，一個乘累加操作需要5個週期，因此處理性能是2億次乘累加/秒。圖b)時鐘週期為2ns，乘累加運算需要3個時鐘週期，因此處理性能約1.67億次乘累加/秒。圖c)時鐘週期個5ns。通過使用操作鏈接，乘累加操作需要一個時鐘週期，因此處理性能是2億次乘累加/秒。

​如果我們將時鐘週期增加到2ns，乘法運算用時將超過兩個週期，那麼加法操作必須等到第3週期才開始，它可以在一個週期內完成。因此乘累加操作需要3個週期，所以總共需要6ns。這時處理性能大約為1.67次乘累加操作 /秒。這個結果比之前1ns時鐘週期的要低。這個可以用第2個時鐘週期中沒有執行任何操作的“死時間”來解釋。

​然而增加時鐘週期並不是在所有情況下都會導致更糟糕的結果。例如，如果我們將時鐘週期設為5ns，我們可以使用操作鏈接將乘法和加法在同一個時鐘週期內執行。如圖2.2 c所示，因此乘累加操作在5ns的時鐘週期下只需要1個時鐘週期，因此我們可以執行2億次乘累加 /秒。這與圖2.2 a時鐘週期更快（1ns）的處理性能相同。

​到目前為止，我們可以在一個時鐘週期內只執行兩個操作。可以在一個時鐘週期內鏈接多個操作。例如，如果時鐘週期是10ns，我們可以按順序執行5個加法操作，或者我們可以實現兩個連續乘累加操作。

​顯而易見，時鐘週期在Vivado HLS優化設計的過程中起着重要作用。時鐘週期與Vivado HLS其他優化方式一起使用，使時鐘週期對設計優化的影響變得更加複雜。完全理解Vivado HLS整個優化過程並不重要，這個觀點是很明確的，因為每個新版本都在不斷改進提升這個工具的性能。然而，重要的是要了解這個工具是如何工作的。這更有利於你更好地理解優化結果，甚至使你編寫的代碼更加優化。

 ```c++
Shift_Accum_Loop:
for(i = N-1;i > 0;i--){
    shift_reg[i] = shift_reg[i-1];
    acc += shift_reg[i] * c[i];
}

acc += x * c[0];
shift_reg[0] = x;
 ```

圖2.3:將for循環中條件語句刪除，可以實現更有效的硬件結構。

​由於Vivado HLS對不同的時鐘頻率可以生成不同的硬件結構。因此整體性能的優化和最佳目標時鐘週期的確認仍然需要用户的創造力。在大多數情況下，我們建議堅持在小範圍時鐘週期內進行優化。例如在本章項目中，我們建議將時鐘週期設為10ns，並將重點放在理解不同優化手段(例如流水處理)如何用於創建不同的處理架構。100Mhz時鐘頻率是相對容易實現的，而且它提供了良好的初始結果。當然可以創建更快時鐘頻率的設計。200Mhz以及更快的頻率是有可能設計的，但這時經常需要在時鐘頻率和其他優化策略之間進行更好的權衡。你可以通過更改時鐘週期來觀察處理性能上的差異。不幸的是，並沒有好的準則來選擇最佳頻率。

{% hint style='info' %}

​將基本FIR架構的時鐘週期(圖2.1)從10ns改為1ns。哪個時鐘會提供最好的性能?哪個時鐘會是面積優化最優?你為什麼會這樣認為?你理解趨勢了嗎?

{% endhint %}

## 2.6 代碼提升

​for循環內部的if/else語句效率很低。在代碼中每個控制結構，Vivado HLS會生成硬件邏輯電路來檢查條件是否滿足，這個檢查在每個循環中都執行。此外，這種條件結構限制了if或else分支中語句的執行;這些語句只有在解決了if條件語句之後才能執行。

​當x==0時if語句進行檢查，這個只發生在最後一次迭代中。因此if分支中的語句可以從循環中“升起”。也就是説，我們可以在循環結束後執行這些語句，然後在循環中刪除if/else控制流。最後我們必須改變執行“第0次”迭代的循環邊界。這個轉換如圖2.3所示。這顯示了for循環所需要的更改。

 最終結果是實現一個更加緊湊的結構，適合進一步的循環優化。例如，展開和流水線。我們稍後討論這些優化。

{% hint style='info' %}

​對比刪除if/else之前和之後的實現結果。它們有哪些性能不同？它們的資源變化了多少？

{% endhint %}

```c++
TDL:
for(i = N - 1;i > 0;i--){
    shift_reg[i] = shift_reg[i - 1];
}
shift_reg[0] = x;

acc = 0;
MAC:
for(i = N-1;i >= 0;i--)
{
    acc += shift_reg[i] * c[i];
}
```

圖2.4:將for循環分解為兩個獨立循環的代碼片段。

{% hint style='info' %}

變化是什麼？

{% endhint %}

## 2.7 循環拆分

​我們在for循環中執行兩個基本操作。第一個是通過shift\_reg數組進行數據移位。第二個是進行乘累加運算來計算輸出樣本。循環分裂是分別在兩個循環中實現各自操作。雖然這樣做看起來不像是一個好主意，但是這樣做允許我們在每個循環上分別進行優化。這可能是有利的，尤其是在對不同循環進行不同優化策略的情況下。

​圖2.4中代碼顯示了手動循環拆分優化結果。代碼片段將圖2.3的循環分割成兩個循環。注意兩個循環的標籤名稱，第一個是TDL 第二個是MAC。延時線(TDL)是數字信號處理中FIFO操作的術語;MAC是“乘累加”的縮寫。

{% hint style='info' %}

​比較循環拆分前後，實現性能上有什麼不同?資源使用情況如何變化?

{% endhint %}

​每個循環單獨拆分往往不能提高硬件實現效率，但是它可以實現每個循環獨立地進行優化，這可能比優化原始的整體for循環更可能得到好結果。反之亦然;將兩個(或多個)循環合併到一個循環中也可能會產生最好的結果。對大多數優化來説，這高度依賴於應用場景。一般來説對於如何優化代碼沒有“最優法則”。優化思路不一樣導致優化過程也會有差異。因此重要的是要有很多可以使用的技巧，更好的是對優化工作原理有深入的瞭解。只有這樣，你才能是得到最好的硬件算法實現。讓我們繼續學習一些額外的技巧……

```c++
TDL:
for(i = N - 1;i > 1;i = i - 2){
    shift_reg[i] = shift_reg[i - 1];
    shift_reg[i - 1] = shift_reg[i - 2];   
}
if(i == 1){
    shift_reg[1] = shift_reg[0];
}
shift_reg[0] = x;
```

圖2.5:手動展開fir11函數中TDL循環。

## 2.8 循環展開

​默認情況下Vivado HLS 將循環綜合成順序執行方式。該工具創建了一個數據路徑，該路徑實現了循環體中語句的執行。數據路徑順序執行每次循環迭代運算。這就創建了一個有效的區域架構;但是它限制了在循環迭代中可能出現的並行運算。

​循環展開會通過循環次數(稱為因子)來複制循環的主體。每次循環迭代循環次數減少相同因子。在最好情況下，當循環中沒有任何語句依賴於前一次迭代生成的任何數據時，這時循環主體大大增加並行性，從而使系統運行速度更快。

​圖2.4中的第一個for循環(帶有標籤TDL)通過shift\_reg數組進行數據移位。循環迭代從最大值(N−1)到最小值(i = 1)。通過展開這個循環,我們可以創建一個並行執行的數據路徑進行移位操作。

​圖2.5顯示了以因子2將循環展開後的結果。此代碼重複循環主體兩次。每次循環迭代都執行兩個移位操作。因此我們迭代次數變為原來的一半。

​請注意，在for循環之後還有一個if條件判斷。當循環次數為奇數時，這個判斷是必需的。在這種情況下，我們必須自己執行最後一次“半”迭代。if語句中的代碼執行最後的“半”迭代，即將數據從shift\_reg[0]移動到shift_reg[1]。

​還要注意for循環展開開頭的結果。減量操作從i--變為i = i-2。這是因為我們在每次迭代中都做了兩次“工作”，因此我們應該減少2而不是1。

​最後，終止for循環的條件從i > 0變為i > 1。我們應該確保“最後一次”迭代能夠完成而不引發錯誤。如果最後的迭代循環執行i= 1,那麼第二個語句會試圖讀取shift_reg[−1]。我們為了不執行這個非法操作，所以在for循環之後的if語句中進行最後的移位操作。

{% hint style='info' %}

​編寫相應的代碼，按照因子3對這個TDL循環進行手動展開。這如何改變循環體呢?循環頭需要哪些更改?for循環之後的if語句附加代碼仍然是必需的嗎?如果是，那現在又有什麼不同呢?

{% endhint %}

​循環展開可以提高總體性能，前提是我們可以並行執行一些(或全部)語句。在展開代碼中，每次迭代要求我們從shift_reg數組中讀取兩個值;而且我們還要在同一個數組上寫兩個值。因此如果我們希望並行地執行這兩個語句，我們必須能夠在相同的週期內對shift_reg數組執行兩個讀操作和兩個寫操作。

​假設我們將shift_reg數組存儲在一個BRAM中，BRAM有兩個讀端口和一個寫端口。因此，我們可以在一個循環中可以執行兩個讀操作，但我們只能在兩個週期內順序進行寫操作。

​有一些方法可以在一個循環中執行這兩個語句。例如，我們可以將所有shift_reg數組的值存儲在獨立寄存器中。每個週期都可以對每個寄存器進行讀寫。在這種情況下，我們可以在一個循環中執行這兩條的語句。你可以使用指令#pragma HLS array_parition variable=shift_reg complete設置Vivado HLS ,使其將所有放在shift_reg數組中的值，放到寄存器中。這是一個重要的優化，因此稍後我們將詳細討論 array_partition 指令。

​用户可以使用unroll指令告訴Vivado HLS自動循環展開。為了自動實現圖2.5中手動完成的循環展開，我們應該將指令#pragma HLS unroll factor=2放入代碼的主體中，具體位置為for循環後面。雖然我們一直可以手動執行循環展開，但是允許工具為我們執行循環展開實現起來更容易，它使代碼更易閲讀;而且可以減少編碼錯誤。

{% hint style='info' %}

​使用Unroll指令將TDL循環自動展開。當你增加unroll因子時，資源(FFs、LUTs、BRAMs、dsp48等)的數量如何改變?它如何影響吞吐量?當使用數組分區指令與unroll指令一起使用時會產生什麼結果?如果你不使用unroll指令會產生什麼結果?

{% endhint %}

​現在考慮圖2.4中第二個for循環(帶有MAC標籤)。該循環將數組c[]中的值與shift_reg[]數組的值相乘。在每次迭代中，它要訪問兩個數組中第i個值。然後把乘法結果加到acc變量中。

​這個循環的每次迭代執行一次乘法和一次加法操作。每次迭代執行一次從數組shift_reg[]和數組c[]的讀取操作。將這兩個值相乘的結果累加到變量acc中。

​加載和乘法操作在for循環中是獨立的。加法操作取決於它是如何實現的，可能取決於前一次迭代運算的結果。但是，可以展開這個循環並刪除此迭代運算的依賴關係。

​圖2.6展示的代碼，該代碼進行展開因子為4的MAC循環展開。第一個for是展開的循環。for循環起始控制語句的修改與我們展開TDL的修改方式類似。運行範圍更改為i>=3，並且在展開循環的每次迭代中，i的值每次減少4。

​雖然在原始for循環內有依賴關係，但在循環展開的情況下，依賴關係優化沒了。循環依賴關係是由於acc變量的存在;由於每次迭代運算中乘累加的結果都要寫入到這個變量中，而且每次迭代也讀取這個寄存器值(以執行累加和)，它就形成了在迭代運算中一個讀寫的依賴項。注意由於編寫實現方式的改變，在展開後循環中不再有依賴acc變量項。因此在展開的for循環中我們可以自由地並行運算四個獨立MAC操作。

​在for循環展開之後還有一個加法for循環。這是執行任意剩餘部分迭代運算的必要條件。就像我們要求TDL中有if語句一樣，它在可能的最後一次迭代操作中進行運算。當展開的for循環初始的迭代次數不為4的倍數時就會出現這種情況。

```c++
acc = 0;
MAC:
for(i = N - 1;i >= 3;i -= 4){
    acc += shift_reg[i] * c[i] +
    shift_reg[i - 1] * c[i - 1] +
    shift_reg[i - 2] * c[i - 2] +
    shift_reg[i - 2] * c[i - 2] +
    shift_reg[i - 3] * c[i - 3];
}

for(;i >= 0; i--){
    acc += shift_reg[i] * c[i];
}
```

![圖2.6:在fir11函數中以展開因子4手動將MAC循環展開。](images/placeholder.png)

​再一次説明，我們可以通過將指令#pragma HLS unroll factor=4插入到MAC循環體中，控制Vivado HLS工具自動以因子4將循環展開。

​通過在指令中指定優化參數 skip_exit_check ，Vivado HLS將不會增加對循環最後部分迭代運算的檢查。當你知道循環永遠不需要這些最後部分的迭代時，跳過運算檢查是很有用的。或者執行最後幾次迭代運算不會對結果產生(主要的)影響，因此這些運算可以被跳過。通過使用這個指令，Vivado HLS工具不會創建額外的for循環迭代。因此產生的硬件更簡單，而且資源利用率更高。

​當沒有指定因子參數時for循環將完全展開。這相當於以最大迭代次數的展開;在這種情況下，完全展開和以因子11展開兩者是等效的。在這兩種情況下，循環主體都被複制了11次。而且循環控制沒有什麼作用;沒有必要保留一個計數器來檢查循環退出條件是否滿足。為了進行完整的展開，循環的邊界必須是靜態確定的，即在編譯時Vivado HLS必須能夠知道for循環的迭代次數。

​完整的循環展開實現程序最大程度的並行性，這樣的代價是需要很多資源。因此，可以在“較小”的循環上執行完整的循環。但是大迭代次數的循環展開(例如迭代一百萬次)通常是不可行的。通常情況下，Vivado HLS將運行很長一段時間(並且往往在經過幾個小時綜合之後都會失敗)，如果這樣的循環進行展開，它展開結果會是生成非常大的代碼。

{% hint style='tip' %}

​如果你的設計在15分鐘內不能綜合完成，你應該仔細考慮優化效果。當然大型設計可能會花費Vivado HLS大量時間進行綜合。但是作為一個初始的用户，你的設計應該相對快速地綜合完成。如果花了很長時間，那很可能意味着你以錯誤的方式使用了一些指令，明顯擴展了綜合代碼。

{% endhint %}

{% hint style='info' %}

 針對MAC循環，設置不同的展開因子，並綜合這一系列的設計。性能將如何變化?展開因子數是如何影響資源數量的?將這些結果與通過展開TDL而發現的趨勢進行比較。

{% endhint %}

## 2.9 循環流水

​在默認情況下，Vivado HLS以順序方式綜合循環操作。例如圖2.1中的For循環將依次執行循環中的每次迭代。也就是説，第二次迭代中的所有語句是在第一次迭代的所有語句完成時才會發生;對於後續的迭代也是如此。即使在並行執行的迭代語句中，也可能發生順序執行方式。其他情況下，在前一次迭代所有語句執行完成之前，可以啟動後續迭代中的一些語句。這種執行行為除非設計者明確指出它應該這樣做，否則不會自動發生。這產生了 *循環流水* 的思想，它允許同時執行多個循環迭代運算。

​考慮圖2.4中MAC循環。每次迭代執行一個乘累加(MAC)操作。在for循環體內部這個MAC運算四個操作:

- 讀取c[]:從c數組加載指定數據。
- 讀取 shift_reg[]:從shift_reg數組加載指定數據。
- ∗:數組c[]和shift_reg[]相乘。
- +:將這些相乘的結果累積到acc變量中。

​MAC for循環中一次迭代運算的流程圖如圖2.7 A所示。讀取操作需要兩個時鐘週期，這是因為第一個時鐘週期提供內存地址，第二個時鐘週期完成數據傳遞。由於這兩個操作之間沒有依賴關係，所以可以並行執行。* 操作可以從第2個週期開始;假設它花費三個週期才能完成，即完成時是第4個時鐘週期。在第4個週期，+操作開始並且能夠完成。因此整個MAC循環需要4個時鐘週期才能完成。

​有許多與for循環相關的性能指標。*迭代延遲* 是執行一次循環運算所需的時鐘週期數。MAC 循環迭代延遲為4個時鐘週期。for *循環延遲* 是完成整個循環所需的時鐘週期數。這個時鐘週期數包括初始化週期數(例如,i = 0),條件判斷週期數(例如,i>= 0),和增量計算週期數(例如,i−−)。假設這三個for循環控制語句與循環並行執行，Vivado HLS報告此MAC延遲為44個時鐘週期。這個時鐘週期數是由迭代的次數(11)乘以迭代延遲(4)，再加上一個判斷循環停止的額外週期，然後減去1。也許這裏唯一奇怪的是“減1”，我們後面就會講到。首先在下一次迭代開始時需要一個額外時鐘週期檢查條件語句是否滿足(不滿足)，然後退出循環。現在來解釋“減1”:Vivado HLS通過數據輸出就緒的時鐘週期來計算延遲。在這種情況下，最後一個數據在第43週期準備好。也就等效於在第43週期結束第44個週期開始時寫入一個寄存器。另一種計算延遲的方式為延時時鐘週期數量等於輸入數據和輸出數據之間的最大寄存器數。

![pipeline_mac](/images/pipeline_mac.jpg)

![圖2.7: a)表示MAC for循環時序圖。b)表示三個迭代運算用流水形式優化的MAC for循環。](images/placeholder.png)

​循環流水線是將for循環多個迭代運算進行重疊的優化。圖2.7 b)是MAC for 循環流水示例。圖中顯示同時執行三個迭代。第一個迭代等價於圖2.7 a中所示的非流水線版本，其區別是後續迭代運算的開始時間。非流水線版本，第二次迭代在第一次迭代完成後開始，即第5個時鐘週期。然而流水線版本第二次迭代可以第一次迭代完成之前啟動。在圖中，第二次迭代從第二個週期開始，第三次迭代從第三個週期開始。其餘的迭代在每個時鐘開始運算。因此，最後一次迭代即第11次迭代將從第11週期開始，並且在第14週期中完成，因此循環延遲是14。

​ *循環起始間隔*(II)是另一個重要的性能度量。它定義為本次循環到下一次循環開始的時鐘週期數。在本例中，循環II值為1，這意味着我們可以在每個週期中啟動新的迭代循環。圖2.7 b中圖形化地描述了這一點。II值可以使用指令進行設置。例如指令#pragma HLS pipeline II=2 設置 Vivado HLS 工具II=2。請注意由於代碼中的資源約束或邏輯依賴關係，II的設定值不一定總能實現。輸出報告將告訴你Vivado HLS工具能夠實現什麼目標。

{% hint style='info' %}

​設置II值為1，並以1的增量進行遞增。增加II的數值對循環延遲產生什麼樣的影響?趨勢是什麼?在某種程度上，將II設為更大的值是沒有意義的。這個例子中的值是多少?對於普通循環你如何描述II值?

{% endhint %}

​任何for循環都可以進行流水操作，現在我們考慮將TDL循環進行流水操作。TDL for循環有一個與MAC for循環相似的頭。循環主體是按照2.3節中介紹的方式進行數組元素移位。每次循環有兩個操作:一個讀，一個寫到shift_reg數組。循環迭代延遲為2個時鐘週期。讀操作需要兩個週期，寫操作在第二個週期末尾開始執行。for循環按照非流水操作需要20個時鐘週期。

​通過在循環頭部後面插入指令#pragma HLS pipeline II=1將這個循環進行流水優化。綜合的結果是循環間隔為1個時鐘週期。也就是説每個時鐘週期都可以開始循環迭代運算。

​通過對示例進行微小改動，我們可以演示當由於資源限制Vivado HLS工具不能實現II=1的情況。為此，我們要指明shift_reg數組的內存類型。我們也可以不指定資源，將它留給Vivado HLS工具來決定。但是我們使用指令來指定內存類型。例如，指令#pragma HLS resource variable=shift_reg core=RAM 1P 強制Vivado HLS工具使用單端口RAM。當使用該指令與循環流水優化相結合時，Vivado HLS工具將無法使用II=1來連接此循環。這是因為這段代碼流水操作需要在同一週期中同時進行讀寫操作。使用單端口RAM是不可能實現的。這在圖2.8 b中很明顯。注意第2個時鐘週期，我們需要在迭代1中完成對數據shift_reg的寫操作，在迭代2中對相同數組進行讀操作。我們可以刪除II=1的確定優化(例如，#pragma HLS pipeline)，從而允許HLS有更多調整自由度。在這種情況下，HLS將自動增加初始間隔，直到找到可行的流程表。

![pipeline_tdl](/images/pipeline_tdl.jpg)

![圖2.8:a)TDL for循環兩次迭代流程表。b)II=1，TDL for循環三次迭代流程表。](images/placeholder.png)

{% hint style='tip' %}

​RESOURCE指令允許用户強制設置Vivado HLS工具進行運算操作到硬件資源的映射方式。這種映射可以在矩陣（如上所示）同時也可以在變量中。思考代碼 a=b+c；我們可以用RESOURCE指令#pragma HLS RESOURCE variable=a core=AddSub_DSP 來告訴Vivado HLS工具，加法操作應DSP48資源來實現。在Vivado HLS文檔[63]中有各種硬件核資源描述。一般來説，建議讓Vivado HLS自己選擇實現資源。如果不能滿足要求，設計人員再進行約束。

{% endhint %}

## 2.10 位寬優化

​C語言提供了許多數據類型來描述各種操作。在這點上，我們已經應用的 **int** 類型，Vivado HLS將其視為一個32位帶符號整數。C語言還提供了浮點數據類型，例如 **float** 和 **double**，以及整數數據類型，例如 **char**、**short**、**long** 和 **long long**。整數數據類型可能都是正數。所有這些數據類型位寬都是2的冪次。

​這些C語言數據類型實際位寬可能由於處理器架構不同而不同。例如，**int** 類型在微處理上可以是16位，通用處理器上可能是32位。C標準規定最小位寬(例如， **int** 類型至少為16位)和各類型之間關係(例如，**long** 類型不小於 **int** 類型，**int** 類型不小於 **short** 類型)。C99語言標準消除了這種含糊不清規定，並定義多種類型，如int8_t、int16_t、int32_t和int64_t。

​使用這些不同數據類型首要好處是解決軟件中大量數據存儲容量問題。對於大型數組，使用8bit而不是16bit可以將內存容量要求減少一半。缺點是可以8bit表示值的範圍減少了。有符號8bit數據表示範圍為[-128,127]，而有符號16bit數據表示範圍是[-32768,32767]。位寬較小數據類型的相關操作可能需要更少的時鐘週期，或者可以實現更多指令並行操作。

​在FPGA實現中也可以看到相同好處，但這種好處更加明顯。由於Vivado HLS工具生成自定義數據路徑，它將生成與指定數據類型相匹配的實現結果。例如,語句a = b∗c根據運算數據類型它會有不同的延遲和資源使用情況。如果所有變量都是32位寬，那麼需要執行的原始布爾操作要比僅為8位寬的變量多。因此，必須使用更多的FPGA資源(或更復雜的資源)來實現。此外，更復雜的邏輯通常需要更多流水線來實現相同頻率。一個32位乘法可能需要5個內部寄存器來達到與使用一個內部寄存器的8位乘法相同的運算頻率。因此，操作延遲將更大(5個週期而不是1個週期)，而應用HLS必須考慮到這一點。

{% hint style='info' %}

​創建一個簡單設計,實現代碼a = b∗c。變量類型分別更改為**char**,**short**,**int**,**long**,**long long**。在每種情況下，相乘運算需要多少個週期?不同的運算類型分別需要多少資源?

{% endhint %}

{% hint style='info' %}

​8bit數值計算需要什麼類型原始布爾操作？當進行32bit數值計算這些需求有什麼變化？提示：需要多少原始十進制操作才能實現兩個8位十進制數值乘法？

{% endhint %}

​在許多情況下為了優化硬件資源，需要處理位寬不是2的冪次的數據。例如，模數轉換器通常輸出結果為10bits，12bits，或14bits。我們可以將這些值映射到16bits，但這可能會降低處理性能並增加資源消耗。為了更準確表示這些值，Vivado HLS提供了任意精度數據類型，這些數據類型可以表示為有符號或者無符號任意位寬數據。

​有符號和無符號的數據類型有兩個單獨的類:
* 無符號：ap_uint <width>
* 有符號：ap_int<width>


width是1到1024之間的整數。例如，ap_int<8>是一個8位有符號數(和char一樣)，ap_uint<32>是一個32位無符號數(與unsigned int相同)。它有一個更強大的數據類型，這種數據類型可以任意設置位寬。例如，ap_uint<4>或ap_int<537>。要使用這些數據類型，你必須使用c++並且包含頭文件ap_int.h，即在你的項目中添加#include“ap_int.h”代碼，並在添加“.cpp”文件名後綴。

考慮圖2.1fir 濾波器代碼中濾波器係數數組c[]。在這裏復現是為了閲讀方便:coef_t c[N] ={53, 0,-91, 0, 313, 500, 313, 0,-91, 0,53};。數據類型coef_t被定義為int，意思是我們有32位精度。32位精度對於濾波器係數來説是多餘的，因為它們的範圍從-91到500。因此，我們可以使用較小的數據類型。由於數值有正有負，所以我們需要一個有符號的數據類型。這11個數據的最大絕對值是500，而log~2~(500) = 9bits。又因為我們需要負數，我們再加1位。因此，coef_t可以聲明為ap_int<10>。

{% hint style='info' %}   

​在fir函數中，變量i適合的數據類型是什麼(見圖2.1)?

{% endhint %}
我們還可以更準確地定義fir函數中其他變量的數據類型，例如acc和shift_reg。首先考慮shift_reg數組。它是存儲輸入變量x最新更新的11個值，因此我們可知shift_reg值可以安全的擁有與x相同的數據類型，用“安全”的意思是，在精度上沒有損失，即，如果shift\_reg設成較小位寬的數據類型，那麼輸入數據X就需要刪除一些重要數據位，來滿足shift_reg的存儲要求。例如，如果x被定義為16位(ap\_uint<16>)，而shift_reg被定義為12位(ap\_uint<12>)，那麼當我們將x變量數值存儲在shift\_reg變量中時，我們就會去掉x變量中4個最重要的數據位。

 為變量acc定義適當的數據類型是一項更加困難的任務。acc變量存儲了shift_reg和濾波器係數數組c[]的乘積加總和，即濾波器輸出值。如果我們希望安全，那麼我們將估算可能存儲在acc中的最大值，並將數據位寬設為和該值一樣。

 為實現這一點，我們必須瞭解在執行算術運算時，位寬如何增加。考慮運算a = b + c，其中b為ap\_uint<10> 、c為ap\_uint<10> ，那麼變量a的數據類型是什麼?在這裏我們可以做一個最壞情況的分析，假設a和b都是最大值 $$2^(10) = 1024$$。二者相加結果為a = 2024，可以表示為11位無符號數，即，ap\_uint< 11 >。一般來説，在做加法時，運算結果要比兩個加數中最大數值的位寬還要多一位。也就是説，當ap\_uint<x> b和ap_uint<y> c相加時，a的數據類型為ap\_uint<z>，其中 z = max(x, y) + 1。這個結論同樣適用於有符號數加法。

 通過以上方法解決了acc數據類型設計的部分問題，但是我們還必須處理乘法運算。使用相同的術語，我們希望通過x和y的數據位寬來確定數值z的數據位寬(即，ad_int<z> a , ap_int<x> b,ap_int<y> c)。對於運算a = b∗c，我們不再詳細介紹,位寬的運算公式為z = x + y。

{% hint style='info' %}

​提供以上兩個公式來確定acc安全位寬。

{% endhint %}

​最終，我們將acc存儲到變量y中，y是函數的輸出端口。因此,如果acc的位寬大於變量c的位寬,acc的值將被截斷並存儲到y。因此,更重要的是確保acc位寬足夠大,以便它可以處理完整精度的乘積加操作嗎?

​問題答案在於應用場景對於精度的要求。在許多數字信號處理應用中，數據本身是有噪聲的，這意味着較低的數據位數可能沒有意義。此外，在信號處理應用中，我們經常在處理數據時進行數值近似，而導致額外誤差的引入。因此，我們確保acc變量精度使其返回一個完全精確的結果可能並不是最重要的。另一方面，為了減少計算中整體的舍入誤差，最好在積累過程中保留更多比特，然後再針對最終的結果進行截位。其他應用如科學計算，通常需要更大動態範圍，在這種應用下更多使用浮點數而不是整數或定點運算。那麼正確的答案是什麼?最終取決於設計者對於精度的要求。

## 2.11 複數FIR濾波器

​到目前為止，我們只研究了實數數字濾波器。許多數字無線通信系統都由實部 (I)和虛部 (Q)組成的複數數字系統(更多的細節見第三章)。幸運的是，我們可以使用實數 FIR 濾波器來創建複數FIR濾波器，如下所述。

​考慮方程2.4來理解如何利用實數FIR濾波器建立複數FIR濾波器。假設(Iin, Qin)是我們希望輸入濾波器的一個數據。其中複數FIR濾波器係數表示為$$(I_{fir}, Q_{fir})$$。處理系統中將會有不止一個輸入樣本和複數濾波器係數，但我們現在不用擔心這點。

$$
(I_{in}+ j Q_{in})(I_{fir} + j Q_{fir}) = (I_{in}I_{fir} - Q_{in} Q_{fir}) +  j (Q_{in}  I_{fir} + I_{in}Q_{fir}) \quad(2.4)
$$                            

​方程2.4顯示了複數FIR濾波器的一個係數與輸入複數數據的乘法。方程右側顯示覆數FIR濾波器輸出實數部分是$$ I_{in}I_{fir} - Q_{in}Q_{fir} $$，和虛數部分為$$ Q_{in}I_{fir} + I_{in}Q_{fir} $$。這意味着我們可以將複數FIR過濾器運算拆分為四個實數濾波器，如圖2.9所示。

![complex_fir](/images/complex_fir.jpg)

圖2.9:一個複數FIR濾波器由4個實數FIR濾波器組成。輸入的I和Q樣本被分配到4個不同的實數FIR濾波器中。FIR濾波器存儲實部(FIR I)和虛部(FIR Q)複數係數。
 ```c++
typedef int data_t;
void firI1(data_t *y,data_t x);
void firQ1(data_t *y,data_t x);
void firI2(data_t *y,data_t x);
void firQ2(data_t *y,data_t x);

void complexFIR(data_t Iin, data_t Qin,data_t *Iout,data_t *Qout){

    data_t IinIfir,QinQfir,QinIfir,IinQfir;

    firI1(&IinIfir,Iin);
    firQ1(&QinQfir,Qin);
    firI2(&QinIfir,Qin);
    firQ2(&IinQfir,Iin);
    * Iout = IinIfir + QinQfir;
    * Qout = QinIfir - IinQfir;
}
 ```
圖2.10:Vivado HLS使用四個實數FIR濾波器分層實現一個複數FIR濾波器。

​複數FIR濾波器輸入數值是複數$$(I_{in}, Q_{in})$$並輸出複數的過濾結果$$(I_{out}, Q_{out})$$。圖2.9描述了複數濾波器的原理框圖，複數濾波器使用了四個實數FIR濾波器(FIR I1, FIR Q1, FIR I2, FIR Q2)。濾波器FIR I1和FIR I2是等效的，即它們的係數相同。FIR Q1和FIR Q2也是相同的。每個濾波器的輸出對應於一個等式2.4的因子。然後對這些輸出進行加法或者減法，來得到最終濾波的複數輸出結果(I~out~, Q~out~)。

​我們使用層次化結構來定義複數FIR濾波器。Vivado HLS使用函數來實現層次化結構。使用前面的實數FIR函數 **void** fir(data\_t * y, data_t x)，我們可以創建封裝了實數fir函數的複數FIR濾波器。此代碼如圖2.10所示。

​該代碼定義了四個函數firI1、firQ1、firI2和firQ2。每個函數都是完全相同的代碼，即圖2.1中的fir函數。通常，我們不需要複製函數;而是簡單地調用同一個函數四次。然而，這在本例中是不可以的，因為fir函數中shift_reg變量使用了 **static** 關鍵字。

​函數調用充當接口。Vivado HLS工具不能跨越函數邊界進行優化。也就是説，每個fir函數都被獨立綜合，並且在complexFIR函數中或多或少的被當作一個黑盒來處理。如果你希望Vivado HLS工具針對某個特定函數在其父函數中共同與其它代碼共同優化，你可以使用inline指令。這個指令將該函數代碼添加到父函數中，並消除層次結構。雖然這有提高性能和資源面積優化，但是它也產生了需要工具綜合的大量代碼。代碼綜合可能需要很長時間，甚至會綜合失敗，或者導致不可優化設計。因此，要小心使用內聯指令。還要注意，Vivado HLS工具可以自動進行函數內聯。這些函數通常具有少量代碼。

```c++
float mul(int x,int y){
    return x * y;
}
float top_function(float a,float b,float c,float d){
    return mul(a,b) + mul(c,d) + mul(b,c) + mul(a,d);
}
float inlined_top_function(float a,float b,float c,float d){
    return a * b + c * d + b * c + a * d;
}
```

​圖2.11:一個簡單的例子説明inline指令。top_function有四個函數調用mul函數。如果我們在mul函數中添加inline指令，其結果與inline_top_function函數結果類似。

{% hint style='tip' %}

​inline指令去除了函數邊界，這使Vivado HLS對代碼可以進行額外優化，但這種額外優化方式可能帶來複雜的綜合問題，例如，它將使編譯時間變長。同時它在執行函數調用時將排除頂層關聯。它有多種方式維持代碼結構，同時使層次結構更加易讀。​圖2.11所示代碼提供了一個inline指令如何工作的示例，inline_top_function函數是應用mul函數應用inline指令的結果。

​Vivado HLS在某些情況下自動應用inline指令。例如，圖2.11由於mul函數很小，工具很有可能對該函數進行inline操作。你可以通過inline指令的off參數來可以強制工具保持函數層次結構。​inline指令也有遞歸參數，即在inline函數中，其調用的子函數也inline處理。也就是説所有子函數都會把代碼展開到母函數中。這個可能會導致代碼膨脹，因此這個功能要謹慎使用。​ 一個inline函數不會有單獨報告，因為所有的邏輯已經融合到了母函數中。

{% endhint %}

## 2.12 總結

​本章描述了使用Vivado HLS工具進行FIR濾波器的設計和優化。文章目標是提供HLS處理過程概況。處理的第一步是理解FIR濾波器計算背後的基本概念。這並不需要深刻的數學理解，但肯定要有足夠的知識可以編寫Vivado HLS工具能夠綜合的代碼。這可能需要進行不同語言(例如，MATLAB、Java、C++、Python等)的轉換。很多時候為了應用更簡單的數據結構程序代碼需要重構。例如，明確指明數據資源類型。同時這經常需要刪除系統調用和HLS工具不支持的代碼。

​創建一個優化的體系結構需要對HLS工具如何進行綜合以及對RTL代碼優化過程有基本理解。當然，精確地理解時序表、綁定、資源分配等等HLS算法是沒有必要的(而且很多時候這些都是有專利的)。但是，對這個過程有一個大致瞭解，可以幫助設計師編寫出與硬件匹配更好的代碼。縱觀整章，我們討論了HLS綜合過程的一些關鍵特性，這些特性是進行各種優化必須要理解的。尤其重要的是要理解HLS性能報告，關於性能報告我們在第2.4章中已經對此進行了描述。

​此外，我們還介紹了一些基本HLS優化方法(包括循環和位寬優化)。我們以FIR濾波器設計為例強調了它們的優點和潛在缺點。這些都是常見的優化，可以廣泛應用於各種場景。在接下來的章節，我們通過討論其他更復雜的應用場景，來介紹更多關於這些優化的細節。
