# 第三章 CORDIC

## 3.1 概述

​   CORDIC(座標旋轉數字算法)是一種計算三角、雙曲和其他數學函數的有效方法。它是一種數字算法，每次運算均產生一次結果輸出。這使我們能夠根據應用需求調整算法精度；增加運算迭代次數可以得到更精確的結果。運算精度與運算性能和佔用資源並列，是一種通用的設計評估指標。CORDIC是隻使用加法、減法、移位和查找表實現的簡單算法，這種算法在FPGA中實現效率高，在硬件算法實現中經常用到。

{% hint style='tip' %}

CORDIC算法是1950年由Jack Volder發明，它最開始是作為數字解決方案替代模擬方案應用於B-58轟炸機實時導航上，它的功能是計算旋轉角度。在那個時代用硬件實現乘法的成本是相當高的，同時CPUs的計算能力也非常有限。因此這個算法需要有低的運算複雜度和使用簡單的運算操作。多年之後，它被應用於數學協處理器[[24](#24)]、線性系統[[3](#3)]、雷達信號處理[[4](#4)]、傅立葉變換[[21](#21)]和其它數字信號處理算法中。現在，它廣泛應用於FPGA設計中。Vivado HLS用CODIC進行三角函數計算，同時CORDIC也是現代FPGA IP CORE庫中的標準運算模塊。

{% endhint %}

​   本章目標是演示如何使用高級語言創建優化CORDIC算法。隨着本書的深入，我們研究設計的硬核複雜性也在逐漸增加。CORDIC算法是一種迭代算法；因此，大多數計算都在一個**for**循環中執行。代碼本身並不複雜，但是用來創建最優硬件實現結構是需要設計人員對代碼有深入理解的。一個優秀的HLS設計人員如果希望創建最優設計，就必須理解算法。因此，我們在本章前部分給出了CORDIC算法的數學和計算背景。

![圖3.1：使用CORDIC方法計算sinφ和cosφ。在這裏，CORDIC算法從X軸正半軸開始，對應的角度為0度，然後執行四次或順時針或逆時針的旋轉，每次旋轉的角度越來越小，最終得到目標角度φ。一旦旋轉完成，得到的角度就與理論的角度十分接近了。如果我們假設向量的長度為1，那麼最終向量在x,y的分量就分別對應cosφ和sinφ。我們改善CORDIC算法的關鍵在於提升以上過程的計算效率。](images/cordic_overview.jpg)

​   我們在本章強調的HLS主要優化方式是為變量選擇正確的數據表示。正如我們在本章後面所討論的，設計人員必須仔細權衡運算結果精度、性能和設計的資源利用率。數據表示是這種權衡的一個重要因素—“較大”數字（那些大位寬數據)，通常是以增加使用資源(更多的寄存器和邏輯塊)和降低處理性能為代價來提供更精確數據。我們將在第3.5.5節中提供了關於數據表示和任意精度數據類型的背景。

​   本章與工程應用相結合，針對運算精度(計算的準確性)、資源佔用和處理性能的權衡進行了更深入的實驗。本章目的是提供足夠的知識經驗，以便人們可以在這個項目中進行練習，例如，這一章和那個工程是相互補充的。那個工程的目標是建立一個相位探測器，它使用了一個CORDIC和一個複數匹配濾波器，這個濾波器我們在前一章中已經介紹過它了。

## 3.2 背景

​   CORDIC核心思想是在一個二維平面上高效地執行一組矢量旋轉。在這些旋轉運算的基礎上增加一些簡單控制，我們就可以實現各種基礎操作，例如，三角函數，雙曲函數，對數函數，實乘和復乘，以及矩陣分解和因式分解。CORDIC已經廣泛應用於信號處理、機器人技術、通信和許多科學計算領域。由於CORDIC佔用資源少，所以常用在FPGA設計中。

​   在下文中，我們將介紹CORDIC如何執行給定輸入角θ的正弦和餘弦的過程。這是使用一系列矢量旋轉來完成的，這些簡單的操作在硬件中使用非常有效。在高層次，算法使用一系列旋轉來工作，目標是達到目標輸入角θ。實現這種效率的關鍵創新是旋轉可以以需要最少計算的方式完成。尤其我們使用乘以2的常數冪來執行旋轉。這意味着簡單地在硬件中移動位是非常有效的，因為它不需要任何邏輯。
     
​   圖3.1提供了用於計算cosφ和sinφ的CORDIC程序的高級概述。在這種情況下，我們在x軸上開始初始旋轉矢量，即0°角。然後，我們執行一系列迭代旋轉;在這個例子中，我們只執行四次旋轉，但通常這是40次旋轉。每個後續旋轉使用越來越小的角度，這意味着每次迭代都會為輸出值增加更多精度。在每次迭代中，我們決定以較小的角度進行正向或負向旋轉。我們旋轉的角度值是先驗固定的;因此，我們可以輕鬆地將它們的值存儲在一個小內存中，並保持我們到目前為止已經旋轉的累積角度的運行總和。如果該累積角度大於我們的目標角度φ，則我們執行負旋轉。如果它更小，那麼旋轉就是正的。一旦我們完成了足夠數量的旋轉，我們就可以通過直接讀取最終旋轉矢量的x和y值來確定cosφ和sinφ。如果我們的最終向量的幅度為1，則x =cosφ且y =sinφ。

我們從一些術語開始，目的是重新定義你的一些基本的三角函數和矢量概念。 如果熟悉的話就不必看了。 但請記住，創建高效硬件設計最重要的一個方面是真正理解應用程序; 只有這樣，設計師才能有效地利用優化指令並執行代碼重構，這是獲得最有效設計所必需的。

CORDIC算法的基本目標是以有效的方式執行一系列旋轉。 讓我們首先考慮如何進行旋轉。 在二維中，旋轉矩陣是：

$$
R(\theta) = \begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta
\end{bmatrix}
\quad(3.1)
$$

CORDIC使用迭代算法將矢量v旋轉到某個角度目標，這取決於CORDIC正在執行的功能。 一次旋轉是$$v_{i} = R_{i} * v_{i-1}$$形式的矩陣向量乘法。 因此，在CORDIC的每次迭代中，我們執行以下操作來執行一次旋轉，即矩陣向量乘法：
$$
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta
\end{bmatrix}\begin{bmatrix}
x_{i-1} \\
y_{i-1}
\end{bmatrix}
= \begin{bmatrix}
x_i \\
y_i
\end{bmatrix}
\quad(3.2)
$$

寫出線性方程，新旋轉矢量的座標是：
$$
x_i = x_{i-1}  \cos \theta - y_{i-1}  \sin \theta \quad(3.3)
$$
和
$$
y_i = x_{i-1} \sin \theta + y_{i-1} \cos \theta \quad(3.4)
$$

這正是我們需要簡化的操作。 我們想要執行這些旋轉而不執行任何乘法。
首先考慮90°旋轉。 在這種情況下，旋轉矩陣是：
$$
R(90^\circ) = \begin{bmatrix}
\cos 90^\circ & -\sin 90^\circ \\
\sin 90^\circ & \cos 90^\circ
\end{bmatrix} = \begin{bmatrix}
0 & -1 \\
1 & 0
\end{bmatrix}
\quad(3.5)
$$
因此我們只需要執行操作：
$$
\begin{aligned}
x_i &= x_{i-1}  \cos 90^\circ - y_{i-1} \sin 90^\circ \\
 &= x_{i-1} \cdot 0 - y_{i-1} \cdot 1  \\
 &= -y_{i-1}
\end{aligned}
\quad(3.6)
$$
和
$$
\begin{aligned}
y_i &= x_{i-1} \sin  90^\circ + y_{i-1} \cos 90^\circ  \\
 &= x_{i-1} \cdot 1 + y_{i-1} \cdot 0  \\
 &=  x_{i-1}
\end{aligned}
\quad(3.7)
$$
把這放在一起，我們可以得到
$$
\begin{bmatrix}
0 & -1 \\
1 & 0 \\
\end{bmatrix}\begin{bmatrix}
x \\
y
\end{bmatrix}
= \begin{bmatrix}
-y \\
x
\end{bmatrix}
\quad(3.8)
$$

可以看到這需要的計算非常少;旋轉矢量簡單地使y值無效，然後交換x和y值。二進制補碼需要等效於加法器的硬件。因此，我們實現了有效執行90°旋轉的目標。

{% hint style='info' %}
如果你想在-90°之間旋轉怎麼辦？什麼是旋轉矩陣R(-90°)？ 旋轉需要什麼類型的計算？如何設計能夠通過-90°執行正負旋轉的最有效電路，例如旋轉方向是電路的輸入？
{% endhint %}

雖然我們可以旋轉±90°，但如果我們希望在旋轉到目標角度時都有好的分辨率，我們需要旋轉更小的角度。也許我們可能希望旋轉的下一個自然角度是±45°。使用公式3.1中的旋轉矩陣得到

$$
R(45^\circ) = \begin{bmatrix}
\cos 45^\circ & -\sin 45^\circ \\
\sin 45^\circ & \cos 45^\circ
\end{bmatrix} = \begin{bmatrix}
\sqrt 2/2 & -\sqrt 2/2 \\
\sqrt 2/2 & \sqrt 2/2
\end{bmatrix}
\quad(3.9)
$$

計算旋轉操作數值，我們可以得到


$$
x_i = x_{i-1}  \cos 45^\circ - y_{i-1} \sin 45^\circ = x_{i-1} \cdot \sqrt 2/2  - y_{i-1} \cdot \sqrt 2/2  \quad(3.10)
$$

和

$$
y_i = x_{i-1} \sin  45^\circ + y_{i-1} \cos 45^\circ= x_{i-1} \cdot \sqrt 2/2 + y_{i-1} \cdot \sqrt 2/2  \quad(3.11)
$$

 把計算結果代入矩陣向量運算
$$
\begin{bmatrix}
\sqrt 2/2 & -\sqrt 2/2 \\
\sqrt 2/2 & \sqrt 2/2 \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
= \begin{bmatrix}
\sqrt 2/2 x - \sqrt 2/2 y \\
\sqrt 2/2 x + \sqrt 2/2 y \\
\end{bmatrix}
\quad(3.12)
$$

與旋轉±90°相比，這肯定不如計算效率高。 ±90°旋轉是理想的，因為乘法運算的倍數是非常簡單的常數（在這種情況下為0,1和-1）。 CORDIC的關鍵是以有效的方式進行這些旋轉，例如用容易的乘法計算的方式定義旋轉矩陣。 也就是説，我們希望更像前一個±90°，而不像我們剛剛描述的±45°旋轉那樣更難計算。

如果我們“強制”旋轉矩陣成為易於乘法的常數怎麼辦？ 例如，乘以2的任意冪可以轉變為移位操作。 如果我們將旋轉矩陣中的常量設置為2的冪，我們可以非常容易地執行旋轉而不需要乘法。 這是CORDIC背後的關鍵理念 - 找到非常有效的旋轉計算，同時最大限度地減少任何副作用。 我們將更詳細地討論這些“副作用”，但這裏有一個工程決策。 為了獲得高效的計算，我們必須放棄一些東西; 在這種情況下，我們必須處理這種情況，即旋轉也會執行縮放，即它會改變旋轉矢量的大小 - 稍後會更多。
為了進一步探索“簡單”旋轉矩陣，請考慮矩陣

$$
R() = \begin{bmatrix}
1 & -1 \\
1 & 1 \\
\end{bmatrix}
\quad(3.13)
$$
轉換成相應的計算形式
$$
x_i = x_{i-1}  - y_{i-1}\quad(3.14)
$$
和

$$
y_i = x_{i-1}  + y_{i-1}\quad(3.15)
$$

​用矩陣向量的形式表示

$$
\begin{bmatrix}1 & -1 \\ 1 & 1 \end{bmatrix}\begin{bmatrix}x \\ y \end{bmatrix}= \begin{bmatrix}x - y \\x + y \end{bmatrix} \quad(3.16)
$$

​   這個很容易計算，而且不需要任何“困難”的乘法。但這次運算結果是什麼呢?結果證明這次運算實現了完美的45度旋轉；現在，我們得到了一個高效方式來實現一次45度旋轉。但是，這個變換也把矢量以$$\sqrt{2}$$進行了量化。這個矩陣行列式的平方根表明變換量化矢量的大小，即，矢量長度是如何變化的。這裏矩陣行列式為1 \cdot 1−(−1) \cdot 1 = 2。因此,這個操作實現角度旋轉45度和尺度變化$$\sqrt{2}$$倍。這是CORDIC運算進行的折中;我們可以使旋轉運算變得容易，但它的副作用是縮放矢量的長度。根據應用場景不同，這不一定是個問題。但是現在，我們暫時不考慮縮放問題，集中討論如何推廣高效旋轉操作。

​   現在我們介紹高效矩陣旋轉概念，即，只進行加/減和2的冪次乘法運算(即移位操作)。再考慮旋轉矩陣

$$
R_{i}(\theta) = \begin{bmatrix} \cos(\theta_{i}) & -\sin(\theta_{i}) \\\sin(\theta_{i}) & \cos(\theta_{i})\end{bmatrix}\quad(3.17)
$$

通過使用下面的三角恆等式

$$
\cos(\theta_{i}) =  {\frac{1}{\sqrt{1 + \tan^2(\theta_{i})}}} \quad(3.18)
$$

$$
\sin(\theta_{i})  =  \frac{\tan(\theta_{i})}{\sqrt{1 +\tan^2(\theta_{i})}} \quad(3.19)
$$

我們可以將旋轉矩陣變為

$$
R_i = \frac{1}{\sqrt{1 + \tan^2(\theta_i)}} \begin{bmatrix} 1 & - \tan(\theta_i) \\ \tan(\theta_i) & 1 \end{bmatrix} \quad(3.20)
$$

​   如果我們限制$$tan(\theta_i)$$的值是2的冪次,那麼旋轉運算可以簡化為數據移位（乘法）和加法。具體為,我們設$$tan(\theta_i)= 2^{-i}$$。旋轉矩陣就變成了

$$
v_i = K_i \begin{bmatrix} 1 & - 2^{-i} \\  2^{-i} & 1 \end{bmatrix}\begin{bmatrix} x_{i-1} \\ y_{i-1} \end{bmatrix} \quad(3.21)
$$

其中

$$
K_i = \frac{1}{\sqrt{1 + 2^{-2i}}} \quad(3.22)
$$
這裏有幾點需要注意。$$2^{-i}$$相當於數據向右移動i位，即，等效於2的冪次除法。這基本上可以等效為一個簡單的不需要任何資源的結構，即，在硬件實現上，它基本上是“無消耗”的。這是一個巨大的優點，但它也存在一些缺點。首先，我們受限只能旋轉角度θ,其中$$tan(\theta_i)= 2^{-i}$$。後續我們將證明這不是什麼嚴重問題。第二，我們只展示了一個方向的旋轉；而CORDIC要求能夠旋轉$$\pm\theta$$。這個可以通過添加σ值（1或−1）來表示正向或者逆向旋轉來修正這個錯誤。我們可能在每次迭代/旋轉中有不同的$$\sigma_i$$ 。因此旋轉操作可概括為

$$
v_i = K_i \begin{bmatrix} 1 & -\sigma_i 2^{-i} \\ \sigma_i 2^{-i} &1 \end{bmatrix} \begin{bmatrix} x_{i-1} \\ y_{i-1} \end{bmatrix} \quad(3.23)
$$

最後，旋轉矩陣需要乘以$$k_i$$，在迭代過程中$$k_i$$通常被省略，然後在一系列旋轉完成後進行補償。比例因子累積為

$$
K(n) = \prod_{i=0}^{n-1} K_i  = \prod_{i=0}^{n-1}\frac {1}{\sqrt{1 + 2^{-2i}}} \quad(3.24)
$$

和

$$
K = \lim_{n \to \infty}K(n) \approx 0.6072529350088812561694 \quad(3.25)
$$

​   不同迭代的比例因子可以預先計算並存儲。如果我們總是做固定次數的旋轉，這個比例因子就是一個常數。這種修正也可以在旋轉之前適當地縮放$$v_o$$來提前進行。有些情況下可以忽略這個比例因子，但這會導致處理增益。

$$
A = \frac{1}{K} = \lim_{n \to \infty} \prod_{i=0}^{n-1} {\sqrt{1 +2^{-2i}}}\approx 1.64676025812107 \quad(3.26)
$$

在每次迭代中,我們需要知道剛剛執行的旋轉角$$\theta_i$$。其中$$\theta_i =arctan2^{-i}$$。我們可以提前計算每一個i對應的$$\theta_i$$值，然後把它們存儲在片上內存中，之後我們可以像用查找表一樣用這些值。此外，我們還有一個決定是順時針還是逆時針旋轉的機制，即，我們必須確定σ的值為1還是−1。這個決定取決於所需CORDIC的模式。例如,計算cosθ和sinθ,我們保存所有旋轉角度的累加和。我們比較這個值和目標角θ的大小，如果當前累加和的角度小於θ則執行正向旋轉，如果當前累加和大於θ則我們進行逆向旋轉。

​   表3.1提供了CORDIC前7次迭代的統計信息。第一行是“零”旋轉(即 i = 0),這是一次 45度旋轉。它的比例因子為1.41421。第二行旋轉因子為$$2^{-1} = 0.5$$。這個結果的旋轉角度為$$\theta=arctan(2^{-1}) = 26.565^\circ$$,這個旋轉的比例因子為1.11803。CORDIC增益是所有比例因子的積。在這個例子中，它的比例因子是前兩個比例因子之積，即，1.58114 = 1.41421*1.11803。這個過程i的數值在增加，而旋轉角度和比例因子越來越小。值得注意的是CORDIC比例因子最終趨於穩定≈1.64676025812107 數值正如公式3.26。另外，請注意，當旋轉角度變小時，它們對數據精度的影響也逐步減弱。

{% hint style='info' %}

描述第i次迭代對結果精度的影響?也就是説，它改變了哪幾位?更多的迭代運算如何改變最終結果的精度，例如。當CORDIC迭代次數增加時 sinθ和cosθ的值發生怎樣的變化?

{% endhint %}

​   表3.1:CORDIC前7次迭代的旋轉角度、比例因子和CORDIC增益。注意，角度每次迭代大約減小一半。比例因子表示在旋轉過程中旋轉矢量增加的長度。CORDIC增益是所有旋轉矢量比例因子的累積，例如，某一次迭代的CORDIC增益是本次迭代和與該次迭代之前所有比例因子累積。

| i    | $$2^{-i}$$ | Rotating Angle   | Scaling Factor | CORDIC Gain |
| ---- | -------- | ---------------- | -------------- | ----------- |
| 0    | 1.0      |$$45.000^\circ$$   | 1.41421        | 1.41421     |
| 1    | 0.5      | $$26.565^{\circ}$$ | 1.11803        | 1.58114     |
| 2    | 0.25     | $$14.036^{\circ}$$ | 1.03078        | 1.62980     |
| 3    | 0.125    | $$7.125^{\circ}$$  | 1.00778        | 1.64248     |
| 4    | 0.0625   | $$3.576^{\circ}$$  | 1.00195        | 1.64569     |
| 5    | 0.03125  | $$1.790^{\circ}$$  | 1.00049        | 1.64649     |
| 6    | 0.015625 | $$0.895^{\circ}$$  | 1.00012        | 1.64669     |

## 3.3 計算正弦和餘弦

​   現在我們可以更精確地使用CORDIC計算一些給定角θ的正弦和餘弦值。為了計算正弦和餘弦值，我們從x軸正方向上的一個矢量開始(例如，初始角度45度)，然後執行一系列旋轉直到我們逼近給定角θ。之後，我們可以直接讀取旋轉矢量的x和y值，這兩個值即為對應cosθ和sinθ。這裏假設最終矢量幅度等於1，你會看到計算正餘弦並不難實現。

​   讓我們用一個示例來具體説明：計算 $$sin60^\circ$$ 和 $$cos60^\circ$$ ，即，$$\theta= 60^\circ$$。這個過程如圖3.2所示。在這個例子中我們執行了五次旋轉得到一個角度近似為$$ 60^\circ $$。我們初始矢量為0度即它從x軸正半軸開始。第一次旋轉對應序號i = 0旋轉了45度角(見表3.1)。由於我們想要得到$$60^\circ$$,所以我們沿正方向旋轉。矢量旋轉後得到$$45^\circ$$角;同時還要注意，它的幅度約為1.414。現在，我們繼續序號i = 1的旋轉。因為我們希望得到$$60^\circ$$角,所以我們沿正方向旋轉。矢量旋轉之後的結果角度為$$45^\circ+ 26.565^\circ = 71.565^\circ$$,比例因子為1.118;

![圖3.2用CORDIC算法計算 cos60 和 sin60 。使用遞增數i(0，1，2，3，4)來表示執行五次旋轉，最終旋轉結果為61.078度 。這個矢量對應的x和y值可以近似為指定角度的餘弦和正弦值。](images/sin_cos_cordic.jpg)

​   兩次旋轉得到的比例因子為1.414×1.118 = 1.581，這也是CORDIC增益。繼續討論 i= 2,現在我們得到的角大於 $$60^\circ$$ 的目標角,所以我們要沿負方向旋轉，旋轉後矢量角度為 $$57.592^\circ$$ 比例因子為1.630。整個過程伴隨i值不斷增大，同時旋轉角度越來越小，最終會近似達到期望角度。同樣，請注意隨着旋轉次數的增加，CORDIC增益逐漸趨於穩定。

​   當我們做了足夠多的旋轉後，數據精度將會滿足我們的要求，最後我們得到一個與期望輸入角近似的矢量。這個矢量的x和y值，對應 $$A_{R}$$ $$cos60^\circ$$和 $$A_{R}$$ $$sin60^\circ$$ ,如果$$A_{R}$$ = 1, 那麼這個x與y的值正是我們想要得到的。由於我們通常知道將要執行的旋轉次數，所以我們可以通過將預設初始矢量的大小為CORDIC增益的倒數來確保$$A_{R}$$ = 1, 在我們的例子中,假設執行了五次旋轉,如圖3.2,可知需要設置初始矢量的值為$$1.64649^{-1} = 0.60735$$(當i=5時CORDIC增益的倒數;見表3.1)。由此，我們可以直接設置一個初始矢量為(0.60735，0)。

{% hint style='info' %}

​   如果我們再多做一次旋轉，結果會變成怎樣?再多做兩次旋轉(三次，四次，等等)會怎麼樣?當我們執行更多的旋轉，精度會變成多少(例如，與MATLAB運算相比)?在一般情況下，你認為幾次旋轉是適合的?

{% endhint %}

{% hint style='info' %}

​   做更多的旋轉有沒有可能會使精度變得更差?提供一個發生這種情況的例子。

{% endhint %}

​   圖3.3提供了使用CORDIC算法實現正弦和餘弦值計算的代碼。它將輸入角作為目標角，輸出這個角對應的正弦和餘弦值。代碼使用數組cordic_phase作為查找表，這個查找表存儲每次迭代的旋轉角度。這個角度對應於表3.1中的“旋轉角度”列中的值。我們假設cordic.h文件定義不同的數據類型(例如,COS_SIN_TYPE和THETA_TYPE)並設置NUM_ITERATIONS為某個常數。數據類型可以更改為不同的定點或浮點類型，設置NUM_ITERATIONS值要同時考慮我們期望的精度、資源和吞吐量。

{% hint style='tip' %}

​   注意變量sigma被設置為一個二位寬整數。因為我們知道它的可能取值只有±1，我們可以優化它的數據類型使它比使用int類型有更小的資源佔用和更佳的性能。我們稍後將討論如何在Vivado HLS中指定它們的數據類型。

{% endhint %}

```c++
//The file cordic.h holds definitions for the data types and constant valuse

#include "cordic.h"

//The cordic_phase array holds the angle for the current rotation
THETA_TYPE cordic_phase[NUM_ITERATIONS] = {
    45, 26.56, 14.036, 7.125
    3.576, 1.790, 0.895, ...    
};

void
cordic(THETA_TYPE theta, COS_SIN_TYPE &s, COS_SIN_TYPE &c)
{
    //Set the initial vector that we will rotate
    //current_cos = I;current = Q
    COS_SIN_TYPE current_cos =0.60735;
    COS_SIN_TYPE current_sin = 0.0;

    //Factor is the 2^(-L) value
    COS_SIN_TYPE factor = 1.0;

    //This loop iteratively rotates the initial vector to find the
    //sine and cosine value corresponding to the input theta angle
    for(int j = 0; j < NUM_ITERATIONS; j++){
        //Determine if we are rotating by a positive or negative angle
        int sigma = (theta < 0) ? -1 : 1;

        //Save the current_cos,so that it can be used in the sine calculation
       COS_SIN_TYPE temp_cos = current_cos;

        //Perform the rotation
        current_cos = current_cos - current_sin * sigma * factor;
        current_sin = temp_cos * sigma * factor + current_sin;

        //Determine the new theta
        theta = theta - sigma * cordic_phase[j];

        //Calculata next 2^(-L) value
        factor = factor >> 1;
    }

    //Set the final sine and cosine values
    s = current_sin;c = current_cos;
}
```

圖3.3:CORDIC代碼實現計算給定角度的正弦和餘弦值。


![圖3.4:圖中顯示了一個二維平面和一個同時用笛卡爾形式(x,y)和極座標形式(r,θ)表示的矢量,通過該矢量説明這兩個座標系之間的關係。](images/rotation.jpg)

​   此代碼接近於“軟件”版本。它有多種方式來提高其性能並減小資源面積。我們將在本章後面討論如何優化這段代碼。

## 3.4 笛卡爾向極座標轉換

​   通過一些修改，CORDIC可以實現其它功能。例如，它可以實現笛卡爾和極座標系轉換；我們將在本節詳細地描述這一點。CORDIC還可以做其他很多功能，我們把它留給讀者作為練習。

​   一個二維矢量v可以使用笛卡兒座標系統(x,y)或極座標系統(r,θ)來表示，對於極座標系r是半徑座標(矢量的長度)和θ是角度座標。這兩種座標系都有優缺點。例如，如果我們想做一個旋轉，那麼極座標形式更容易實現，而笛卡爾座標系更適合描述線性變換。

​   兩種座標系之間的轉換關係如下式所示：

$$
\begin{aligned}
x = r \cos \theta \quad(3.27) \\
y = r \sin \theta \quad(3.28) \\
r =\sqrt{x^2 + y^2} \quad(3.29) \\
\theta = atan2(y, x) \quad(3.30)
\end{aligned}
$$

atan2在arctan函數中定義為

$$

atan2(y, x) =
\begin{cases}
\arctan(\frac{y}{x})     \quad\quad\quad      {if } x > 0 \\
\arctan(\frac{y}{x}) + \pi   \quad  {if } x < 0 { and } y \ge 0 \\
\arctan(\frac{y}{x}) - \pi   \quad  {if } x < 0 { and } y < 0 \\
\frac{\pi}{2}             \quad \quad\quad    {if } x = 0 { and } y > 0 \\
-\frac{\pi}{2}        \quad\quad\quad         {if } x = 0 { and } y < 0 \\
\text{undefined}      \quad\quad\quad         {if } x = 0 { and } y = 0
\end{cases}

$$

​   這裏提供了一種在兩個座標系之間轉換的方法。然而，這些操作在硬件中並不容易實現。例如，sine，cosine，平方根和arctan都不是簡單操作，它們需要大量的運算資源。但是我們可以使用CORDIC算法通過一系列簡單的迭代旋轉來實現這些操作。

​   給定一個用笛卡爾座標系表示的數(x, y)，我們使用CORDIC算法可以計算它的角度和幅度座標(即，將它轉換成極座標形式)。為實現這一點，我們將給定的笛卡爾座標系下的數據旋轉為0度。一旦這個旋轉完成，幅度就是最終旋轉矢量的x值。要確定角度座標，我們只需關注CORDIC執行旋轉的累計角度。矢量旋轉(i=0第一次旋轉、i=1第二次旋轉、i=3第三次旋轉……)的角度可以存儲在查找表中，用來計算sine /cosine。因此，我們只需要通過對這些角進行加減就可以得到總的旋轉角度，而這裏的加減操作取決於旋轉方向。

​   該算法與計算給定角的正弦和餘弦相似。我們執行一系列帶有遞增值i的旋轉，使最終的矢量位於(靠近)x的正半軸上（即0度)。這可以用正旋轉或負旋轉來實現，正負旋轉取決於矢量的y值，而這個矢量的幅度和角度值都是我們希望確定的。

​   算法執行第一步旋轉得到的初始矢量在象限I或者IV。旋轉 $$90^\circ$$ 的正負取決於初始矢量的y值。如果y值是正數，我們可以推算出我們在第I或者第II象限。反向旋轉-$$90^\circ$$ 將使我們進入IV或者I象限。一旦我們進入這些象限中,我們可以保證最終能夠漸近的接近目標角度0度。如果在象限III或象限IV，初始矢量y值將是負的。我們要做一個 $$90^\circ$$ 正向旋轉，讓我們進入IV和I象限。回想一下, $$\pm90^\circ$$ 的旋轉是通過將矢量的x和y值求反，然後將兩個值互換實現。關於旋轉 $$\pm90^\circ$$ 的情況在圖3.5中説明。

​   這裏存在旋轉矢量最終徑向數值的問題；它的大小與旋轉前初始大小不同；它受CORDIC增益的影響。當然，也可以通過乘以對應CORDIC增益的倒數(例如，1/1.647 = 0.607)來精確計算矢量徑向值。然而，這違背了設計CORDIC算法避免乘法運算的目的。不幸的是，這種乘法不能簡單地使用移位和加法來實現。幸運的是，這個因素通常並不重要。例如，在無線通信中用於調製的調幅鍵控中，你只需要知道相對幅度。或者在其他應用中，這個振幅增益可以由系統的其他部分來補償掉。

![圖3.5：笛卡爾座標系轉換為極座標系的第一步是執行一個正或負90度的旋轉，這次旋轉的目的是為了使初始矢量到象限I或IV。一旦矢量到了這兩個象限，後續的旋轉將使矢量到達最終角度0◦。此時，初始矢量的徑向值是最終旋轉矢量的x值，初始矢量的角度是CORDIC所做旋轉角度累加和。a)和b)展示了一個初始y值為正的例子，這意味着矢量位於象限I或II中。旋轉-90度將它們旋轉到相應象限中。c)和d)給出了類似的情況，當初始矢量y值為負值時，我們希望旋轉+90度使矢量轉到第I或第IV象限。 ](images/cordic_magnitude_angle.jpg)

## 3.5 數字表示

​   cordic函數使用當前常用的變量類型。例如，變量sigma被定義為int類型，其他變量使用自定義數據類型(例如，THETA_TYPE和COS_SIN_TYPE)。在許多情況下，HLS工具能夠進一步優化這些值，來實現硬件資源優化。舉個例子,在圖3.3中,變量sigma的值為1或−1，即使已經將變量聲明為至少包含32位位寬的int類型，在不改變程序功能的情況下，可以用更少的位數用來實現。在其它情況下，特別是變量經常出現在函數輸入、存儲和遞歸中，HLS工具不能針對變量進行自動優化。在這些情況下，修改代碼使用較小的數據類型是避免資源浪費的重要優化手段。


​   雖然減少變量位寬通常是一個好的優化方法，但是這種優化方法可能改變程序的行為。一個小位寬數據類型不能像大位寬數據類型那樣表徵大量信息，而且無限的二進制數可以表示所有無限精度的實數。幸運的是，作為設計人員，我們可以選擇符合特定需求的精度，並且可以在精度、資源佔用和性能之間進行權衡。

​   在進一步討論cordic函數數值表示方法之前，我們首先介紹數值表示的背景知識。我們提供基礎知識，因為這在理解Vivado HLS所提供的數據類型進行數值表示時非常重要。下一節將從數值表示的基本背景開始講解，然後討論Vivado HLS中可用的任意精度變量。

### 3.5.1 二進制和十六進制數

​   計算機和fpga通常使用二進制來表示數據，這使數據可以由開關信號組成的二進制數字或簡單的位來有效地表示。二進制數在大多數情況下都像普通的十進制數一樣工作，但是如果你不熟悉它們的工作原理，它們常常會導致混淆錯誤，在許多嵌入式系統和fpga中尤其如此，在這些系統中，最小化數據位寬可以極大地提高系統總體性能和效率。在本節中，我們將總結二進制算法以及計算機表示數字的基本方法。

​   許多讀者可能熟悉這些知識，如果是這樣的話，你可以略讀這些部分或完全跳過它們。我們建議閲讀第3.5.5節，因為那裏針對Vivado HLS説明了怎樣定義任意的數據類型，這是一個用來進行CORDIC數值優化的重要方法。


​   當我們表示一個普通整數，例如4062，它可以表示成(4 \* 1000)+(0 \* 100)+(6 \* 10)+(2 \* 1) = 4062，或者我們可以按如下方式表示

| $$10^3$$ | $$10^2$$ | $$10^1$$ | $$10^0$$ | unsigned |
| ------ | ------ | ------ | ------ | -------- |
| 4      | 0      | 6      | 2      | = 4062    |

​   二進制數表達方式與這個相似，不過沒有用到數字0到9和10的冪。二進制數用0和1以及2的冪來表示數值

| $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ | unsigned |
| ----- | ----- | ----- | ----- | -------- |
| 1     | 0     | 1     | 1     | = 11      |

​   因為(1 * 8) + (0 * 4)  + (1 * 2) + (1 * 1) = 11。為了避免歧義，二進制數經常在前邊加“0b”，這個使0b1011很明顯表示的是十進制11而不是數值1011。二進制數最高位是*最關鍵*的位置，同時二進制數最低位是*最不重要*的位置。

​   十六進制數用0到15和16的冪次來表示數值

| $$16^3$$ | $$16^2$$ | $$16^1$$ | $$16^0$$ | unsigned |
| ------ | ------ | ------ | ------ | -------- |
| 8      | 0      | 3      | 15     | = 32831   |

​   為了避免歧義，數字10到15表示為字母“A”到“F”，同時十六進制數據前綴“0x”，因此在c語言中上面的數值可表示為0x803F。

​   注意，二進制同樣可以表示小數，這種類型數據通常叫做定點數，通過簡單的拓展這種形式也可以表示負數。因此"0b1011.01"等效於：

| $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ | $$2^{-1}$$ | $$2^-2$$ | unsigned |
| ----- | ----- | ----- | ----- | ------ | ------ | -------- |
| 1     | 0     | 1     | 1     | 0      | 1      | = 11.25   |

​   因為8 + 2 + 1 + 1/4 = 11.25。不幸的是，C標準沒有提供二進制表示常數的形式，儘管gcc和一些其他的編譯器允許整型常數（沒有小數點），這些常量前邊會加“0b”。C99標準提供了一種描述浮點常數的方法，這種方法通過十六進制和指數來表示，注意指數是無法省略的，甚至值為0的情況下也不能省略。

```C++
float p1 = 0xB.4p0;//Initialize p1 to "11.25"
float p2 = 0xB4p-4;//Initialize p2 to "11.25"
```

​   一般來説，對於一個無符號數，只需要填寫數值中非零的數字，沒有顯示的數字都可以假設為零。因此，用更多的數字表示相同的值很容易：只要添加儘可能多的零就可以了。這個過程通常稱為零擴展。注意，每個附加的數字都增加了可以表示數值的範圍。在二進制數中每添加一位，可以使表示的數字範圍增加一倍，而在十六進制數字中每增加一位會使可表示的數字範圍增加16倍。

| $$2^7$$ | $$2^6$$ | $$2^5$$ | $$2^4$$ | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ | $$2^{-1}$$ | $$2^-2$$ | $$2^-3$$ | $$2^-4$$ | unsigned |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ------ | ------ | ------ | ------ | -------- |
| 0     | 0     | 0     | 0     | 1     | 0     | 1     | 1     | 0      | 1      | 0      | 0      | =11.25   |

 {% hint style='tip' %}

​   注意，二進制數可以定義為任意位寬，而不僅僅是8、16和32位。例如System C[ [2](#2) ]通過定義一系列模板類，可以實現任意精度整數和定點數（包括 sc_int<>,sc_uint<>,sc_bigint<>,sc_ubigint<>,sc_fixed<>,和sc_ufinxed<>）儘管它們最初是為系統模型定義的，而不是為了綜合，但這些類在HLS工具中可以廣泛使用。Vivado HLS包含相似的模板類（ap_int<>,ap_uint<>,ap_fixed<>,和ap_ufixed<>）這些類在通常情況下在仿真和綜合上都會比SystemC類性能好。

{% endhint %}

{% hint style='info' %}

​   通過使用0值，任意精度數被很好的定義(雖然用處不大)。列出所有能用0位數字表示的數字。

 {% endhint %}

### 3.5.2 負數

​   負數的表示比正數稍微複雜一些，一定程度上是因為它有不同的表示方法。一種簡單的方法是用符號位表示負數，通常稱為有符號幅值表示。這種表示只是在數字前面添加了一個額外的位，以表示它是否有符號。有符號幅值表示法的奇怪之處是，有不止一種方法可以表示0。這使得有些簡單操作例如 **operator == ()** 實現起來更加複雜。

| +/-  | $$2^1$$ | $$2^0$$ | signed magnitude |
| ---- | ----- | ----- | ---------------- |
| 0    | 1     | 1     | = 3               |
| 0    | 1     | 0     | = 2               |
| 0    | 0     | 1     | = 1               |
| 0    | 0     | 0     | = 0               |
| 1    | 0     | 0     | = -0              |
| 1    | 0     | 1     | = -1              |
| 1    | 1     | 0     | = -2              |
| 1    | 1     | 1     | = -3              |

​   另一種表示負數的方法是用偏移碼錶示。這種表示方法是增加了一個常量偏移(通常等於最高位數值)，否則視為正數：

| $$2^2$$ | $$2^1$$ | $$2^0$$ | biased |
| ----- | ----- | ----- | ------ |
| 1     | 1     | 1     | = 3     |
| 1     | 1     | 0     | = 2     |
| 1     | 0     | 1     | = 1     |
| 1     | 0     | 0     | = 0     |
| 0     | 1     | 1     | = -1    |
| 0     | 1     | 0     | = -2    |
| 0     | 0     | 1     | = -3    |
| 0     | 0     | 0     | =- 4    |

​   然而，到目前為止，最常用的用於實現負數的技術被稱為“二進制補碼”。二進制補碼中最重要的位表示數值的符號(即數值表示為符號+大小)，二進制補碼也表示偏移量是否可以用。理解這種表示方法的思路是將最高位表示成對應位寬的負數。

| -$$2^2$$ | $$2^1$$ | $$2^0$$ | two's complement |
| ------ | ----- | ----- | ---------------- |
| 0      | 1     | 1     | = 3               |
| 0      | 1     | 0     | = 2               |
| 0      | 0     | 1     | = 1               |
| 0      | 0     | 0     | = 0               |
| 1      | 1     | 1     | = -1              |
| 1      | 1     | 0     | = -2              |
| 1      | 0     | 1     | = -3              |
| 1      | 0     | 0     | = -4              |

​

| -$$2^4$$ | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ | two's complement |
| ------ | ----- | ----- | ----- | ----- | ---------------- |
| 0      | 0     | 0     | 1     | 1     | = 3               |
| 0      | 0     | 0     | 1     | 0     | = 2               |
| 0      | 0     | 0     | 0     | 1     | = 1               |
| 0      | 0     | 0     | 0     | 0     | = 0               |
| 1      | 1     | 1     | 1     | 1     | = -1              |
| 1      | 1     | 1     | 1     | 0     | = -2              |
| 1      | 1     | 1     | 0     | 1     | = -3              |
| 1      | 1     | 1     | 0     | 0     | = -4              |

​   無符號數與二進制補碼之間的一個重要區別是，我們需要確切地知道數值有多少位來表示，因為最高位與其它位代表不同的意義。此外，當擴展帶符號的二進制補碼時要複製符號位到所有新增的比特位。這個過程通常稱為符號位擴展。在本書的其餘部分中，除非另有説明，我們通常假設所有帶符號的數字都用二進制補碼錶示。

{% hint style='info' %}

​   N位二進制補碼能表示的正數最大是多少?最大的負數是多少?

{% endhint %}

{% hint style='info' %}

​   給定一個正數x,如何用二進制補碼來表示−x?−0的二進制補碼是什麼?如果x是N位二進制補碼所能表示的最大的負數,那麼−x是什麼?

{% endhint %}

### 3.5.3 溢出、下溢和舍入

​   當一個數值大於給定位寬所能表示的最大值時，就發生*溢出*(Overflow)。類似地，當一個數值小於可以表示的最小值時，就發生*下溢*(Underflow)。處理溢出或下溢的常見方法是簡單地刪除原始數字中最重要的位，這個操作通常稱為*包裝*(Wrapping)。

| $$2^5$$ | $$2^4$$ | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ | $$2^{-1}$$ | $$2^-2$$ | $$2^-3$$ | $$2^-4$$ |        |
| ----- | ----- | ----- | ----- | ----- | ----- | ------ | ------ | ------ | ------ | ------ |
| 0     | 0     | 1     | 0     | 1     | 1     | 0      | 1      | 0      | 0      | =11.25 |
|       | 0     | 1     | 0     | 1     | 1     | 0      | 1      | 0      | 0      | =11.25 |
|       |       | 1     | 0     | 1     | 1     | 0      | 1      | 0      | 0      | =11.25 |
|       |       |       | 0     | 1     | 1     | 0      | 1      | 0      | 0      | =3.25  |

​   通過包裝二進制補碼的方式解決溢出和下溢的問題可能會導致正數變為負數，負數變為正數。

| $$-2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ | $$2^{-1}$$ | $$2^{-2}$$ | $$2^{-3}$$ | $$2^{-4}$$ | two' complement ||
| ------ | ----- | ----- | ----- | -------- | -------- | -------- | -------- | --------------- |
| 1      | 0     | 1     | 1     | 0        | 1        | 0        | 0        | =-4.75          |

| $$-2^2$$ | $$2^1$$ | $$2^0$$ | $$2^{-1}$$ | $$2^{-2}$$ | $$2^{-3}$$ | $$2^{-4}$$ | two' complement |
| ------ | ----- | ----- | -------- | -------- | -------- | -------- | --------------- |
| 0      | 1     | 1     | 0        | 1        | 0        | 0        | =3.25           |

​   同樣，當一個數值不能通過給定小數位數來精確地表示時，需要採用*舍入*來解決這個問題。同樣，這有幾種常見的方法來對數值進行舍入。最簡單的方法就是去掉額外不能表示的小數位數，但這樣就會使數值變的更負。這種舍入的方法通常被稱為向下舍入或向負無窮舍入。當向下舍入到最近的整數時，它就能與floot()函數對應起來，儘管它也可能捨入到其他小數位。

![](images/3.5.3_1.png)

​   同樣，也可以使用類似的方法使舍入後數值變得更大(這種稱為向上舍入或向正無窮舍入與ceil()函數相對應),向絕對值較小的方向舍入(稱為向零舍入與trunc()函數相對應),或向絕對值更大的值舍入(稱為遠離零舍入或向無窮舍入和round()函數相對應)。然而，這些操作中沒有一個總可以最小化舍入誤差。一種更好的方法叫做向最接近偶數舍入、收斂舍入或四捨六入五成雙，它在lrint()函數中實現。正如你所期望的，這種舍入方式總是選擇最近可表示數字。另外，如果有兩個誤差相等的數，則取偶數。如果最後一個數值是零，那麼任意精度數是一個偶數。這種方法是處理IEEE浮點數舍入的默認方法，因為它不僅可以最小化舍入誤差，而且還可以確保計算隨機數舍入誤差之和趨於零。
![](images/3.5.3_2.png)
### 3.5.4 二進制運算

​   二進制加法與十進制加法相似，可以簡單地對齊每位二進制數並進行加法運算，注意正確處理從一列到下一列的進位操作。注意，兩個N位數值加或減的結果通常需要N+1位的數值來正確表示才不能溢出。對於小數，總是在符號位進行增加位寬

|      | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ | unsigned |
| ---- | ----- | ----- | ----- | ----- | -------- |
|      |       | 0     | 1     | 1     | =3       |
| +    |       | 0     | 1     | 1     | =3       |
| =    | 0     | 1     | 1     | 0     | =6       |

|      | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ | $$2^{-1}$$ | unsigned |
| ---- | ----- | ----- | ----- | ----- | -------- | -------- |
|      |       | 1     | 1     | 1     | 1        | =7.5     |
| +    |       | 1     | 1     | 1     | 1        | =7.5     |
| =    | 1     | 1     | 1     | 1     | 0        | =15      |

​   注意由於減法結果可能是負數，那個“額外的位數”就成了有符號二進制補碼數據的符號位。

|      | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ | unsigned |
| ---- | ----- | ----- | ----- | ----- | -------- |
|      | 0     | 0     | 1     | 1     | =3       |
| -    | 0     | 0     | 1     | 1     | =3       |
| =    | 0     | 0     | 0     | 0     | =0       |

|      | $$2^{-4}$$ | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ | unsigned               |
| ---- | -------- | ----- | ----- | ----- | ----- | ---------------------- |
|      |          | 0     | 0     | 1     | 1     | =3                     |
| +    |          | 1     | 1     | 1     | 1     | =15                    |
| =    | 1        | 1     | 1     | 1     | 0     | =-12(two's complement) |

​   二進制數乘法與十進制數乘法相似。通常説，兩個N位數據做乘法，最後結果位寬是2*N

|      | $$2^6$$ | $$2^5$$ | $$2^4$$ | $$2^3$$ | $$2^2$$ | $$2^1$$ | $$2^0$$ | two's complement       |
| ---- | -----| -----| ----- | ----- | ----- | ----- | ----- | ---------------------- |
|      |       |       |       | 1     | 0     | 0     | 1     | =9                     |
| *    |       |       |       | 1     | 0     | 0     | 1     | =9                     |
|      |       |       |       | 1     | 0     | 0     | 1     | =9                     |
|      |       |       | 0     | 0     | 0     | 0     |       | =0                     |
|      |       | 0     | 0     | 0     | 0     |       |       | =0                     |
| +    | 1     | 0     | 0     | 1     |       |       |       | =72                    |
|      | 1     | 0     | 1     | 0     | 0     | 0     | 1     | =81                    |

​   由於對符號位要進行單獨處理，所以有符號數的操作更加複雜。然而，對於結果數據位寬的計算方法仍然適用：兩個N位數值進行加減法，結果位寬為N+1位，兩個N位有符號數據做乘法，結果將有2*N位。

{% hint style='info' %}

​   關於除法怎麼分析呢？這個數值位寬是否可以精確的表示兩個N位數值的除法呢？

{% endhint %}

### 3.5.5 表示C/C++中任意精度整數

​   根據C99語言標準，已經定義了許多標準數據類型精度，例如**int**和**long**。雖然有些程序可以改變這些數據類型的精度來構建代碼，但大多數程序是不能這樣用的。在C99標準inttypes.h頭文件中有一個小的改進，這個頭文件中定義了固定位寬的有符號數據類型int8_t、int16_t、int32_t和int64_t，以及相應的無符號類型uint8_t、uint16_t、uint32_t和uint64_t。儘管這些數據類型有明確的位寬定義，但是它們使用起來仍然有些不方便。例如，即便像下面這樣簡單的代碼也會有意外的行為發生。

```c++
#include "inttypes.h"
uint16_t a = 0x4000;
uint16_t b = 0x4000;
//Danger! p depends on sizeof(int)
uint32_t p = a * b;
```

儘管a和b的值可以用16位二進制數表示，而且他們的積(0x10000000)可以精確的用32位二進制數表示，但是依據C99的轉換協議在計算開始時會把a和b的值強制轉換為**int**類型，然後計算出一個整型的結果，之後再將處理結果拓展到32位。儘管不常見，對於C99編譯器來説整數的精度只有16位。更進一步，C99標準對於整數只定義了4位寬度，然而FPGA系統經常應用自定義的位寬來進行算法運算。同時，用printf()函數不支持這類類型的數據打印，要求應用額外的宏定義來編寫代碼。如果你考慮用定點進行運算，情況會變得更糟。以下代碼中，我們考慮a和b為定點數，在相同的結構下運算產生正確結果。

```c++
#include "inttypes.h"
//4.0 represented with 12 fractional bits
uint16_t a = 0x4000;
//4.0 represented with 12 fractional bits
uint16_t b = 0x4000;
//Danger! p depends on sizeof(int)
uint32_t p = (a*b) >> 12;
```

​   在以下兩種情況，正確的代碼都要求在輸入變量相乘之前將變量位寬轉換為與結果位寬一致。

```c++
#include "inttypes.h"
uint16_t a = 0x4000;
uint16_t b = 0x4000;
//p is assigned to 0x10000000
uint32_t p = (uint32_t) a*(uint32_t) b;
```

 ```c++
#include "inttypes.h"
//4.0 represented with 12 fractional bits
uint16_t a = 0x4000;
//4.0 represented with 12 fractional bits
uint16_t b = 0x4000;
//Danger! p depends on sizeof(int)
uint32_t p = ((uint32_t) a*(uint32_t) b) >> 12;
 ```

{% hint style='tip' %}

​   當用整數代表定點數值時，定點數的格式是非常重要的，只有這樣在做乘法後的歸一化操作才能正確。通常定點數用“Q”的形式來給出小數位數。例如“Q15”格式表示有15位小數，而且它經常用來表示16位有符號變量。這樣的變量數值區間為[-1,1)。相似的，“Q31”表示有31位小數。

{% endhint %}

​   由於這些原因，最好使用c++和Vivado HLS模板類ap_int<>, ap_uint<>, ap_ fixed<>, ap_ufixed<>來表示任意精度數據。ap_int<>和ap_uint<>模板類需要整數參數來定義他們的位寬。計算函數通常產生結果的位寬足夠寬，可以表示正確結果，參照3.5.4節中的規則。只有當結果分配給較小的位寬時，才會發生溢出或下溢。

```C++
#include "ap_int.h"
ap_uint<15> a = 0x4000;
ap_uint<15> b = 0x4000;
//p is assigned to 0x10000000
ap_uint<30> p = a*b;
```

​   ap_fixed<>和ap_ufixed<>模板類相似，它們都需要兩個整數參數來定義位寬（數據所有位數）和數據整數的位寬。

```C++
#include "ap_fixed.h"
//4.0 represented with 12 fractional bits
ap_ufixed<15,12> a = 4.0;
//4.0 represented with 12 fractional bits
ap_ufixed<15,12> b = 4.0;
//p is assigned to 16.0 represented with 12 fractional bits
ap_ufixed<18,12> p = a*b;
```

{% hint style='info' %}

​   注意ap_fixed<>和ap_ufixed<>模板類位寬數據要為正數，但是數值可以是任意的。特殊情況下，整數的位寬可能是零（暗示這個數是純小數）或者這個數和數值位寬總數相同（暗示這個數沒有小數）。然而，整數的位寬可以是負數或者比總位寬大的數！這些數據格式描述的數值是什麼樣子的？ap_fixed<8,-3>能表示的最大數和最小數是什麼？ap_fixed<8,12>呢？

{% endhint %}

### 3.5.6 浮點

​   Vivado HLS還可以綜合浮點運算。浮點數據提供了很高精度，但這是有代價的；它需要大量的計算資源，這意味着很大的硬件資源開銷和多個時鐘週期延遲。因此，應該避免應用浮點數，除非應用場景根據精度要求必須要用浮點數。事實上，本章的首要目標是讓讀者瞭解在工程中如何有效地從浮點數過渡到定點數。不幸的是，這通常是一項非常重要的任務，並且沒有完美的標準方法可以自動執行轉換。這個原因一部分是由於轉換到定點將降低處理運算精度，所以浮點轉換定點的性能資源折中最好留給設計人員決定。

​   用高級語言綜合開發應用程序，初始數據類型都是採用浮點類型。這使設計人員專注於一個功能的正確實現。一旦實現了這一點，她就可以優化數據類型，來減少資源使用和/或提高性能。

{% hint style='info' %}

​   將CORDIC中所有變量從float更改為int，這對資源使用有什麼影響?它如何改變延遲?吞吐量如何變化?精度會有變化嗎?

{% endhint %}

## 3.6 進一步優化

​   在本節中，我們將對優化CORDIC函數的方法提出一些簡要的想法和建議。在權衡吞吐量、精度和資源的同時，我們關注不同優化方式如何對處理結果精度產生影響。

在實現CORDIC功能時，選擇合適的數據類型來表示角度和結果十分重要。儘管源代碼在浮點數和定點數下都能運行，CORDIC通常都會使用定點數數據類型使得乘法器數量減少。而當高效的乘法實現可行時，其它計算三角函數的方法就會被採用。回看圖3.3中的源代碼，包含了幾個跟sigma和factor變量有關的乘法器。通過限制代碼只工作在定點數下，我們可以用移位和加法操作來替代。代碼如圖3.6所示。
    
```C++
// The ﬁle cordic.h holds deﬁnitions for the data types and constant values 
#include ”cordic.h”

// The cordic phase array holds the angle for the current rotation 
// cordic_phase[0] =˜ 0.785 
// cordic_phase[1] =˜ 0.463

void cordic(THETA_TYPE theta, COS_SIN_TYPE &s, COS_SIN_TYPE &c) 
{ 
    // Set the initial vector that we will rotate 
    // current cos = I; current sin = Q 
    COS_SIN_TYPE current_cos = 0.60735; 
    COS_SIN_TYPE current_sin = 0.0;
    
    // This loop iteratively rotates the initial vector to ﬁnd the 
    // sine and cosine values corresponding to the input theta angle 
    for (int j = 0; j < NUM_ITERATIONS; j++) { 
        // Multiply previous iteration by 2ˆ(−j). This is equivalent to 
        // a right shift by j on a ﬁxed−point number. 
        COS_SIN_TYPE cos_shift = current_cos >> j; 
        COS_SIN_TYPE sin_shift = current_sin >> j;
        
        // Determine if we are rotating by a positive or negative angle 
        if(theta >= 0) { 
            // Perform the rotation 
            current_cos = current_cos − sin_shift; 
            current_sin = current_sin + cos_shift;
            
            // Determine the new theta theta = theta − cordic_phase[j]; 
        } else { 
            // Perform the rotation 
            current_cos = current_cos + sin_shift; 
            current_sin = current_sin − cos_shift;
            
            // Determine the new theta 
            theta = theta + cordic_phase[j];
        }
    }    
    // Set the ﬁnal sine and cosine values 
    s = current_sin;
    c = current_cos;
}
```
Figure 3.6 定點數CORDIC代碼實現給定角度sin和cos值

​   最後，CORDIC運算得到一個近似值。隨着迭代次數的增加，近似值的誤差通常會減小。這對應於我們在cordic函數中執行**for**循環的次數，該循環次數由NUM_ITERATION進行設置。即使我們執行了大量迭代，我們仍然可能得到一個近似值。這樣做的一個原因是我們可以接近，但從來沒有得到完全匹配的目標角度。然而，我們可以通過選擇執行更大或更小的迭代角度來調整精度。上述算法中需要更改的地方都可以通過修改NUM_ITERATIONS的值來實現。NUM_ITERATIONS數值依賴於使用這個CORDIC算法應用程序所需精度。

{% hint style='info' %}

​   隨着數據類型的變化，資源、吞吐量、和正餘弦結果精度會發生怎樣的變化?

{% endhint %}

{% hint style='info' %}

​   常量NUM_ITERATIONS如何影響資源、吞吐量和精度?它如何影響current_cos和current_sin的初始值?需要修改cordic_phase矩陣嗎?可以根據NUM_ITERATIONS的數值優化數據類型嗎?

{% endhint %}

{% hint style='info' %}

​   for循環中的計算佔用了大部分時間。如何最好地進行代碼轉換和/或使用編譯指令來優化它?

{% endhint %}

{% hint style='info' %}

​   在硬件中兩輸入複用器可以高效實現*sigma*變量。你可以調整代碼以便高級語言綜合（HLS）工具以這種方式實現它嗎?

{% endhint %}

{% hint style='info' %}

​   當前代碼假設給定的角是在正負90度之間。你能添加代碼使其可以處理任何±180◦之間的角度嗎?

{% endhint %}

## 3.7 結論

​   在本章中，我們研究了基於矢量旋轉計算三角函數和雙曲函數的座標旋轉數字算法(CORDIC)。我們從一個由CORDIC方法實現的計算背景開始。我們特別關注瞭如何使用CORDIC方法計算給定角度的正弦和餘弦值。此外，我們還討論瞭如何使用相同的CORDIC方法來計算給定複數的振幅和相位。

​   在此之後，我們將重點放在可以對CORDIC算法進行的優化上。由於它是一種迭代算法，所以在執行迭代次數上和計算結果的精度及準確性之間存在着基本的權衡。我們討論瞭如何降低精度/準確性，來節省FPGA資源和提高處理性能。

​   在CORDIC函數中，我們引入了自定義數據類型的概念。這就提供了一種減小中間和最終結果精度來減少延遲、增加吞吐量和減少資源使用的思路。同時，Vivado HLS提供了一種專門生成大值數據類型的方法。我們提供了數值表示的背景，並介紹了這些自定義數據類型。

​   通常，精度、資源利用率和性能之間存在複雜的關係。我們討論了一些權衡方法，並提供了關於如何更好地優化cordic函數的一些建議。我們把多種優化方式和權衡分析留給讀者作為練習。
