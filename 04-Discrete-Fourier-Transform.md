
# 第四章 離散傅里葉變換

本章介紹了DFT，並將重點放在了介紹了DFT在FPGA實現中的算法優化。DFT運算的核心是以一組固定係數執行矩陣向量乘法。在4.6章節中，我們首先將DFT將其簡化為矩陣 - 向量乘法，隨後介紹了使用Vivado HLS代碼的完整實現DFT方式。 另外，我們也描述瞭如何最佳地優化DFT計算以增加吞吐量。第4.5章中，我們將的優化工作集中在陣列分區優化上。

 本章的前兩小節有大量的數據計算和推導，這可能看起來有些多餘，但是它對於我們充分理解代碼重構優化以下一章快速傅里葉變換的對稱性計算有着很大作用。但是如果你對HLS 優化內容更感興趣，可以直接跳至第4.6章開始閲讀。

## 4.1 傅里葉級數

 為了解釋離散傅里葉變換，我們首先要了解傅里葉級數。傅立葉級數提供了另一種可選方法來觀察信號從-π到π的一個週期內的連續實值週期信號。Jean Baptiste Joseph Fourier的開創性成果表明，在2π週期內任何連續的週期性信號都可以用週期為2π的餘弦和正弦和表示。最終，傅里葉級數的表現形式如下：

$$
\begin{aligned}
f(t)&\sim\frac{a_{0}}{2}+a_{1}cos(t)+a_{2}cos(2t)+a_{3}cos(3t)+\cdots \\  
&b_{1}sin(t)+b_{2}sin(2t)+b_{3}sin(3t)+\cdots \\
&\sim\frac{a_{0}}{2}+{\sum_{n=1}^{\infty}}(a_{n}cos(nt)+b_{n}sin(nt))
\end{aligned}
\quad(4.1)
$$

其中參數$$a_{0},a_{1},\cdots$$和$$b_{0},b_{1},\cdots$$的計算公式如下：

$$
\begin{aligned}
a_{0}&=\frac{1}{\pi}\int_{-\pi}^{\pi}f(t)dt \\
a_{n}&=\frac{1}{\pi}\int_{-\pi}^{\pi}f(t)cos(nt)dt \\
b_{n}&=\frac{1}{\pi}\int_{-\pi}^{\pi}f(t)sin(nt)dt
\end{aligned}
\quad(4.2)
$$

有幾個需要注意的點是：首先式4.2中的參數$$a_{0},a_{1},\cdots$$,$$b_{0},b_{1},\cdots$$被稱作傅里葉參數。其中參數 $$a_{0}$$ 被稱作直流分量（來自於對早期電流分析的參考），其中n=1頻率分量稱為基波，而其他頻率（n≥2）分量統稱為高次諧波。基波和高次諧波的概念來自聲學和音樂。其次，函數f以及cos()和sin()函數都有2π個週期; 我們很快就會展現如何將這個週期改變為其他值。
直流分量$$a_{0}$$等同於cos(0·t)=1時的係數，因此使用符號a。因為sin(0·t)=0，所以不需要 $$b_{0}$$ 的值。最後，在某些情況下，函數f和它的傅里葉級數之間是近似相等的關係，這種不連續的現象我們稱之為吉布斯現象。而這是隻是一個僅與傅里葉級數有關的小問題，與其他傅立葉變換無關。 因此，今後我們將忽略式[4.1]中的“近似”（〜），直接視為“相等”（=）。

表示函數不以π為週期時需要對自變量進行簡單的更改。 假設一個函數的週期範圍在[-L,L]而不是[-π,π],則設：

$$
t\equiv\frac{\pi t^\prime}{L} \quad(4.3)
$$

以及

$$
dt=\frac{\pi{d} t^\prime}{L}\quad(4.4)
$$

這是一個簡單地將週期區間從[-π,π]變換到期望的[-L,L]的一個線性方程，將$$t^\prime=\frac{Lt}{\pi}$$ 代入到式4.1得：

$$
f(t^\prime)=\frac{a_{0}}{2}+{\sum_{n=1}^{\infty}}(a_{n}cos(\frac{n\pi{t^\prime}}{L})+b_{n}sin(\frac{n\pi{t^\prime}}{L}))\quad(4.5)
$$

用同樣的方法解得a和b的各項參數可解得：

$$
a_{0}=\frac{1}{L}\int_{-L}^{L}f(t^\prime)dt^\prime \quad
$$

$$
a_{n}=\frac{1}{L}\int_{-L}^{L}f(t^\prime)cos(\frac{n\pi{t^\prime}}{L})dt^\prime \quad(4.6)
$$

$$
b_{n}=\frac{1}{L}\int_{-L}^{L}f(t^\prime)sin(\frac{n\pi{t^\prime}}{L})dt^\prime \quad\quad
$$

我們也可以利用歐拉公式 $$e^{jnt}=cos(nt)+jsin(nt)$$ 來得出一個更簡潔的公式。

$$
f(t)=\sum_{n={-\infty}}^{\infty}c_{n}e^{jnt}\quad(4.7)
$$

其中，傅里葉參數$$c_{n}$$ 是一個較為複雜的指數表達式：

$$
c_{n}=\frac{1}{2\pi}\int^{\pi}_{-\pi}f\left(t\right)e^{-jnt}dt\quad(4.8)
$$

假設f(t)是一個具有2π個週期的周期函數，將這個公式與式4.1等效，傅里葉參數$$a_{n},b_{n}, and\,c_{n}$$ 之間的數值關係為:

$$
a_{n}=c_{n}+c_{-n}\text{ for }n=0,1,2,\cdots\quad\quad
$$

$$
b_{n}=j(c_{n}-c_{-n})\text{ for }n=0,1,2,\cdots\quad\quad
$$

$$
C_{n}=\begin{cases}
1/2\left( a_{n}-jb_{n}\right) n >0\\
1/2a_{0}                      n =0\\
1/2\left( a_{-n}+jb_{-n}\right) n <0
\end{cases}
\quad(4.9)
$$

我們需要注意的是參數$$a_{n},b_{n},c_{n}$$ 的公式中引入了“負”頻率的概念。雖然從物理的角度上看它沒有實際意義，但在數學上我們可以將其視為複平面上的“負”旋轉。正頻率表示複數在複平面上以逆時針方向旋轉，負頻率表示我們在複平面上以順時針方向旋轉。

餘弦，正弦和復指數之間的關係更加證明了上面這個理論，餘弦既可以看作復指數的實數部分，也可以推導為一個正頻率和一個負頻率兩個復指數的和，如式4.10所示。

$$
cos(x)=Re\left(e^{jx}\right) =\dfrac{e^{ix}+e^{-jx}}{2}\quad(4.10)
$$

正弦和復指數之間的關係如式4.11所示，與餘弦的不同點在於這裏我們減去負頻率併除以2j。

$$
sin(x)=Im\left(e^{jx}\right) =\dfrac{e^{ix}-e^{-jx}}{2j}\quad(4.11)
$$

這兩種正餘弦和復指數之間的關係都可以用複平面矢量圖的形式來理解，如下圖4.1所示。圖4.1中a)部分顯示了餘弦的推導過程，這裏我們添加兩個複平面向量$$e^{jx}$$ 和 $$e^{-jx}$$，圖中可以看出這兩個向量和是一個在實軸上的向量，大小為2cos(x)。所以，當我們將這兩個向量的和除以2就到了式4.10中的cos(x)的值。圖4.1中b)部分顯示了類似的正弦的推導過程，這裏我們添加兩個複平面向量$$e^{jx}$$ 和 $$e^{-jx}$$，圖中可以看出這兩個向量差是一個在虛軸上的向量，大小為2sin(x)。所以，當我們將這兩個向量的差除以2j就到了式4.11中的sin(x)的值。

![圖4.1：餘弦，正弦和復指數之間的關係。a）部分顯示了兩個復矢量 $$e^{jx}$$ 與 $$e^{-jx}$$ 的和。 這個求和的結果恰好落在實值軸上，其值為2cos(x)。b）部分顯示了一個類似的總和，只是這次對矢量$$e^{jx}$$ 與 $$-e^{-jx}$$ 求和。 這個總和落在虛軸上，其值為2sin(x).](images/sin_cos_exp.jpg)

## 4.2 DFT背景介紹

上一節我們探究了傅里葉級數的分析數學基礎，證明了它對於週期連續性信號的作用，而離散傅里葉變換是針對於離散的週期信號的。DFT可以將有限數量的等間隔樣本轉換為有限數量的複數正弦曲線。換句話説，它將一個採樣函數從一個域（通常是時域）轉換到頻域。複數正弦曲線的頻率取為與輸入函數的採樣週期相關的頻率的基頻的整數倍。離散信號和週期信號最重要的關聯在於它可以用一組有限的數字表示。因此，可以使用數字系統來實現DFT。

DFT適用於同時包含實數和複數的輸入函數。直觀上，為了輕鬆入門，我們暫時忽略複數部分，從實數信號開始瞭解實際DFT的工作原理。

{% hint style='tip' %}
關於術語的簡要説明：我們使用小寫函數變量來表示時域中的信號，大寫函數變量來表示頻域中的信號。我們使用()表示連續函數，用[]表示離散函數。例如，f()是連續的時域函數，F()是其連續的頻域表示。類似地，g[]是時域中的離散函數，G[]是將該函數轉換到頻域。
{% endhint %}

讓我們從圖4.2開始分析，左圖是一個具有N個樣本或從0到N-1運行的點的實值時域信號g[]。當我們用DFT分析時域信號時，會得出對應於各個頻率的餘弦和正弦幅度的頻域信號。這些可以看作是餘弦幅值對應複數的實數值，而正弦幅值對應複數的虛數值，其中包含有有N/2+1個餘弦（實數）和N/2+1個正弦（虛數）值。我們稱之為複頻域函數G []。注意，頻域中樣本的數量為（N/2+1）是由於我們正在分析一個只包含實數的時域信號，複數時域信號經過DFT後將變為具有N個樣本的頻域信號。

![圖4.2：一個有N個樣本點的離散實值時域函數g可以用一個具有N/2+1個樣本點的頻域函數表示。每個頻域採樣都有一個餘弦值和一個正弦幅值。這兩個幅度值可以共同表示為一個複數，餘弦幅度表示實部，正弦幅度表示虛部。](images/basic-DFT.jpg)

一個具有N個樣本點的DFT可以通過一個N×N矩陣乘以一個大小為N的矢量來確定。G = S·g其中
$$
\begin{bmatrix}
    1 &       1        & 1        &\ldots    &1\\
    1 &       s        &s^{2}     &\ldots    &s^{N-1}\\
    1 &       s^{2}    &s^{4}     &\ldots    &s^{2(N-1)}\\
    1 &       s^{3}    &s^{6}     &\ldots    &s^{3(N-1)}\\
    \vdots&   \vdots   &\vdots    &\ddots    &\vdots\\
    1 &       s^{N-1}  &s^{2(N-1)}  &\ldots    &s^{(N-1)(N-1)}
\end{bmatrix}\quad(4.12)
$$

其中$$s=e^{\frac{-i2\pi}{N}}$$。 因此，頻域中的樣本被推導為
$$
G[t]=\sum_{n={0}}^{N-1}g[n]s^{kn}\quad for \; k=0,\ldots,N-1\quad(4.13)
$$

圖4.3提供了8個樣本點的DFT操作的係數的可視化分析圖。八點頻域採樣是通過將8個時域採樣與S矩陣的對應行相乘而得到的。S矩陣的行0對應於與時域採樣的平均值成比例的DC分量。將S矩陣的第1行與g相乘，得出圍繞單位圓圈旋轉一圈時的餘弦和正弦振幅值。由於這是一個8點DFT，這意味着每個相位偏移45°。執行8個45°旋轉將圍繞單位圓完整旋轉一圈。第2行是相似的，唯一不同點是圍繞單位圓執行兩次旋轉，即每次旋轉90°。這是一個更高的頻率。第3排做三次旋轉; 第4排四輪旋轉等等。每一個這樣的行時間列乘法中都給出了適當的頻域樣本。

我們可以注意到S矩陣是對角對稱矩陣，即$$S[i][j]=S[j][i]$$。另外，$$S[i][j]=s^{i}s^{j}=s^{i+j}$$。在第四行周圍也會出現有趣的對稱性現象。行3和行5中的相量是彼此的共軛複數，即$$S[3][j]=S[5][j]^{\ast}$$。 類似地，行2和6 $$(S[2][j]=S[6][j]^{\ast})$$ 以及行1和7 $$(S[1][j]=S[7][j]^{\ast})$$ 都是彼此的共軛複數。 正是由於這個原因，具有N個採樣點的實值輸入信號的DFT在頻域中僅具有N/2+1個餘弦和正弦值。剩餘的N/2個頻域值提供了宂餘信息，因此不需要它們。然而，當輸入信號為負數時，情況並非如此。在這種情況下，頻域將有N+1個餘弦和正弦值。

![圖4.3 矩陣S中元素的複數向量圖.](images/dft-visualization.jpg)

```c
#define SIZE 8
typedef int BaseType;

void matrix_vector(BaseType M[SIZE][SIZE], BaseType V_In[SIZE], BaseType V_Out[SIZE]) {
	BaseType i, j;
data_loop:
	for (i = 0; i < SIZE; i++) {
		BaseType sum = 0;
	dot_product_loop:
		for (j = 0; j < SIZE; j++) {
			sum += V_In[j] * M[i][j];
		}
		V_Out[i] = sum;
	}
}
```
圖4.4 實現矩陣向量乘法的簡單代碼

## 4.3 矩陣向量乘法的優化

矩陣向量乘法是DFT計算的核心，輸入的時域向量將乘以一個固定特殊值的矩陣，輸出的結果是與輸入時域信號表示相對應的頻域矢量。
在本節中，我們討論如何在硬件中實現矩陣向量乘法。我們把這個問題分解成最基本的形式（見圖4.4）。這讓我們能夠更好地將討論集中在算法優化上，而不是集中在使用功能正確的DFT代碼的所有難點上。在下一節中我們將構建一個DFT內核。

圖4.4中的代碼提供了將該算法實現到硬件中的原始形式，代碼中使用當前被映射為**浮點型**的**BaseType**的自定義數據類型。雖然這在剛開始看起來可能是多餘的，但是可以方便我們在將來輕鬆地將變量（例如，具有不同精度的有符號或無符號的定點）進行不同的數字表示。 **matrix_vector** 功能共有三個參數，我們對前兩個參數進行乘法計算，輸入矩陣和向量分別是 **BaseType** **M[SIZE][SIZE]** 和 **BaseType V In[SIZE]**。第三個參數 **BaseType V_Out[SIZE]** 是結果向量。我們將M=S和V_in設為採樣的時域信號，則Vout將包含DFT。SIZE是決定輸入信號中樣本數量的常數，相應地也決定了DFT的大小。

![](images/matrix_vector_sequential.jpg)

![圖4.5 一種圖4.4矩陣向量乘法代碼可能的實現方式。](images/dft_behavior_loop_sequential.jpg)

這個算法本身只是一個嵌套的for循環。內部循環（ **dot_product_loop**）從0至SIZE-1計算DFT的係數。但是，這個相對簡單的代碼在映射到硬件執行時，就有許多種設計方案可選擇。

無論何時執行HLS，你都應該考慮希望綜合成怎樣的結構體系。內存結構在這個過程中顯得尤為重要。這個問題可以歸結為你將代碼中的數據存儲到哪裏？因為將變量映射到硬件時有許多選項。該變量可能只是一組電線（如果它的值永遠不需要在一個週期內保存）、寄存器、RAM或FIFO。但所有這些選項都需要你在速度和麪積之間作出折中的選擇。

另一個我們需要考慮的重要因素是代碼並行度的可用性。純粹的順序代碼到硬件上實現相當困難。換句話説，一個具有足夠並行可行性的代碼，可以從純粹順序執行到完全並行執行。這樣的選擇顯然會帶來不同的面積和速度。我們將研究內存配置和並行性會如何影響DFT矩陣向量的硬件實現。

圖4.5顯示了包含一個乘法和一個加法運算符的矩陣向量乘法的順序結構。我們創建邏輯以訪問存儲在BRAM中的V_In和矩陣M。計算V_Out的每個元素並存儲到BRAM中。這種體系結構本質上是將圖4.4中的代碼合成為無指令的結果。它不佔用大量面積，但任務延遲和任務間隔相對較大。

## 4.4 流水線和並行運行

在矩陣乘法的例子中，我們可以很大程度地利用並行思想來解決問題。首先關注每次迭代循環執行的內部循環表達式 $$sum+= V_in [j] * M [i] [j]$$。乘法運行時，計數變量SUM在每次迭代中都被重複利用並賦予新的值。如圖4.6所示，這個內部循環可以重新表述，此時變量 **SUM** 已被完全消除，並在較大表達式中替換為多箇中間值。

```c
#define SIZE 8
typedef int BaseType;

void matrix_vector(BaseType M[SIZE][SIZE], BaseType V_In[SIZE], BaseType V_Out[SIZE]) {
	BaseType i, j;
data_loop:
	for (i = 0; i < SIZE; i++) {
		BaseType sum = 0;
		V_Out[i] = V_In[0] * M[i][0] + V_In[1] * M[i][1] + V_In[2] * M[i][2] +
							 V_In[3] * M[i][3] + V_In[4] * M[i][4] + V_In[5] * M[i][5] +
							 V_In[6] * M[i][6] + V_In[7] * M[i][7];
	}
}
```
圖4.6: 手動展開矩陣向量乘法內部循環實例

{% hint style='tip' %}
循環的展開可以由Vivado HLS在流水線中自動執行,也可以通過使用#pragma HLS unroll或者流水線外的等價指令來實現。
{% endhint %}

我們應該已經發現替換內部循環的新表達式應具有大量的並行性。如此而來每個乘法可以同時執行，並且可以使用加法器樹來執行求和。這個計算的數據流圖如圖4.7所示。

如果我們希望展開內循環的表達式的任務延遲最小，那麼所有的八個乘法運算都應該並行執行。假設乘法有3個週期的延遲且加法有1個週期的延遲，則所有$$V\_In[j] * M [i][j]$$ 操作在第三週期結束時完成。使用加法器樹對這八個中間結果進行求和需要$$log8 = 3$$個週期。因此，對於每次迭代，數據循環主題將共有6個週期的延遲，並且需要8個乘法器和7個加法器，如圖4.8左側所示。需要注意的是，如果在循環4-6中重複使用加法器，這會將加法器的數量減少到4個。但是，在FPGA上加法器通常是無法共享的，因為加法器和多路複用器需要相同數量的FPGA資源（對於2輸入運算，大約1個LUT每比特）。

如果我們不願意使用8個乘法器，則可以增加執行該功能的週期數量來減少資源使用量。例如，使用4個乘法器會使得8個$$V\_In [j] * M [i] [j]$$ 乘法操作帶來6個週期的延遲，那麼完成整個數據循環體將會有9個週期的總延遲，如圖4.8的右側所示。為了使用更少的乘法器，我們需要犧牲更多的時間週期來完成內部循環。

![圖4.7：圖4.6的內循環展開代碼對應的數據流圖。](images/matrix_vector_unroll_inner.jpg)

![圖4.8：由圖4.6的內部循環展開代碼實現的兩種不同的順序模式操作圖。](images/dft_behavior1.jpg)

![圖4.9：由圖4.6的內部循環展開代碼實現的兩種不同的流水線模式操作圖。](images/dft_behavior2.jpg)

從圖4.8中我們可以明顯看出有很多重要的時間段並沒有執行有效的工作，因而降低了設計的總體效率。我們應該儘量縮短這些時間來提高效率。在這種情況下，可以發現data_loop的每次迭代實際上是完全獨立的，這意味着它們可以同時執行。正如我們展開dot_product_loop一樣，也可以展開數據循環並同時執行所有的乘法運算。但是，這需要大量的FPGA資源。我們還有更好的選擇是儘快地啟動循環的每次迭代，意味着前一次循環仍在執行。這個過程被稱為循環流水線化，我們通過#pragma HLS pipeline在Vivado HLS中實現。 在大多數情況下，循環流水線會減少循環的間隔時間，但不會影響延遲時間。循環流水線的實現如圖4.9所示。

截至目前，我們的關注點集中在操作運行的延遲上。功能單元通常也是流水線式的，Vivado HLS中的大多數功能單元都是間隔為1的流水線式的。儘管單次乘法操作可能需要3個週期才能完成，但流水線乘法器的乘法操作可以在每個時鐘週期開始。通過這種方式，單個功能單元可以同時執行多個乘法操作。例如，有3個週期延遲且間隔為1的乘數可以同時執行三次乘法運算。

充分利用流水線乘法器的優勢就在於我們就可以在不添加額外運算符的前提下減少內部循環的延遲。圖4.10中左邊展示了使用三個流水線乘法器一種可能的實現方式。在這種情況下，乘法操作可以併發執行（因為它們沒有數據依賴性），而加法操作只有在第一次乘法完成之後才能開始。在右圖中，顯示了該設計間隔為3的流水線版本，如果將#pragma HLS pipeline II=3應用於data_loop，則與Vivado HLS的結果類似。這樣不僅個別操作在同一個操作符上併發執行，而且這些操作可能來自於不同data_loop的迭代。

![圖4.10：由圖4.6的內部循環展開代碼實現的兩種不同的流水線乘法器操作。](images/dft_behavior3.jpg)

現在你可能已經觀察到，我們可以在不同的層次級別上進行流水線操作，包括算法級別，循環級別和功能級別。此外，不同級別的流水線在很大程度上也是獨立的！我們可以在順序循環中使用流水線操作符，或者我們可以使用順序操作符來構建流水線循環，也可以構建大型功能的流水線實現。這些功能可以像原始運算單元一樣在Vivado HLS 中共享。我們實例化了多少運算單元，它們的個體成本以及使用頻率如何才是最重要的。

## 4.5 存儲權衡和數據分區

到了本小節，我們已經假定數組中的數據 V_In[],M[][]和V_Out[]可以隨時訪問，但是實際上，數據的放置的位置對整個處理器的性能和資源使用情況有重要影響。在大多數處理器系統中，內存架構是固定的，我們只能調整程序以嘗試最大程度地利用可用的內存層次結構，例如注意儘可能減少寄存器溢出和緩存丟失。在HLS設計中，我們還可以利用不同的存儲器結構，並嘗試找到最適合特定算法的存儲器結構。通常，大量數據存儲在片外存儲器如DRAM、閃存或網絡連接的存儲器中，但是數據訪問時間通常很長，大約為幾十到幾百（或更多）個週期。由於大量的電流必須流過長電線已訪問片外存儲器，所以使用片外存儲消耗的能量也比較大。相反，片上存儲器可以快速訪問並且功耗要低得多，只是它可以存儲的數據量有限。有一種常見的操作模式類似於通用CPU的內存層次結構中的緩存效果，它是將數據重複地加載到塊中的片上存儲器上。

當我們選擇片上存儲器的時候，需要在嵌入式存儲器（例如Block RAM）或觸發器（FF）之間權衡。基於觸發器的存儲器允許在一個時鐘內對不同地址的數據進行多次讀取，也可以在一個時鐘週期內讀取、修改和寫入基於觸發器的存儲器。然而，即使在資源配置最好的設備中，FF的數量通常也限制在大約10萬字節左右。實際上，以便有效地使用其他FPGA資源，大多數基於FF的存儲器應該小得多。Block RAM（BRAM）提供更高的容量，擁有Mbytes的存儲量，其代價是有限的可訪問性。例如，單個BRAM可以存儲大於1到4千字節的數據，但是在每個時鐘週期只可以對該數據的兩個不同的地址進行訪問。此外，BRAM需要儘可能減少流水線操作（比如，讀操作必須具有至少一個週期的延遲）。因此，我們的基本的權衡點在於工程所需的帶寬與容量。

如果説數據的吞吐量我們需要考慮的頭號問題，則所有數據都將存儲在FF中。這將允許任何元素在每個時鐘週期內被訪問儘可能多的次數。但是，隨着矩陣陣列變大，這種方案也將變得不可行。在矩陣向量乘法的情況下，存儲1024位乘以1024位矩陣的32位整數將需要大約4兆字節的存儲器。即使使用BRAM來存儲，由於每個BRAM存儲大約4KBytes，也需要大約1024個BRAM塊。另一方面，使用單個大型基於BRAM的內存意味着我們一次只能訪問兩個元素。這明顯降低了性能，如圖4.7所示，它需要在每個時鐘週期訪問多個數組元素（V_In[]的所有8個元素以及M[][]的8個元素）。在實際工程中，大多數設計需要更大的陣列分佈存放在更小的BRAM存儲器中，這種方法稱為陣列分區。較小的數組（通常用於索引較大的數組）可以完全劃分為單獨的標準變量並映射到FF。匹配流水線選擇和數組分區以最大限度地提高運算符使用率和內存使用率是HLS設計探索的一個重要方面。

{% hint style='tip' %}
Vivado HLS 將自動執行一些陣列分區，但由於陣列分區傾向於某些特定設計，因此通常需要我們利用好工具以獲得最佳結果。陣列分區的全局配置可在config_array_partiton選項中找到。單個數組可以使用array_patition指令來顯示分區，並將指令數組分區完成將數組的每個元素分解到它自己的寄存器中，最終形成基於FF內存。與許多其他基於指令的優化一樣，通過手動重寫代碼也可以實現相同的效果。一般情況下，最好使用工具指令，因為它避免了引入錯誤並易於代碼維護。
{% endhint %}

回到圖4.4中的矩陣向量乘法代碼，我們可以通過添加幾個指令來實現高度並行，如圖4.11所示，最終的體系結構如圖4.12所示。請注意，內部j循環由Vivado HLS 自動展開，因此j在每次使用的時候都被替換為常量。此設計演示了陣列分區的最常見用法，其中分區的數組維度（在本例中為V_In[]和第二維的M[][]）都被索引為常量（在本例中為循環索引j來展開循環）。這使得多路複用器可以無需訪問分區陣列架構。

我們還可以用更少的乘法器降低性能以實現其他設計。例如，在圖4.10中，這些設計只使用三個乘法器，因此我們只需要在每個時鐘週期讀取三個矩陣M[][]和矢量V_in[]的元素。完全分割這些數組會導致額外的多路複用，如圖4.13所示。實際上，陣列只需要分成三個物理存儲器。同樣，這種分區可以通過重寫代碼手動實現，也可以使用array_patition循環指令在Vivado HLS中實現。

{% hint style='tip' %}
讓我們從包含數據的矩陣X來分析：
$$
\begin{bmatrix}
    1   &2   &3   &4   &5   &6   &7   &8   &9
\end{bmatrix}
$$
數組中指令　array_patition　variable=x factor=2 cycle  將矩陣分為如下兩個
$$
\begin{bmatrix}
    1   &3   &5   &7   &9
\end{bmatrix}and \begin{bmatrix}
    2   &4   &6   &8
\end{bmatrix}
$$
{% endhint %}

```c
#define SIZE 8
typedef int BaseType;

void matrix_vector(BaseType M[SIZE][SIZE], BaseType V_In[SIZE], BaseType V_Out[SIZE]) {
#pragma HLS array_partition variable=M dim=2 complete
#pragma HLS array_partition variable=V_In complete
	BaseType i, j;
data_loop:
	for (i = 0; i < SIZE; i++) {
#pragma HLS pipeline II=1
		BaseType sum = 0;
	dot_product_loop:
		for (j = 0; j < SIZE; j++) {
			sum += V_In[j] * M[i][j];
		}
		V_Out[i] = sum;
	}
}

```
圖4.11 選用陣列分割和流水線操作的矩陣向量乘法

![圖4.12 具有特定的陣列分區和流水線選擇的矩陣-矢量乘法體系結構。右圖的流水線寄存器已經被刪除.](images/matrix_vector_optimized.jpg)

![圖4.13 II = 3時具有特定的陣列分區選擇的矩陣向量乘法體系結構。如左圖所示，陣列已被分割得超過需要以至於使用了多路複用器。如右圖所示，數組用factor=3分區，這樣減少了多路複用器的使用，但j循環索引成為地址計算的一部分。](images/matrix_vector_poor_scaling.jpg)

{% hint style='tip' %}
相似地，如果我們使用 **array_patition** variable=x factor=2 block 指令可以將它分為兩個矩陣向量：
    [1   2   3   4   5] and[ 6   7   8   9]
{% endhint %}


{% hint style=‘info’ %}
讓我們來研究一下變化的流水線II和陣列分區對性能和麪積的影響，比較根據每秒的矩陣向量乘法運算（吞吐量）和根據展開陣列分區因子的數量的性能高低，並繪製相同的區域趨勢圖（如顯示LUT，FF，DSP模塊，BRAM）。再思考這兩種情況的總趨勢是什麼？你會選擇哪種設計？為什麼？
{% endhint %}

通過流水線操作並將部分循環展開應用於 **dot_product_loop**，我們也可以得到類似的結果。圖4.14顯示了將矩陣向量乘法代碼的內部循環展開2倍的結果。你可以發現，循環的邊界現在增加到2；每個循環迭代需要2個矩陣M[][]和向量Vin[]每次迭代並執行兩次乘法而不是一次。使用這種方式循環展開後，對應於原始循環的兩次迭代，Vivado HLS可以並行地在兩個表達式中實現這些操作。請注意，如果沒有適當的數組分區，展開內部循環可能不會提高性能，因為併發讀取操作的數量受到內存端口數量的限制。在這種情況下，我們可以將來自偶數列的數據存儲在一個BRAM中，將來自奇數列的數據存儲在另一個BRAM中。這是因為展開的循環總是執行一次偶數迭代和一次奇數迭代。

```c
#define SIZE 8
typedef int BaseType;

void matrix_vector(BaseType M[SIZE][SIZE], BaseType V_In[SIZE], BaseType V_Out[SIZE]) {
#pragma HLS array_partition variable=M dim=2 cyclic factor=2
#pragma HLS array_partition variable=V_In cyclic factor=2
	BaseType i, j;
data_loop:
	for (i = 0; i < SIZE; i++) {
		BaseType sum = 0;
	dot_product_loop:
		for (j = 0; j < SIZE; j+=2) {
#pragma HLS pipeline II=1
			sum += V_In[j] * M[i][j];
			sum += V_In[j+1] * M[i][j+1];
		}
		V_Out[i] = sum;
	}
}
```
圖4.14 內部循環展開2倍的矩陣向量乘法代碼。

{% hint style=‘tip’ %}
HLS工具可以使用 unroll 指令自動展開循環。該指令採用一個因子作為參數，它是一個正整數，表示循環體應該展開的次數。
{% endhint %}

{% hint style=‘info’ %}
使用 **array_partition** cyclic factor = 2 指令和將 M[][]和向量 V_in[]手動劃分為單獨的數組有着相同的效果。考慮一下應該如何修改代碼才能更改訪問模式呢？ 現在我們手動將循環展開為兩倍。原始代碼（沒有數組分區和不展開），只執行數組分區的代碼，同時執行數組分區和循環展開代碼之間的性能結果有哪些不同呢？ 最後，使用指令執行數組分割和循環展開的結果與手動執行的結果相比有哪些不同呢？
{% endhint %}

在這段代碼中，我們看到數組分區通常與流水線操作並行執行。通過2倍的數組分割可以使性能提高2倍，我們可以用將內環部分展開2倍或將外環的II減少2倍來實現。提升性能需要相應數量的陣列分區。在矩陣向量乘法中，這種關係相對簡單，因為對內部循環中的每個變量只有一次訪問權限。在其他代碼中，關係可能更復雜。無論如何，設計者的目標應該是確保例化的FPGA資源得到有效利用。一般情況下，將性能提高2倍將使用大約兩倍的資源，相反將性能降低2倍可以節約一半的資源。

{% hint style=‘info’ %}
讓我們來研究一下循環展開和陣列分區對性能和麪積的影響，比較根據每秒的矩陣向量乘法運算（吞吐量）和根據展開陣列分區因子的數量的性能高低，並繪製相同的區域趨勢圖（如顯示LUT，FF，DSP模塊，BRAM）。再思考這兩種情況的總趨勢是什麼？你會選擇哪種設計？為什麼？
{% endhint %}

## 4.6 Baseline實現

上一節中我們討論了執行DFT的核心計算——矩陣向量乘法的一些優化方法。然而將矩陣向量乘法轉移到功能完備的DFT進行硬件實現，還會出現其他問題。在本節中，我們將重點轉移到DFT，並討論如何優化以使其執行起來最有效。

處理大量複雜數字的能力是這一節我們需要着重考慮的點之一。如4.2節所述，因為S矩陣的元素是複數，所以實值信號的DFT幾乎總是一個複數值信號。執行復數值信號的DFT以產生複數值結果也很常見。此外，我們需要處理分數或可能的浮點數據，而不是整數。這會增加實現的成本，尤其是需要執行浮點操作的時候。另外，浮點運算符（特別是加法運算符）比整數加法具有更大的延遲。這可以使得II = 1的循環更難以實現。第二個變化是我們希望能夠將我們的設計容量擴展到一個大輸入矢量的大小，比如N = 1024個輸入樣本。然而如果我們直接使用矩陣向量乘法，那麼我們必須存儲整個S矩陣。由於這個矩陣是輸入大小的平方，因此這麼大的一個輸入矢量的存儲實現起來比較困難。本章我們將討論解決這兩個複雜問題的技巧。

正如使用HLS創建硬件實現時的典型實例一樣，讓我們從簡單代碼的實現開始。這裏我們有一個可以保證它具有正確的功能baseline代碼。通常，這些代碼都以非常連續化的方式運行;它沒有高度優化，因此可能無法達到所需的性能指標。但是，這是確保設計人員理解算法功能的必要步驟，並且可以作為未來優化的起點。圖4.15顯示了DFT的baseline實現。這使用雙重嵌套for循環。內部循環將S矩陣的一行與輸入信號相乘。該代碼不是將S矩陣作為輸入讀取，而是基於當前循環索引，在內部循環的每次迭代中計算S中的元素。我們使用cos()和sin()函數將該相量轉換為具有實部和虛部的笛卡爾座標。該代碼可將相量與適當採樣的輸入信號相乘並累加結果。經過該內環的N次迭代之後，每個S矩陣的列元素都被計算得出一個頻域樣本。外循環也迭代了N次，S矩陣的每一行都被迭代一次。最終，代碼計算了N次矩陣W的表達式，但是cos()和sin()函數以及複數乘加計算進行了 $$n^{2}$$ 次。

此代碼使用函數調用來計算cos()和sin()值。Vivado HLS能夠使用其內置的數學庫來實現這樣的數學計算。第3章介紹了用於實現三角函數（包括CORDIC）的幾種可能的算法[22]。但是，要使這些函數生成精確的結果可能代價比較高。因為輸入量不是任意的，取消這些函數調用也有幾種方法。我們將在稍後更詳細地討論這些權衡方法。這個代碼的順序執行代碼如圖4.16所示。

```c
#include <math.h>					//Required for cos and sin functions
typedef double IN_TYPE;		// Data type for the input signal
typedef double TEMP_TYPE; // Data type for the temporary variables
#define N 256							// DFT Size

void dft(IN_TYPE sample_real[N], IN_TYPE sample_imag[N]) {
	int i, j;
	TEMP_TYPE w;
	TEMP_TYPE c, s;

	// Temporary arrays to hold the intermediate frequency domain results
	TEMP_TYPE temp_real[N];
	TEMP_TYPE temp_imag[N];

	// Calculate each frequency domain sample iteratively
	for (i = 0; i < N; i += 1) {
		temp_real[i] = 0;
		temp_imag[i] = 0;

		// (2 * pi * i)/N
		w = (2.0 * 3.141592653589  / N) * (TEMP_TYPE)i;

		// Calculate the jth frequency sample sequentially
		for (j = 0; j < N; j += 1) {
			// Utilize HLS tool to calculate sine and cosine values
			c = cos(j * w);
			s = sin(j * w);

			// Multiply the current phasor with the appropriate input sample and keep
			// running sum
			temp_real[i] += (sample_real[j] * c - sample_imag[j] * s);
			temp_imag[i] += (sample_real[j] * s + sample_imag[j] * c);
		}
	}

	// Perform an inplace DFT, i.e., copy result into the input arrays
	for (i = 0; i < N; i += 1) {
		sample_real[i] = temp_real[i];
		sample_imag[i] = temp_imag[i];
	}
}

```
圖4.15：DFT的baseline code

{% hint style=‘info’ %}
如果你要使用你設計的CORDIC（如從第3章開始），那麼此代碼需要做什麼修改？ 改變CORDIC核心的準確性會使DFT硬件資源使用情況發生變化嗎？ 它會如何影響性能？
{% endhint %}

{% hint style=‘info’ %}
請使用HLS實現DFT的基線代碼，實現後查看報告，與乘法和加法相比，實現三角函數的相對成本是多少？ 對哪些操作嘗試優化更有意義？通過流水線操作內循環可以實現什麼性能？
{% endhint %}

## 4.7 DFT優化

上一節的基線的DFT實現使用了相對較高的 **double** 數據類型。實現浮點運算尤其是雙精度浮點運算通常代價很高並且需要很多流水線操作。我們可以從圖4.16中看到這顯着影響了循環的性能。通過流水線操作，這些高延遲操作的影響不那麼重要，因為可以同時執行多個循環執行。此代碼中的例外是用於累加結果的變量temp real []和temp imag []。這個累加是一種循環，並在流水線化內循環時限制了可實現的II。該運算符的依賴性如圖4.17所示。

一種可能的解決方案是降低計算的精度。這種方法在實際應用時是有價值的，因為它減少了每個操作所需的資源，減少了存儲值所需的內存，並且通常也減少了操作的延遲。例如，我們可以使用32位浮點型或16位半型來替代雙精度型。許多信號處理系統完全避免了浮點數據類型，並使用定點數據類型3.5。對於常用的整數和定點精度，每個加法可以在一個循環中完成，從而使循環在II = 1處流水線化。

{% hint style='info' %}
如果將所有數據類型從雙精度型更改為浮點型，那麼圖4.15中的代碼綜合結果會發生什麼變化？還是從一倍到一半？或到一個固定的點值？這是如何改變性能（間隔和延遲）和資源使用情況的？它是否會更改輸出頻率域採樣值？
{% endhint %}

用浮點累加實現II = 1的普適解決方案是用不同的順序處理數據。看圖4.17，我們看到由於j循環是內部循環，所以重複是存在的（用箭頭表示）。如果內循環是i循環，那麼在下一次迭代開始之前我們就不需要累加的結果。我們可以通過交換兩個循環的順序來實現這一點。這種優化方式通常被稱為循環交換或流水線交織處理[40]。由於外循環i內部的額外代碼，我們可能不是很容易地發現可以重新排列循環。由於S矩陣是對角對稱的，因此i和j可以在w的計算中交換。

結果是我們現在可以在內部循環中實現1的II。但是我們需要為臨時實值和臨時圖像數組設置額外的存儲器，存儲計算的中間值一直到再次需要這些數據。

![](images/dft_behavior_baseline.jpg)

![圖4.16：DFT的高層體系結構圖，如圖4.15所示。 這不是該體系結構的綜合視圖，例如，它缺少與更新循環計數器i和j的相關內容。該圖想向讀者提供關於如何合成這種體系結構的近似概念。這裏我們假定浮點運算符需要4個時鐘週期。.](images/dft_sequential_arch.jpg)

![圖4.17：圖4.16中的行為的流水線版本。在這個設計案例下，由於每個浮點的添加需要4個時鐘週期才能完成，並且在下一個循環開始之前需要上一個循環的結果加入計算（以紅色顯示相關性），所以設置循環的啟動間隔為4個間隔。所有迭代的依賴關係彙總在右圖中。.](images/dft_pipelined_behavior.jpg)

{% hint style=‘info’ %}
重新排列圖4.15中代碼的循環，並顯示您可以使用1的II來管理內部循環。
{% endhint %}

根據DFT中S矩陣的結構，我們可以應用其他優化方式來完全消除三角運算。回想一下，S矩陣的每個元素的復矢量是通過單位圓的固定旋轉角度來計算的。S矩陣的行S[0][]對應於單位圓周的零旋轉，行S[1][]對應於單次旋轉，並且隨後的行對應於單位圓周更大角度的旋轉。我們可以發現，第二行S[1][]相對應的向量覆蓋了來自其他行的所有向量，因為8個列向量每個繞單位圓旋轉45°，一共則圍繞單位圓旋轉了一圈。我們可以通過研究圖9.11來直觀地確認這個現象。這樣我們可以只存儲第二行這一次旋轉中的正弦和餘弦值，然後索引到這個存儲器中的值以計算相應行的必要值。這隻需要2×N=O（N）個存儲單元可以有效減少存儲器的O（N）的大小。對於1024個點的DFT，存儲器的存儲需求將減少到1024×2個條目。假設有一個32位的固定值或浮點值，則只需要8KB大小的片上存儲器。與明確存儲整個S矩陣相比，明顯減少了存儲容量。我們將矩陣S的這個一維存儲表示為$$s^\prime$$

$$
S^\prime=S[1][.]=\begin{bmatrix}
    1 &       s        &s^{2}        &\ldots    &s^{n-1}\\
\end{bmatrix}
$$

{% hint style=‘info’ %}
導出一維數組$$s^\prime$$對應於數組S的行號i和列元素j的輸入的訪問模式的公式。也就是説，我們如何才能索引到一維S數組以訪問元素S（i; j）呢？
{% endhint %}

為了進一步提高性能，我們可以應用一種與矩陣向量乘法非常相似的技術。之前我們發現了提高矩陣向量乘法的性能需要對M[][]數組進行分區。但是如果用$$s^\prime$$ 表示S矩陣則意味着不再有一種有效的方法來劃分$$s^\prime$$ 以增加我們在每個時鐘上讀取的數據量。S的每一個奇數行和列都包括$$s^\prime$$ 的每個元素。因此，我們無法像對S一樣對$$s^\prime$$ 的值進行分區。這樣增加我們從存儲$$s^\prime$$ 的內存中讀取數據端口的數量的唯一方法是複製存儲。幸運的是，不像與必須讀取和寫入的內存，複製只讀的數組的存儲是相對容易的。事實上，Vivado HLS將只對在初始化且從未例化的只讀存儲器（ROM）自動執行此優化。這種功能的一個優點是我們可以簡單地將sin（）和cos（）調用移動到數組初始化中。在大多數情況下，如果此代碼位於函數的開頭並僅初始化陣列，則Vivado HLS能夠完全優化三角函數計算並自動計算ROM的內容。

{% hint style=‘info’ %}
設計一個利用$$s^\prime$$——S矩陣的一維版本的體系結構。這種體系結構是如何影響到所需的存儲空間的？與使用二維的S矩陣的實現相比，這會改變邏輯利用率嗎？
{% endhint %}

為了有效地優化設計，我們必須考慮代碼的每個部分。往往是最薄弱的環節決定了設計的整體性能，這意味着，如果設計有一個瓶頸，將顯著影響設計的性能。當前版本的DFT可以對輸入和輸出數據進行就地操作，即它存儲結果相同的數組作為輸入數據，輸入數組 sample_real 和 sample_imag 都是有效的存儲器端口，也就是説，你可以把這些參數的數組存儲在相同的存儲位置。這樣，在任意給定的週期，我們只能獲取其中一個陣列的一個數據，這可能會在函數中並行的乘法和加法運算方面產生瓶頸。這就是我們為什麼必須將所有的輸出結果存儲在一個臨時數組的原因，然後將所有這些結果複製到函數結尾處的“sample”數組中。如果我們沒有執行就地操作，則不需要這樣做。

{% hint style=‘info’ %}
修改DFT函數接口，使輸入和輸出存儲在單獨的數組中。這會如何影響你的可以執行優化？它如何改變性能？ 區域結果如何？
{% endhint %}

## 4.8 結語

在本章中，我們探究了離散傅里葉變換（DFT）的硬件實現和優化方法。DFT是數字信號處理的基本操作，需要採樣時域的信號並將其轉換到頻域。在本章的開頭，我們描述了DFT的數學背景。這對於理解下一章（FFT）中所做的優化很重要。本章的其餘部分集中介紹了指定和優化DFT以在FPGA上進行高效的實現。

由於DFT的核心是執行矩陣向量乘法，所以我們最初花費了一些時間來描述在執行矩陣向量乘法的簡化代碼上的指令級優化。這些指令級優化由HLS工具完成。我們用這個機會來闡明HLS工具執行指令優化的過程，希望如上的優化過程能讓你直觀地瞭解到工具優化的結果。

本章後節，我們為DFT提供了正確的功能實現方案，討論了一些可以改善性能的優化，具體來説就是將係數陣列劃分為不同存儲器以提高吞吐量。陣列的分區優化通常是構建最高性能體系結構的關鍵方法。
