# 第五章 快速傅里葉變換

當取樣樣本數量為N時，直接使用矩陣向量乘法來執行離散傅里葉變換需要$$\mathcal{O}(n^2)$$次乘法和加法操作。我們可以通過利用矩陣中的常數係數的結構來降低運算的複雜度。在這裏S矩陣負責對DFT的係數進行編碼碼。矩陣的每一行對應於繞複數單位圓周旋轉的固定圈數（詳情請參閲第4.2章）。這些運算值有大量的宂餘，可以利用這些值來降低算法的複雜性。

{% hint style='tip' %}
這裏使用的'Big O'符號描述了基於輸入數據大小的算法複雜度的一般順序。有關'Big O'符號及其在分析算法中的使用的完整描述，請參見[17](./BIBLIOGRAPHY.md#45)
{% endhint %}

快速傅立葉變換（FFT）使用基於S矩陣對稱性的分塊處理方法。FFT因Cooley-Tukey算法[16]而廣為流行，它需要$$\mathcal{O}(n \log n)$$次操作來計算與DFT相同的函數。這可以在大規模信號執行傅立葉變換時提供顯着的加速。

計算DFT的分塊處理的方法最初由Friedrich Gauss在19世紀初提出。然而，由於高斯的這部分研究並沒有在他生前出版，而是出現在他去世後的一些收藏的文獻中，所以這件作品一點都不含糊。海德曼等人[32]為FFT的研究史提供了一個很好的背景。

本章的重點是讓讀者更好地理解FFT算法，因為這是硬件設計優化的重要部分。首先，我們從數學的角度理解一下FFT；其次將討論的重點放在如何縮小FFT的大小；最後，討論一些不同的硬件實施方法。

## 5.1 背景

FFT算法利用DFT計算中的對稱性來降低算法的複雜度。為了更好地理解這個問題，讓我們首先關注一下DFT算法中的研究點，以2點DFT為例。DFT背景介紹執行一個矩陣向量乘法計算$$G[] = S[][] \cdot g[]$$,其中$$g[]$$是輸入向量，$$G[]$$是頻域的輸出數據，$$S[][]$$DFT參數。我們遵循第4.2章中所述相同的係數矩陣記法以及的輸入和輸出向量。

對於一個兩個樣本點的DFT，矩陣S的值為：

$$
S =
 \begin{bmatrix}
  W^{0 0}_2 & W^{0 1}_2  \\
  W^{1 0}_2 & W^{1 1}_2
 \end{bmatrix}\quad(5.1)
$$

這裏我們使用$$W = e^{-j 2 \pi}$$的概念，其中W的上標表示添加到分子中的值，W的下標表示在復指數的分母值。舉個例子，$$W^{2 3}_4 = e^{\frac{-j 2 \pi \cdot 2 \cdot 3}{4}}$$。這和4.2節中討論的DFT中s的值一樣，其中$$s = e^{\frac{-j 2 \pi}{N}}$$,s和W之間的關係為$$s = W_N$$。


 $$e^{-j 2 \pi}$$ 或者 $$W $$經常被稱作*旋轉因子*，這個術語起源於1966年Gentleman和Sande的論文[27]。


$$
\begin{bmatrix}
G[0] \\
G[1]
\end{bmatrix} =
 \begin{bmatrix}
  W^{0 0}_2 & W^{0 1}_2  \\
  W^{1 0}_2 & W^{1 1}_2
 \end{bmatrix}
 \cdot
  \begin{bmatrix}
  g[0] \\
  g[1]
\end{bmatrix}\quad(5.2)
$$

把這兩個等式拓展到2點DFT則有：

$$
\begin{array} {lll}
G[0] & = & g[0] \cdot e^{\frac{-j 2 \pi \cdot 0 \cdot 0}{2}} + g[1] \cdot e^{\frac{-j 2 \pi \cdot 0 \cdot 1}{2}} \\
 & = & g[0] + g[1]
\end{array}\quad(5.3)
$$

由於$$e^{0} = 1$$，所以其中的第二個頻率項為:

$$
\begin{array} {lll}
G[1] & = & g[0] \cdot e^{\frac{-j 2 \pi \cdot 1 \cdot 0}{2}} + g[1] \cdot e^{\frac{-j 2 \pi \cdot 1 \cdot 1}{2}} \\
 & = & g[0] - g[1] \\
\end{array}\quad(5.4)
$$

其中$$e^{\frac{-j 2 \pi \cdot 1 \cdot 1}{2}}  = e^{-j \pi } = -1$$。

圖5.1為這個計算提供了兩種不同的表示方法。a）部分是2點DFT的數據流圖。這是我們熟悉的本書的一種習慣的表達方法。b）部分展示了用於相同計算的蝶形結構。這是數字信號處理中使用的典型結構，特別是用於表示FFT中的計算。

蝴蝶結構是一種更緊湊的表示形式，可用於表示大型數據流圖。當兩條線合在一起時，這表示一個加法操作。箭頭線上的任何標籤都表示該標籤乘以該線上的值。該圖中有兩個標籤:底部水平線上的'-'標誌表示該值應該被否定。此後加上由相交的兩條線表示的加法與減法相同。第二個標籤是 $$W^0_2$$。雖然這個乘法是不必要的（因為 $$W^0_2$$ = 1，這意味着它乘以值'1'），但是把它表示出來是因為它在多樣本點的FFT計算中很常見。

現在讓我們考慮一個稍微大一點的DFT——4點DFT，有4個輸入、4個輸出以及一$$4 * 4$$的S矩陣如式5.5所示：

$$
S=
\begin{bmatrix}
 W^{0 0}_4 & W^{0 1}_4 & W^{0 2}_4 & W^{0 3}_4 \\
 W^{1 0}_4 & W^{1 1}_4 & W^{1 2}_4 & W^{1 3}_4 \\
 W^{2 0}_4 & W^{2 1}_4 & W^{2 2}_4 & W^{2 3}_4 \\
 W^{3 0}_4 & W^{3 1}_4 & W^{3 2}_4 & W^{3 3}_4
\end{bmatrix}\quad(5.5)
$$

![圖5.1 a）部分是2點DFT/FFT的數據流圖。 b）部分顯示了該運算的蝴蝶結構。它是數字信號處理領域中計算FFT的常見表示方法。](images/2pointFFT.jpg)

用於計算頻率輸出項的DFT方程為：

$$
\begin{bmatrix}
G[0] \\
G[1] \\
G[2] \\
G[3]
\end{bmatrix} =
 \begin{bmatrix}
  W^{0 0}_4 & W^{0 1}_4 & W^{0 2}_4 & W^{0 3}_4 \\
  W^{1 0}_4 & W^{1 1}_4 & W^{1 2}_4 & W^{1 3}_4 \\
  W^{2 0}_4 & W^{2 1}_4 & W^{2 2}_4 & W^{2 3}_4 \\
  W^{3 0}_4 & W^{3 1}_4 & W^{3 2}_4 & W^{3 3}_4
 \end{bmatrix}
 \cdot
  \begin{bmatrix}
  g[0] \\
  g[1]\\
  g[2]\\
  g[3]
\end{bmatrix}\quad(5.6)
$$

現在我們逐個寫出G[]中每個頻域值的方程。G[0]的方程為:

$$
\begin{array} {lll}
G[0] & = & g[0] \cdot e^{\frac{-j 2 \pi \cdot 0 \cdot 0}{4}} + g[1] \cdot e^{\frac{-j 2 \pi \cdot 0 \cdot 1}{4}} + g[2] \cdot e^{\frac{-j 2 \pi \cdot 0 \cdot 2}{4}} + g[3] \cdot e^{\frac{-j 2 \pi \cdot 0 \cdot 3}{4}}\\
 & = & g[0] + g[1] + g[2] + g[3] \\
\end{array}\quad(5.7)
$$

G[1]的方程為:

$$
\begin{array} {lll}
G[1] & = & g[0] \cdot e^{\frac{-j 2 \pi \cdot 1 \cdot 0}{4}} + g[1] \cdot e^{\frac{-j 2 \pi \cdot 1 \cdot 1}{4}} + g[2] \cdot e^{\frac{-j 2 \pi \cdot 1 \cdot 2}{4}} + g[3] \cdot e^{\frac{-j 2 \pi \cdot 1 \cdot 3}{4}}\\
 & = & g[0] + g[1] \cdot e^{\frac{-j 2 \pi}{4}} + g[2] \cdot e^{\frac{-j 4 \pi}{4}} + g[3] \cdot e^{\frac{-j 6 \pi}{4}}\\
 & = & g[0] + g[1] \cdot e^{\frac{-j 2 \pi}{4}} + g[2] \cdot e^{-j \pi}   + g[3] \cdot e^{\frac{-j 2 \pi}{4}} e^{-j \pi} \\
 & = & g[0] + g[1] \cdot e^{\frac{-j 2 \pi}{4}} - g[2] - g[3] \cdot e^{\frac{-j 2 \pi}{4}}\\
\end{array}\quad(5.8)
$$

其中方程簡化的依據是$$e^{-j \pi} = -1$$.

G[2]的方程為:

$$
\begin{array} {lll}
G[2] & = & g[0] \cdot e^{\frac{-j 2 \pi \cdot 2 \cdot 0}{4}} + g[1] \cdot e^{\frac{-j 2 \pi \cdot 2 \cdot 1}{4}} + g[2] \cdot e^{\frac{-j 2 \pi \cdot 2 \cdot 2}{4}} + g[3] \cdot e^{\frac{-j 2 \pi \cdot 2 \cdot 3}{4}}\\
 & = & g[0] + g[1] \cdot e^{\frac{-j 4 \pi}{4}} + g[2] \cdot e^{\frac{-j 8 \pi}{4}} + g[3] \cdot e^{\frac{-j 12 \pi}{4}}\\
 & = & g[0] - g[1]  + g[2] -  g[3]
\end{array}\quad(5.9)
$$

其中方程的運算是通過基於旋轉的簡化來完成的，例如，$$e^{\frac{-j 8 \pi}{4}} = 1$$ 以及$$e^{\frac{-12 j \pi}{4}} = -1$$ 。這兩個例子都運用到了$$e^{-j 2\pi}$$等於1。換句話説，任何具有2π旋轉的復指數都是相等的。

最終G[3]的方程為:

$$
\begin{array} {lll}
G[3] & = & g[0] \cdot e^{\frac{-j 2 \pi \cdot 3 \cdot 0}{4}} + g[1] \cdot e^{\frac{-j 2 \pi \cdot 3 \cdot 1}{4}} + g[2] \cdot e^{\frac{-j 2 \pi \cdot 3 \cdot 2}{4}} + g[3] \cdot e^{\frac{-j 2 \pi \cdot 3 \cdot 3}{4}}\\
 & = & g[0] + g[1] \cdot e^{\frac{-j  6 \pi}{4}} + g[2] \cdot e^{\frac{-j  12 \pi}{4}} + g[3] \cdot e^{\frac{-j 18 \pi}{4}}\\
 & = & g[0] + g[1] \cdot e^{\frac{-j 6  \pi }{4}}  - g[2] +  g[3] \cdot e^{\frac{-j 10  \pi}{4}}\\
  & = & g[0] + g[1] \cdot e^{\frac{-j 6  \pi }{4}}  - g[2] -  g[3] \cdot e^{\frac{-j 6  \pi}{4}}
\end{array}\quad(5.10)
$$

我們尚未發現我們的簡化和上一個週期有何聯繫，它由 $$e^{\frac{-j 18 \pi}{4}}$$開始，因為他們相差了$$2\pi$$個旋轉週期所以可以簡化或者説是等價於$$e^{\frac{-j 10 \pi}{4}} \cdot e^{\frac{-j 8 \pi}{4}}$$,第二項等於1即$$e^{\frac{-j 8 \pi}{4}}=1$$。最後，再旋轉$$\pi$$ 個角度就相當於-1，就變成了$$e^{\frac{-j 6 \pi}{4}}$$。從另一個角度來看這個$$e^{\frac{-j 6 \pi}{4}}.e^{\frac{-j 18 \pi}{4}}$$，其中 $$e^{\frac{-j 4 \pi}{4}}=1$$。我們沒有將式5.10徹底簡化是為了在以下等式中證明對稱性。通過重新排序，我們可以將這四個方程視為：

$$
\begin{array} {lll}
G[0] & = & (g[0] + g[2]) + e^{\frac{-j 2 \pi 0}{4}} (g[1] + g[3])\\
G[1] & = & (g[0] - g[2]) + e^{\frac{-j 2 \pi 1}{4}} (g[1] - g[3])\\
G[2] & = & (g[0] + g[2]) + e^{\frac{-j 2 \pi 2}{4}} (g[1] + g[3])\\
G[3] & = & (g[0] - g[2]) + e^{\frac{-j 2 \pi 3}{4}} (g[1] - g[3])
\end{array}\quad(5.11)
$$

從式5.11可以看出，幾種不同的對稱性開始出現。首先，我們可以將輸入數據劃分為偶數和奇數元素，即，對元素g[0]和g[2]進行類似的操作，對於奇數元素g[1]和g[3]也是如此。此外，我們可以看到在這些偶數和奇數元素上存在加法和減法對稱性。在計算輸出頻率G[0]和G[2]期間，將偶數和奇數元素相加在一起。在計算頻率G[1]和G[3]時，將偶數和奇數元素減。最後，每個頻率項中的奇數元素乘以常數復指數 $$W^i_4$$，其中i表示頻率輸出，即G[i]。

我們來看一下括號裏面的項，可以發現有2點FFT。比如，我們先考慮一下括號裏面的偶數輸入項g[0]和g[2]。如果我們對這些偶數項用2點FFT展開，那麼低頻分量（直流分量）就是g[0]＋g[2]（參見式5.3），高頻分量計算結果為g[0]－g[2]（參見式5.4）。2點FFT同樣適用於奇數項輸入g[1]和g[3]。

我們在這些等式上做更多的變換。

$$
\begin{array} {lll}
G[0] & = & (g[0] + g[2]) + e^{\frac{-j 2 \pi 0}{4}} (g[1] + g[3])\\
G[1] & = & (g[0] - g[2]) + e^{\frac{-j 2 \pi 1}{4}} (g[1] - g[3])\\
G[2] & = & (g[0] + g[2]) - e^{\frac{-j 2 \pi 0}{4}} (g[1] + g[3])\\
G[3] & = & (g[0] - g[2]) - e^{\frac{-j 2 \pi 1}{4}} (g[1] - g[3])
\end{array}\quad(5.12)
$$

最後兩個等式裏的旋轉變化是由$$e^{\frac{-j 2 \pi 2}{4}} = -e^{\frac{-j 2 \pi 0}{4}}$$ 和 $$e^{\frac{-j 2 \pi 3}{4}} = -e^{\frac{-j 2 \pi 1}{4}}$$兩個等式得來的。我們可以跨兩個等式，共享乘法項係數，進一步降低了矩陣乘法的複雜度。

圖5.2顯示了四點FFT的蝶形圖。 我們可以看到第一階段是對偶數（頂部蝶形）和奇數（底部蝶形）輸入值執行的兩個2點FFT運算。通過使用公式5.12中所示的簡化方式，將奇數的2點FFT輸出乘以適當的旋轉因子，可以用於所有四個輸出項。

![四點FFT分為兩個階段。 階段1使用兩個2點FFT {一個2點FFT用於偶數輸入值，另一個2點FFT用於奇數輸入值。 階段2執行剩餘的操作以完成FFT計算，如公式5.12所述。](images/4ptFFT.jpg)

我們看到這樣的趨勢使得從DFT的$$\mathcal{O}(n^2)$$操作到FFT的$$\mathcal{O}(n \log n)$$ 操作的複雜性降低。關鍵的想法是通過遞歸來構建計算。4點FFT使用兩個2點FFT。擴展到更大的FFT尺寸就是8點FFT使用兩個4點FFT，每個FFT使用兩個2點FFT（總共四個2點FFT）。16點FFT使用兩個8點FFT，依此類推。

{% hint style='info' %}
在32點FFT中使用了多少個2點FFT？ 64點FFT有多少？ 64點FFT需要多少4點FFT？ 128點FFT怎麼樣？ 在N點FFT（其中N> 8）中，2點，4點和8點FFT的通用公式是什麼？
{% endhint %}

現在讓我們來正式推導出這種關係，它提供了一種描述FFT遞歸結構的通用方法。假設我們正在計算N點FFT。給定輸入值g[]的頻域值G[]的計算公式為：

$$
G[k] = \displaystyle\sum\limits_{n=0}^{N-1} g[n] \cdot e^{\frac{-j 2 \pi k n}{N}} \text{ for } k = 0, \ldots, N-1
\quad(5.13)
$$

我們可以把這個公式分為兩部分，一部分是偶數部分，一部分是奇數部分。

$$
G[k] =\displaystyle\sum\limits_{n=0}^{N/2-1} g[2n] \cdot e^{\frac{-j 2 \pi k (2n)}{N}} + \displaystyle\sum\limits_{n=0}^{N/2-1} g[2n+1] \cdot e^{\frac{-j 2 \pi k (2n+1)}{N}}
\quad(5.14)
$$

該等式的第一部分處理偶數輸入，是g[]和e的指數中的2n項。第二部分對應於兩個部分的2n+1的奇數輸入。還要注意的是在兩種情況下，由於我們將它分為兩個部分所以每個公式的求和總和現在變為N/2-1。

我們將公式5.14轉換為如下：

$$
G[k] = \displaystyle\sum\limits_{n=0}^{N/2-1} g[2n] \cdot e^{\frac{-j 2 \pi k n}{N/2}} + \displaystyle\sum\limits_{n=0}^{N/2-1} g[2n+1] \cdot e^{\frac{-j 2 \pi k (2n)}{N}} \cdot e^{\frac{-j 2 \pi k}{N}}
\quad(5.15)
$$

在第一個求和（偶數輸入）中，我們只需將2移動到分母中，使其現變為N/2。第二個求和（奇數輸入）使用冪規則來分離+1，留下兩個複數指數。我們可以進一步表達這個等式為：

$$
G[k] = \displaystyle\sum\limits_{n=0}^{N/2-1} g[2n] \cdot e^{\frac{-j 2 \pi k n}{N/2}} + e^{\frac{-j 2 \pi k}{N}} \cdot \displaystyle\sum\limits_{n=0}^{N/2-1} g[2n+1] \cdot e^{\frac{-j 2 \pi k n}{N/2}}
\quad(5.16)
$$

這裏我們只修改第二個求和。首先，我們在求和之外拉出一個不依賴於n的複數指數。我們也將第二個移動到分母中，就像我們在第一次求和中所做的那樣。請注意，這兩個求和現在具有相同的復指數$$e^{\frac{-j 2 \pi k n}{N/2}}$$。最後，我們將其簡化為

$$
G[k] = A_k + W_N^k B_k \quad(5.17)
$$

其中$$A_k$$和$$B_k$$分別是第一部分和第二部分的總和。我們回想一下$$W = e^{-j 2 \pi}$$。它正是通過將偶數和奇數項分成兩個求和項來完整地表述N點FFT。

讓我們假設只用公式5.17來計算前N/2項，即G[0]到G[N/2-1]，再使用另一個等式導出剩餘的N/2項，即從G[N/2]到G[N-1]的項。雖然這可能看起來很愚蠢（為什麼要做更多的數學計算而且是不必要的？），但你會發現這將使我們能夠利用更加對稱的方式，得到一種我們在4點FFT研究中看到的那種計算模式。

為了計算更高頻率G[N/2]到G[N-1]，讓我們推導出相同的方程，但這次使用k=N/2，N/2+1,...,N/2-1。因此，我們希望計算：

$$
G[k + N/2] = \displaystyle\sum\limits_{n=0}^{N-1} g[n] \cdot e^{\frac{-j 2 \pi (k + N/2) n}{N}} \text{ for } k = 0, \ldots, N/2 - 1\quad(5.18)
$$

這類似於公式5.13，只是下標不同。即我們用k+N/2替換公式5.13中的k。用我們之前完全相同的變換，我們可以將它直接類比到等式5.16，但用k+N/2替換k，可得：

$$
G[k + N/2] = \displaystyle\sum\limits_{n=0}^{N/2-1} g[2n] \cdot e^{\frac{-j 2 \pi (k + N/2) n}{N/2}} + e^{\frac{-j 2 \pi (k + N/2)}{N}} \cdot \displaystyle\sum\limits_{n=0}^{N/2-1} g[2n+1] \cdot e^{\frac{-j 2 \pi (k + N/2) n}{N/2}} \quad(5.19)
$$

我們可以減少求和中的復指數，如下所示：

$$
e^{\frac{-j 2 \pi (k + N/2) n}{N/2}} = e^{\frac{-j 2 \pi k n}{N/2}} \cdot e^{\frac{-j 2 \pi (N/2) n}{N/2}} = e^{\frac{-j 2 \pi k n}{N/2}} \cdot e^{-j 2 \pi n} = e^{\frac{-j 2 \pi k n}{N/2}} \cdot 1\quad(5.20)
$$

第一次簡化使用了冪運算規則來分割指數。第二次簡化取消了在第二指數中的N/2項。最後的簡化使用n是非負整數的事實，因此$$e^{-j2\pi n}$$將始終是2π的倍數的旋轉。這意味着該項始終等於1。

現在讓我們來處理第二個復指數：

$$
e^{\frac{-j 2 \pi (k + N/2)}{N}} = e^{\frac{-j 2 \pi k }{N}} \cdot e^{\frac{-j 2 \pi N/2 }{N}} = e^{\frac{-j 2 \pi k }{N}} \cdot e^{-j  \pi} = - e^{\frac{-j 2 \pi k }{N}}\quad(5.21)
$$

第一次簡化使用冪運算規則分割指數。第二次對第二個指數進行了一些簡化。我們通過等式$${e^{-j\pi n}=-1}$$得到了最終形式。

![圖5.3：從兩個N/2點FFT構建N點FFT。在偶數輸入上執行上N/2點FFT; 較低的N/2點FFT使用奇數輸入。](images/NptFFT.jpg)

通過將式5.20和式5.21代入式5.19.我們得到

$$
G[k + N/2] = \displaystyle\sum\limits_{n=0}^{N/2-1} g[2n] \cdot e^{\frac{-j 2 \pi k n}{N/2}} - e^{\frac{-j 2 \pi k}{N}} \cdot \displaystyle\sum\limits_{n=0}^{N/2-1} g[2n+1] \cdot e^{\frac{-j 2 \pi k n}{N/2}} \quad(5.22)
$$

注意到它和式5.16很相似，我們把它帶入式5.17可以得到：

$$
G[k + N/2] = A_k - W_N^k B_k\quad(5.23)
$$

我們可以使用公式5.17和5.23從兩個N/2點FFT來創建N點FFT。請記住，$$A_k$$對應於偶數輸入值函數，$$B_k$$對應奇數輸入值的函數。公式5.17涵蓋了前N/2項，公式5.23對應於較高的N/2頻率。

圖5.3顯示了從兩個N/2點FFT導出的N點FFT。$$A_k$$對應於頂部的N/2 FFT，$$B_k$$對應於底部的 N/2 FFT。輸出項G[0]到G[N/2-1]乘以$$W_N^0$$，而輸出項G [N / 2]到G [N - 1]乘以$$-W_N^0$$。注意，輸入g[]被分成偶數和奇數元素，分別饋入頂部和底部的n/2點FFT。

我們可以使用通用公式來創建剛剛導出的FFT，以遞歸創建N/2點FFT。也就是説，N/2個點FFT中的每一個可以使用兩個N/4點FFT來實現。並且每個N/4點FFT可以使用兩個N/8點FFT，依此類推，直到我們達到最基本的2點FFT。

圖5.4顯示了一個8點FFT並突出顯示了這種遞歸結構。帶有虛線的方框表示不同的FFT大小。 最外面的框表示8點FFT。這由兩個4點FFT組成。這4個點FFT中的每一個都具有兩個2點FFT，總共四個2點FFT。

![圖5.4：遞歸構建的8點FFT。有兩個4點FFT，每個FFT使用兩個2點FFT。 必須將輸入重新排序為偶數和奇數元素兩次。 這導致基於索引的比特反轉進行重新排序。](images/8ptFFT.jpg)

另外還要注意的是，輸入量必須在輸入8點FFT之前重新排序。這是因為不同的N/2點FFT採用偶數和奇數輸入。上面的四個輸入對應於偶數輸入，下面的四個輸入對應奇數輸入。但是，它們被重新排序了兩次。如果我們將偶數集分開，則將偶數和奇數輸入分開{g[0],g[2],g[4],g[6]}和奇數集{g[1],g[3],g[5],g[7]}。現在讓我們再次對偶數集重新排序。在偶數集g[0]和g [4]是偶數元素，g[2]和g[6]是奇數元素。因此重新排序它為{g[0],g[4],g[2],g[6]}。對於初始奇數集可以同樣產生重新排序的集合{g[1],g[5],g[3],g[7]}。

最終的重新排序是通過交換索引，將順序排列的值按位取反來完成的。表5.1顯示了索引及其三位二進制值。該表顯示了8點FFT的8個索引，以及第2列中每個索引的相應二進制值。第三列是第二列的位反轉二進制值。最後一列是對應反轉二進制數的十進制數值。

表5.1：索引，該索引的三位二進制值，位反轉二進制值，以及結果位反轉索引。

|   索引   | 二進制   | 位反轉二進制 | 位反轉索引   |
| -------- | -------- | ------ | ---------- |
| 0     | 000    | 000  | 0     |
| 1 | 001    | 100  | 4    |
| 2     | 010    |010   | 2     |
| 3     | 011    | 110  | 6         |
| 4   | 100  | 001 | 1 |
| 5     | 101     |101   | 5    |
| 6     | 110    | 011   | 3  |
| 7   | 111   | 111 | 7 |

查看第一行，初始索引0的二進制值為000，當反轉時保持為000.因此，不需要交換該索引。由圖5.4可知g[0]保留在同一位置。在第二行中，索引1具有二進制值001，反轉時是100或4。因此，最初在索引1處開始的數據，即g[1]應該在第四位置結束。並且查看索引4，我們看到位反轉值為1,因此交換g[1]和g[4]。

假設FFT是2的冪，則無論FFT的輸入大小如何，該位反轉過程都有效。FFT通常是2的冪,我們就可以遞歸地實現它們。
{% hint style='info' %}
對於一個32點FFT，索引1的值應該和哪個位置的值交換呢？索引2的值呢？
{% endhint %}

這樣我們就完成了對FFT的數學理論學習，還有很多有關如何優化FFT的細節。你可能認為我們花了太多時間討論FFT的精細的知識點，這是一本關於FPGA的並行編程的書而不是數字信號處理的書。但這突出了創建最佳硬件實現的重要部分，設計人員必須很好地理解正在開發的算法。因為沒有這個基礎很難創建一個好的硬件實現算法。下一節將介紹如何創建良好的FFT硬件實現方法。

## 5.2 Baseline 實現

在本章我們將討論使用Vivado HLS工具來實現 Cooley-Tukey FFT[16]算法的不同方法。這與我們在上一節中描述的算法相同。我們從代碼的通用版本開始，然後描述如何對其進行重組以實現更好的硬件設計。

當順序執行時，FFT中的$$\mathcal{O}(n \log n)$$ 運算需要$$\mathcal{O}(n \log n)$$個時間步長。通常，並行實現將並行執行FFT的某些部分。並行化FFT的一種常用方法是將計算組織為 log n 個階段，如圖5.8所示。每個階段的操作都取決於前一階段的操作，自然導致跨任務的流水線操作。這種架構允許以log n個FFT與由每個階段的體系結構確定的任務間隔，來進行同時計算。我們將使用第5.4節中的dataflow指令討論任務流水線。

FFT中的每個階段也包含顯著的並行性，因為每個蝶形計算獨立於同一階段中的其他蝶形計算。每個時鐘週期執行n/2蝶形計算，任務間隔為1，可以允許以1的任務間隔計算整個階段。當與數據流架構結合使用時，FFT算法中的所有並行性都可以被利用。儘管可以構造這樣的架構，但是除了非常小的信號之外幾乎從不使用它，因為必須在每個時鐘週期提供整個新的SIZE樣本塊以保持流水的充分利用。例如，以250 MHz運行的複雜32位浮點值的1024點FFT將需要1024點\*（8字節/點）\* 250 \* $${10^9}$$Hz = 1太字節/秒的數據到FPGA中。實際上，設計人員必須保證計算架構與系統中所需的數據速率相匹配。

{% hint style='info' %}
假設時鐘頻率為250MHz，每個時鐘週期接收一個採樣，大約需要執行多少蝶形計算才能使用1024點FFT處理每個採樣？16384點FFT怎麼樣？
{% endhint %}

在本節的其餘部分中，我們描述了函數原型void fft（DTYPE X_R [SIZE]，DTYPE X_I [SIZE]）的優化，其中DTYPE是用於表示輸入數據的用户可定製數據類型。這可以是int，float或固定點類型。例如，＃define DTYPE int將DTYPE定義為int。請注意，我們選擇在兩個單獨的數組中實現複數的實部和虛部。X_R數組保存實數輸入值，X_I數組保存虛數值。X_R[i]和X_I [i]將第i個複數保存在單獨的實部和虛部中。

{% hint style='tip' %}
我們在本節中描述了FFT實現中的一個變化，就是FFT對象由實數成了複數。雖然這似乎是一個重大變化，但核心思想保持不變。唯一的區別是數據有兩個值（對應於複數的實部和虛部），運算操作（加，乘等）更加複雜一些。
{% endhint %}

此函數原型使用的是就地實現方法（in-place implementation）。也就是説，輸出數據存儲在與輸入數據相同的陣列中。這樣做消除了對輸出數據的額外陣列的需要，減少了實現所需的內存量。但是，這可能會限制性能，因為我們必須讀取輸入數據並將輸出數據寫入相同的數組。如果可以提高性能，輸出數據就可以使用單獨的數組。資源使用和性能之間總是存在權衡，這裏也是如此。最佳實現方案取決於應用要求（例如，高吞吐量，低功耗，FPGA大小，FFT大小等）

我們從FFT的代碼開始研究，因為這是一個典型的軟件實現代碼。圖5.5顯示了一個嵌套的三個**for**循環結構。外部**for**循環，標記為**stage_loop**在每次迭代期間實現FFT的一個階段。有$${log_2(n)}$$個階段，其中N是輸入樣本的數量。這些階段在圖5.4中清楚標明，該8點FFT具有$${log_2(8)=3}$$級。你可以看到每個階段執行相同數量的計算或相同數量的蝶形運算。在8點FFT中，這個階段有四個蝶形運算。

{% hint style='info' %}
對於N點FFT，每個階段有多少個蝶形運算？整個FFT一共有多少個蝶形運算？
{% endhint %}

第二個for循環，標記為**butterfly_loop**，執行當前階段的所有蝶形運算。butterfly_loop有另一個嵌套for循環，標記為dft_loop。dft_loop的每次迭代執行一次蝶形運算。請記住，我們正在處理複數，並且必須執行復雜的加法和乘法。

dft_loop中的第一行確定了蝴蝶運算的偏移量。蝴蝶操作的“寬度”會根據階段而變化。如圖5.4所示，階段1對相鄰元素執行蝶式運算，階段2對索引相差2的元素執行蝶式運算，階段3對索引相差四的元素執行蝶式運算。計算這個差值並存儲在**i_lower**變量中。我們可以發現存儲在變量**numBF**中的這個差值在每個階段都是不同的。

dft_loop中的剩餘操作通過旋轉因子和加法或減法操作來執行乘法。變量temp_R和temp_I在乘以旋轉因子*W*之後保持數據的實部和虛部。變量c和s是*W*的實部和虛部，使用sin()和cos()計算內置功能。我們也可以使用CORDIC，例如第3章中開發的CORDIC，來更好地控制
實現。最後，使用蝶式計算的結果更新X_R[]和X_I[]數組的元素。

dft_loop和butterfly_loop各自根據階段執行不同的次數。然而，在一個階段中執行dft_loop的總次數是恆定的。butterfly_loop中的for循環的迭代次數取決於該階段中唯一*W*旋轉因子的數量。再次參考圖5.4，我們可以看到階段1僅使用一個旋轉因子，在這種情況下為 $$W_8^0$$。階段2使用兩個獨特的旋轉因子，階段3使用四個不同的$$W$$值。因此，butterfly_loop在階段1中僅具有一次迭代，階段2中具有2次迭代，並且在階段3中具有四次迭代。類似地，dft_loop的迭代次數改變。它在階段1中對於8點FFT迭代四次，在階段2中迭代兩次，在階段3中僅迭代一次。然而在每個階段中，dft_loop體總共執行的次數相同，對於一個8點DFT每個階段執行總計四個蝶形運算。
```c
void fft(DTYPE X_R[SIZE], DTYPE X_I[SIZE]) {
	DTYPE temp_R; // temporary storage complex variable
	DTYPE temp_I; // temporary storage complex variable
	int i, j, k;	// loop indexes
	int i_lower;	// Index of lower point in butterfly
	int step, stage, DFTpts;
	int numBF;			// Butterfly Width
	int N2 = SIZE2; // N2=N>>1

	bit_reverse(X_R, X_I);

	step = N2;
	DTYPE a, e, c, s;

  stage_loop:
	for (stage = 1; stage <= M; stage++) { // Do M stages of butterflies
		DFTpts = 1 << stage;								 // DFT = 2^stage = points in sub DFT
		numBF = DFTpts / 2;									 // Butterfly WIDTHS in sub-DFT
		k = 0;
		e = -6.283185307178 / DFTpts;
		a = 0.0;
	// Perform butterflies for j-th stage
	butterfly_loop:
		for (j = 0; j < numBF; j++) {
			c = cos(a);
			s = sin(a);
			a = a + e;
		// Compute butterflies that use same W**k
		dft_loop:
			for (i = j; i < SIZE; i += DFTpts) {
				i_lower = i + numBF; // index of lower point in butterfly
				temp_R = X_R[i_lower] * c - X_I[i_lower] * s;
				temp_I = X_I[i_lower] * c + X_R[i_lower] * s;
				X_R[i_lower] = X_R[i] - temp_R;
				X_I[i_lower] = X_I[i] - temp_I;
				X_R[i] = X_R[i] + temp_R;
				X_I[i] = X_I[i] + temp_I;
			}
			k += step;
		}
		step = step / 2;
	}
}
```
圖5.5：使用三個嵌套for循環的FFT的常見實現方法。雖然它在處理器上作為軟件運行良好，但它對於硬件實現來説遠非最佳。

{% hint style='tip' %}
Vivado HLS對每個合成函數執行重要的靜態分析，包括計算每個循環可以執行的次數的界限。這些信息有許多來源，包括代碼中的可變位寬，範圍和**assert()** 函數。當與循環II結合使用時，Vivado HLS可以計算FFT功能的延遲或間隔的界限。在某些情況下（通常當循環邊界是可變的或包含條件結構時），該工具無法計算代碼的延遲或間隔並返回“ ？”。在合成圖5.5中的代碼時，Vivado HLS可能無法確定butterfly_loop和dft_loop迭代的次數，因為這些循環具有可變邊界。
**tripcount** 指令使用户能夠向Vivado HLS工具提供有關循環執行次數的更多信息，該工具可用於分析設計的性能。它需要三個可選參數min，max和average。在這段代碼中，我們可以為dft_loop添加一個指令。通過應用此指令，Vivado HLS工具可以計算循環和整體設計的延遲和間隔值的界限。由於Vivado HLS工具使用你提供的數字，如果你為該工具提供了錯誤的tripcount，則報告的任務延遲和任務間隔將不正確，出現垃圾輸入和垃圾輸出。
{% endhint %}

{% hint style='info' %}
在圖5.5中使用tripcount指令進行FFT的適當方法是什麼？你應該設置min，max和average參數嗎？如果FFT的大小發生變化，你是否需要修改tripcount參數？
{% endhint %}

## 5.3 位反轉

我們還沒有談到位反轉功能，它可以反轉輸入數據值，以便我們執行就地FFT。當輸入值是混合的時候，使用該功能就使得輸出數據的順序是正確的。我們現在詳細討論這個功能。

圖5.6顯示了位反轉功能的一種可能實現方法。它將代碼分為兩個函數部分。第一個是bit_reverse（位反轉）功能，對給定數組中的數據進行重新排序，以便每個數據位於數組中的不同索引處。該函數調用另一個函數reverse_bit，它接受一個輸入整數並返回該輸入的位反轉值。

讓我們從reverse_bit函數的簡要概述開始。該函數逐位通過輸入變量並將其轉換為rev變量。for循環體由幾個位運算操作組成，它們對輸入的位進行重新排序。雖然這些操作不是非常複雜，但是這個代碼的意圖是將for循環完全展開，Vivado HLS可以識別輸入的位，並簡單地連接到輸出。這樣的話，reverse_bits函數功能的實現應該根本不需要邏輯資源，而只需要連線。這是一例通過展開循環而大大簡化了運算量的情況。在不展開循環的情況下，必須按順序執行各個“或”操作。雖然這個循環可以流水線化，但'或'操作仍將在FPGA中使用純邏輯實現，並且執行這個循環將會有由被反轉的位數確定的延遲時間（在這種情況下為\gls{fft}_BITS）。

```c
#define FFT_BITS 10			// Number of bits of FFT, i.e., log(1024)
#define SIZE 1024				// SIZE OF FFT
#define SIZE2 SIZE >> 1 // SIZE/2
#define DTYPE int

unsigned int reverse_bits(unsigned int input) {
	int i, rev = 0;
	for (i = 0; i < FFT_BITS; i++) {
		rev = (rev << 1) | (input & 1);
		input = input >> 1;
	}
	return rev;
}

void bit_reverse(DTYPE X_R[SIZE], DTYPE X_I[SIZE]) {
	unsigned int reversed;
	unsigned int i;
	DTYPE temp;

	for (i = 0; i < SIZE; i++) {
		reversed = reverse_bits(i); // Find the bit reversed index
		if (i < reversed) {
			// Swap the real values
			temp = X_R[i];
			X_R[i] = X_R[reversed];
			X_R[reversed] = temp;

			// Swap the imaginary values
			temp = X_I[i];
			X_I[i] = X_I[reversed];
			X_I[reversed] = temp;
		}
	}
}

```
圖5.6：FFT實現的第一階段重新排序輸入數據。 這是通過將輸入數組中索引i處的值與對應於i的位反轉索引處的值進行交換來完成的。函數reverse_bits給出與輸入參數對應的位反轉值，並且交換對應反轉位中的數組中的值。

{% hint style='info' %}
當沒有應用指令時，反向位功能的延遲是多少？ 循環流水線時的延遲是多少？ 整個函數流水線時的延遲是多少？
{% endhint %}
{% hint style='tip' %}
為了實現更好的設計，盲目地使用優化指令很誘人。然而，這可能適得其反。最好的設計師對應用程序和可用的優化都有深刻的理解，並仔細考慮這些以達到最佳效果。
{% endhint %}

現在讓我們優化一下bit_reverse函數。此函數有一個for循環，它遍歷輸入數組的每個索引。值得注意的是有兩個輸入數組X_R[]和X_I[]。由於我們處理的是複數，我們必須存儲實部（在數組X_R[]中）和虛部（在數組X_I[]中)。X_R[i]和X_I[i]保持第i個輸入的實數和虛數值。在for循環的每次迭代中，我們通過調用reverse_bit函數找到索引反轉值，並交換存儲在索引i中的實數和虛數值。當我們瀏覽所有SIZE索引時，我們最終會瀏覽到每一個被反轉的索引下的值。因此，代碼僅根據**if**（i<reversed）條件來執行索引下對應的數值的交換。

## 5.4 任務流水化

將FFT算法劃分為多個階段使Vivado HLS能夠生成一種讓算法的不同階段在不同的數據集上運行的實現方法。這種優化方法使用dataflow指令，稱為任務流水 ，是十分常見的，適用於各種硬件優化的方法。

```C++
void fft_stage(int stage, DTYPE X_R[SIZE], DTYPE X_I[SIZE],
			DTYPE Out_R[SIZE], DTYPE Out_I[SIZE]){
	int DFTpts = 1 << stage; // DFT = 2^stage = points in sub DFT
	int numBF = DFTpts / 2; // Butterfly WIDTHS in sub−DFT
	int step = SIZE >> stage;
	DTYPE k = 0;
	DTYPE e = −6.283185307178 / DFTpts;
	DTYPE a = 0.0;
	// Perform butterflies for j−th stage
butterfly loop:
	for (int j = 0; j < numBF; j++){
		DTYPE c = cos(a);
		DTYPE s = sin(a);
		a = a + e;
		// Compute butterflies that use same W**k
	dft loop:
		for (int i = j; i < SIZE; i += DFTpts){
			int i_lower = i + numBF; // index of lower point in butterfly
			DTYPE temp_R = X_R[i_lower] * c − X_I[i_lower] * s;
			DTYPE temp_I = X_I[i_lower] * c + X_R[i_lower] * s;
			Out_R[i_lower] = X_R[i] − temp_R;
			Out_I[i_lower] = X_I[i] − temp_I;
			Out_R[i] = X_R[i] + temp_R;
			Out_I[i] = X_I[i] + temp_I;
		}
		k += step;
	}
}

void fft_streaming(DTYPE X_R[SIZE], DTYPE X_I[SIZE], DTYPE OUT_R[SIZE], DTYPE OUT_I[SIZE])
{
  #pragma HLS dataflow
  DTYPE Stage1_R[SIZE], Stage1_I[SIZE];
  DTYPE Stage2_R[SIZE], Stage2_I[SIZE];
  DTYPE Stage3_R[SIZE], Stage3_I[SIZE];

  bit_reverse(X_R, X_I, Stage1_R, Stage1_I);
  fft_stage(1,Stage1_R, Stage1_I, Stage2_R, Stage2_I);
  fft_stage(2,Stage2_R, Stage2_I, Stage3_R, Stage3_I);
  fft_stage(3,Stage3_R, Stage3_I, OUT_R, OUT_I);
}
```
圖5.7：代碼將8點FFT分為4個階段，每個階段都是一個單獨的功能。bit_reverse是第一階段，8點FFT還有三個階段。

我們可以自然地將FFT算法劃分為$$log_2(N+1)$$ 級，其中N是FFT的點數。第一級交換輸入數組中的每個元素，其中元素位於數組中的位反轉地址。在該位反轉階段之後，我們執行蝶形運算的$$log_2N$$ 階段。這些蝶形級中的每一個具有相同的計算複雜度。圖5.7描述瞭如何將8點FFT分成四個獨立的任務。針對每個階段的任務代碼具有單獨的功能分別是：位反轉、第一階段、第二階段和第三階段。每個階段有兩個輸入數組和兩個輸出數組：一個用於實部，另一個用於複數的虛部。假設DTYPE在別處已經定義好，例如作為int，float或定點數據類型。

![圖5.8：該將FFT分成了不同的階段允許跨越每個階段的任務流水線。該圖演示了同時執行4個具有三個FFT級（即，8點FFT）的示例。](images/fft_dataflow_behavior.jpg)

重構FFT代碼允許我們執行任務流水線操作。圖5.8給出了一個例子。在這個操作中，我們允許第二個任務在第一個任務僅完成第一個函數bit_reverse之後就啟動，而不是等待第一個任務完成代碼中的所有四個四個函數再開始第二個任務。 第一個任務繼續按順序執行流水線中的每個階段，然後按順序執行剩餘的任務。一旦流水線已滿，所有四個子功能同時執行，但每個子功能都在不同的輸入數據上運行。類似地，同時計算四個8點FFT，每個點在硬件的不同組件上執行。圖5.8的中間部分顯示垂直四級中的每一級代表一個8點FFT。水平方向待變時間的增加。因此，一旦我們開始了第四個8點FFT，我們就有四個FFT同時運行。

```C++
void fft_streaming(DTYPE X_R[SIZE], DTYPE X_I[SIZE], DTYPE OUT_R[SIZE], DTYPE OUT_I[SIZE])
{
	#pragma HLS dataflow
	DTYPE Stage_R[M][SIZE], Stage_I[M][SIZE];
	#pragma HLS array partition variable=Stage_R dim=1 complete
	#pragma HLS array partition variable=Stage_I dim=1 complete

	bit_reverse(X_R, X_I, Stage_R[0], Stage_I[0]);
stage loop:
	for (int stage = 1; stage < M; stage++){ // Do M−1 stages of butterflies
		#pragma HLS unroll
		fft_stage(stage, Stage_R[stage−1], Stage_I[stage−1], Stage_R[stage], Stage_I[stage]);
	}
	fft_stage(M, Stage_R[M−1], Stage_I[M−1], OUT_R, OUT_I);
}
```
圖5.9：一段使用循環的隨機大小的FFT代碼。在循環被展開後，展開循環中的每個函數調用成為一個dataflow的進程。

**dataflow** 指令可以從函數和循環中構造出單獨的流水線階段（通常稱為進程）。雖然圖5.7中的代碼僅使用函數，但我們可以使用四個循環而不是四個函數來實現類似的結果。實際上，我們可以通過直接使用#pragma HLS unroll指令在原始代碼中展開外部stage_loop來得到這個結果。這樣的一段代碼有以下幾個優點。第一點，它跟原本算法的結構更接近，減少了需要改動的代碼。第二點，代碼不會是宂長的，更易編寫。第三點，再次對代碼進行參數化設置，以支持具有不同size值相同代碼。圖5.9顯示了這樣一段代碼。

**dataflow** 指令和**pipeline**指令都生成能夠流水線執行的電路。關鍵的區別在於任務流水的粒度不一樣。**pipeline** 指令構造了一個在循環級別上有效的流水線化的體系結構，由指令中的II所決定。運算符是靜態調度的，如果II大於1，則可以在同一運算符上共享運算。**dataflow** 指令構造了一種體系結構，該體系結構可以有效地進行流水線操作，以獲取（可能未知的）時鐘週期數的操作，例如在數據塊上運行循環的行為。這些粗粒度操作不是靜態調度的，是通過流水線中的數據握手來動態地控制的。在FFT的情況下，每個階段是對數據塊（整個陣列）的操作，其需要大量的週期。在每個階段中，循環都對塊中的數據執行單獨的操作。因此，在這種情況下，通常在頂層使用**dataflow**指令來形成粗粒度管道，並與每個循環中的**dataflow** 指令相結合，以形成對每個單獨數據元素上進行細粒度流水操作。

**dataflow** 指令必須要有存儲器設置以保證在不同進程之間傳遞數據。在Vivado HLS可以保證進程按順序訪問數據的情況下，它使用FIFO實現存儲。這要求我們用與從數組中讀取數組的順序相同的順序來寫入數組。如果不是這種情況，或者如果Vivado HLS無法確定是否滿足此流式傳輸條件，則可以使用乒乓操作來實現存儲。乒乓操作由兩個（或更多）概念數據塊組成，每個數據塊都是原始數組的大小。其中一個數據塊可以由源進程寫入，而另一個數據塊由目標進程讀取。術語“乒乓”就來自每次執行任務時對每個數據塊的讀寫都是交替的。也就是説，源進程將數據寫入一個數據塊，然後在開始之前切換到另一個數據塊。下一個任務中，目標進程從生成器未寫入的塊中讀取數據。因此，源進程和目標進程永遠不能同時從同一個數據塊寫入和讀取。

乒乓操作需要足夠的內存來存儲每個通信數組至少兩次。FIFO通常可以佔用更少的資源，儘管確定每個fifo的最小尺寸通常是一個困難的設計問題。但是，與FIFO不同，乒乓操作中的數據可以按任何順序寫入和讀取。因此，當按順序生成和使用數據時，FIFO通常是最佳選擇，而當沒有這種常規數據訪問模式時，用乒乓操作來緩存數據是更好的選擇。

有效地使用**dataflow**函數仍然需要優化每個單獨進程的行為。流水線中的每個單獨流程仍然可以使用我們之前看到的技術進行優化，例如代碼重組，流水線操作和展開。例如，我們已經在5.3節討論了bit_reverse函數的一些優化。通常，在考慮整體性能目標的同時優化各個任務非常重要。很多時候，最好從小功能開始，並瞭解如何隔離優化它們。作為設計人員，通常可以更容易理解一小段代碼中發生的事情，並希望快速確定最佳優化方案。在優化每個單獨的功能之後，我們就可以指定小功能的特定實現方式以優化的更大功能模塊，你可以向上移動層次結構，最終到達頂部。

但是，我們也必須在總體目標範圍內考慮局部優化。特別是對於數據流的一些設計，整個流水線的實現間隔永遠不會小於每個單獨過程的間隔。再看圖5.7，假設位反轉的間隔為8個週期，第一個階段需要12個週期，第二個階段需要12個週期，而第三個階段需要14個週期。使用**dataflow**時，總的任務間隔為14，由所有任務或是函數的最大值決定。這意味着你應該小心平衡不同流程之間的優化，目標是創建一個平衡的流水線通道，其中每個流程的間隔大致相同。在該示例中，改善bit_reverse函數的間隔不能改善fft功能的整體間隔。實際上，如果可以用更少的資源實現整個FFT功能，增加bit_reverse函數的延遲可能是有益的。

## 5.5 結論

我們總體目標是創建一個滿足應用目標的最優化設計。這個目標可能是創建一個資源使用最少的實現方式。或者，無論FPGA的大小、功率、能量限制如何，目標是創建一個能夠實現最高吞吐量的方案。再或者，如果對應用程序有實時約束要求，傳遞結果的延遲可能也很重要。所有優化方法都會以不同的方式改變這些因素。

一般來説，沒有一種固定的算法可以完成你設計的優化。它是應用功能，時序約束和設計者自身能力的一個綜合體現。然而，設計人員必須深入瞭解應用程序本身，時序約束以及綜合工具的各方面問題。

我們試圖在本章中説明以上這些。雖然FFT是一種經過充分研究的算法，但由於它綜合了大量已知的硬件實現技巧，所以仍然可以作為高級綜合的良好示例。當然，我們也沒有給出優化的所有技巧。無論如何，我們試圖提供一些關於FFT關鍵優化的見解，我們希望這些優化可以作為你如何使用Vivado HLS工具來優化FFT的指南。

首先，我們要了解算法，所以花了很多時間來解釋FFT的基礎知識，以及它與DFT的關係。我們希望讀者理解這些基礎知識，因為這是構建最佳硬件實現方案的的最重要部分。當然，設計人員可以將C/MATLAB/Java/Python代碼轉換為Vivado HLS並探尋有效的實現方式。同樣，設計師可能會盲目地應用指令來獲得更好的優化結果。但是，如果不深入理解算法，設計師就無法接近最佳結果
本身。

其次，我們使用**dataflow**指令介紹任務級流水線。這是一項強大的優化方法，是通過代碼重組無法實現的。也就是説，設計者必須使用此優化來獲得這樣的設計。因此，設計師必須瞭解它的功能，缺點和用法。

另外，我們基於前面章節中的一些優化方式構建了循環，例如，循環展開和流水線操作。所有這些對於獲得優化的FFT硬件設計都很重要。雖然我們沒有在這些優化上花費太多時間，但它們非常重要。

最後，我們試圖向讀者強調這些優化不能孤立地完成。有時優化是獨立的，它們可以孤立地完成。例如，我們可以專注於其中一項任務（例如，我們在第5.3節中所優化的bit_reverse函數）。但很多時候，不同的優化會相互影響。例如，inline指令將影響函數的流水線操作。還有一點很重要，當我們優化任務或是功能時，可以通過功能層次從下向上傳播。同時，設計人員也必須瞭解優化對本地和全局算法的影響。
