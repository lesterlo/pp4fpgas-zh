# 第六章 稀疏矩陣向量乘法

稀疏矩陣向量乘（**SpMV**）把一個稀疏矩陣與一個向量相乘。稀疏矩陣是指矩陣中大部分元素為0的矩陣。這裏的向量本身也可是稀疏的，但通常情況下是密集的。作為一種通用的運算，在科學應用、經濟模型、數據挖掘、信息檢索中廣泛應用。例如，在利用迭代法求解稀疏線性方程組和特徵值的問題。同時，也被應用於網頁搜索排名和計算機視覺（圖像重構等）。

本章會引入幾個與HLS相關的新概念，並進一步深入之前討論過的優化。本章的目標之一是引入一種更復雜的數據結構。我們用壓縮行存儲（CRS）來保存稀疏矩陣。另一個目標是演示如何進行性能測試。我們編寫了簡單的激勵用來檢驗設計是否正確。這在硬件設計中十分重要，**Vivado®HLS** 工具採用HLS C編寫激勵，並能輕鬆的對工具生成的RTL代碼進行多方面的驗證。這是基於HLS設計比基於RTL設計的巨大優勢之一。章節中也會講解如何採用Vivado®HLS工具進行C/RTL聯合仿真。不同**SpMV**設計會帶來性能上差異，因為執行時間和稀疏矩陣是密切相關的，所以我們必須通過輸入數據來確定任務執行之間的間隔以及任務延遲。


## 6.1 背景 ##

圖6.1顯示了一個4x4的矩陣M表示的2種方式。其中圖6.1-a採用通用的二維方式16個元素來表示矩陣，每個元素存儲在自己對應的位置上。圖**6.1**-b採用**CRS**的方式表示相同的矩陣。**CRS** 作為一種數據結構，由3個數組組成。值(**values**)數組保存矩陣中非零元素的值。列索引(**columnIndex**)數組和行指針（**rowPtr**）數組對非零元素的位置信息進行編碼。列索引存儲每個元素的列數，行指針包含每一行第一個元素在**values**中的索引。**CRS** 結構避免存儲矩陣中的0值，確實在數值數組中確實沒有存儲0。但是在這個例子中，雖然數值數組不保存0，但是列索引數組和行指針數組作為標記信息，表示了矩陣的形態。**CRS** 廣泛用於大型的矩陣但是僅僅有少量的非零元素（少於10%或者更低），這樣可以簡化這類矩陣的存儲以及相關的運算。



![圖 6.1: M是一個4x4矩陣，用兩種方式表示：同"密集"矩陣一樣存在二維數組之中；作為稀疏矩陣，以行壓縮存儲的形式保存，行壓縮存儲是一種由3個數組組成的數據結構。](images/crs.jpg)

但是，CRS對矩陣的稀疏性沒有要求，可以適用於任何矩陣。作為一種針對矩陣的通用方法，但不見得是最高效的。CRS結構也不見得是表示稀疏矩陣最高效的方式，其他稀疏矩陣表示方法也在被使用。

更準確的講，CRS作為一種數據結構由3個數組構成：**值**(**values**)、**列索引**(**colIndex**)、**行索引**（**rowPtr**）。值數組和列索引表示稀疏矩陣**M**中的每一個非零元素，這些數組表示矩陣**M**採用行的方式，從左到右，從上到下。矩陣中的數據保存在值數組中，列索引數組保存數據在數組中水平方向的位置，如果 **values[k]** 表示  $$M_{ij}$$  其中$$collndex[k]= j$$。數組**rowPtr**用$$n+1$$的長度來表示n行矩陣。**rowPtr[k]** 表示在行k之前，矩陣中所有元素的數目，其中$$rowPtr[0]=0 $$且最後一個元素**rowPtr[k]** 總是表示當前矩陣k行之前所有非零元素的個數$$ M_{ij}$$ ,其中$$rowPtr[i] \leq k  \leq rowPtr[i+1]$$。如果行k包含任何非0元素，那麼**rowPtr[k]** 將包含當前行的第一個元素。注意，如果當前行沒有非0元素，那麼 **rowPtr** 數組中的值將會重複出現。

從圖**6.1** a）中，我們可以行優先的方式遍歷矩陣，從而確定值（**values**）數組在**CRS**中的形式。只要發現一個非0元素，它的值會被保存在下一個索引 $$i$$ 中，同時，它的列號**columnIndex[i]** 會被保存在列數組中。另外，在我們訪問一個新行的時候，我們保存下一個值的索引 $$i$$ 在**rowPtr**數組中。所以，**rowPtr** 數組的第一個元素總是0。從圖 6.1 b)中，我們可以把矩陣轉換為二位數組表示的方式。第一步是根據**rowPtr**數組，確定每一行中非0 元素的個數。對行 $$i $$ 而言，該行中元素的數目為$$rowPtr[i]-rowPtr[i+1]$$的差值。所以當前行的值可以從**values**數組**values[rowPtr[i]]** 開始，通過遞歸得到。在我們的示例矩陣中，因為前 **rowPtr** 數組前2個元素是0和2，所以我們知道第一行有2個非0元素，即**value[0]** 和**value[1]** 。第一個非0元素在**values**數組中,**value[0]** 是3。該值所對應的列號為1，因為$$columnIndex[0]=0$$。以此類推，矩陣中第二行元素的個數為$$k\in[2,4)$$,第三行的元素個數為$$k \in [4,7)$$。最後，共有9個非0元素在矩陣中，所以**rowPtr**最後一個值是9。

```c
#include "spmv.h"

void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ],
		DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE]){
L1: for (int i = 0; i < NUM_ROWS; i++) {
		DTYPE y0 = 0;
	L2: for (int k = rowPtr[i]; k < rowPtr[i+1]; k++) {
			#pragma HLS unroll factor=8
			#pragma HLS pipeline
			y0 += values[k] * x[columnIndex[k]];
		}
		y[i] = y0;
	}
}

```

![圖6.2: 主體代碼演示了係數矩陣向量乘（SpMV）y=M*x的計算。採用CRS的方式，通過rowPtr、columnIndex 和 value 保存矩陣M。第一個for循環通過迭代訪問每一行，第二個for循環訪問每一列，實現矩陣M中非0元素和向量中對應的元素相乘並保存值在向量y中。](images/placeholder.png)


{% hint style='info' %}
給定一個二維數組表示一個矩陣，通過C代碼實現矩陣CRS格式。編寫對應的C代碼實現將矩陣從CRS格式轉化為二維數組的形式。
{% endhint %}

結果表明，通過採用**CRS**的方式，我們能高效的實現稀疏矩陣乘法，不需要將矩陣轉化為二維形式。實際上， 對於大型的矩陣僅僅只有一小部分非0元素，稀疏矩陣向量乘法會比第四章中討論的密集矩陣向量乘高效很多。因為我們直接找到非0元素，並執行非0元素對應的運算。



## 6.2 基本實現

圖6.2 提供了基本代碼對係數矩陣乘法的實現。函數**spmv**函數有5個參數，分別是**rowPtr**、**columnIndex** ，以及 **values** 對應矩陣 **M** 的 **CRS** 格式中包含的3個參數，這和圖6.1中描述的數據結構等價。參數 $$y$$ 用於保存輸出的結果，參數x表示輸入的被乘向量$$x$$。變量**NUM_ROWS**表示矩陣**M**中行號。變量**NNZ**表示矩陣中非0元素的個數。最後，變量SIZE表示數組x和數組y中元素的個數。

外層**for**循環標籤為**L1**，對矩陣的行進行遍歷。將矩陣當前的行與向量x相乘，得到輸出的結果$$y$$。內層循環標籤為**L2**，實現對矩陣**M**中每列元素的遍歷。L2循環迭代計算$$rowPtr[i+1]-rowPtr[i]$$計算每一行非0元素的個數。每次循環計算，能從**value**數組中讀取矩陣M的非0元素然後對應的從x數組中取得被乘向量x的值，對應相乘。**cloumnIndex[k]** 中的值保存了對應的列號**k**。

```c
#ifndef __SPMV_H__
#define __SPMV_H__

const static int SIZE = 4; // SIZE of square matrix
const static int NNZ = 9; //Number of non-zero elements
const static int NUM_ROWS = 4;// SIZE;
typedef float DTYPE;
void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ],
		  DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE]);

#endif // __MATRIXMUL_H__ not defined
```
![圖6.3： spmv函數和激勵的頭文件](images/placeholder.png)



## 6.3 測試平台

圖6.4 展示了一個針對**spmv**函數測試平台。測試平台通過定義**matrixvector**函數，直接實現矩陣向量乘法，它不考慮矩陣是否為稀疏矩陣以及矩陣是否採用**CRS**方式表示。我們比較**matrixvector**函數輸出和**spmv**函數的輸出。


{% hint style='info' %}
在通常的測試平台中，需要實現的函數都會有個“黃金"參考(gold reference)，作為用户期望綜合的結果。測試平台會比較黃金參考的輸出和通過**Vivado®HLS**綜合的代碼執行結果。最好的實踐方式是，測試平台既可以用於黃金參考，也可用於被綜合的代碼。這樣就保證了兩者實現的正確性。
{% endhint %}


測試平台在主函數**main**中執行。這裏我們通過設置**fail**變量初始化為0，當**spmv**函數的輸出成結果與**matrixvector**函數輸出結果不相同是時，變量置1。定義與矩陣**M**相關的變量、被乘向量$$x$$ 和輸出結果$$y$$。對於矩陣**M**，即有普通模式，也有**CSR**模式（保存為**values**、**columnIndex**、**rowPtr**）。矩陣**M** 的**value**如圖6.1中所示，輸出向量$$y$$有兩種，其中y_sw數組保存**matrixvector**函數輸出的結果，y數組保存**spmv**函數輸出的結果。

在定義好所有的輸入變量和輸出變量之後，分別調用**spmv**函數和**matrixvector**函數並輸入合適的數據。 接下來的**for**循環用於比較y_sw和y中的每一個對應的結果。如果其中一個不相同，則將**fail** 標誌置1。最後，程序會打印測試的結果並返回**fail**變量。

```c
#include "spmv.h"
#include <stdio.h>

void matrixvector(DTYPE A[SIZE][SIZE], DTYPE *y, DTYPE *x)
{
	for (int i = 0; i < SIZE; i++) {
		DTYPE y0 = 0;
		for (int j = 0; j < SIZE; j++)
			y0 += A[i][j] * x[j];
		y[i] = y0;
	}
}

int main(){
	int fail = 0;
	DTYPE M[SIZE][SIZE] = {{3,4,0,0},{0,5,9,0},{2,0,3,1},{0,4,0,6}};
	DTYPE x[SIZE] = {1,2,3,4};
	DTYPE y_sw[SIZE];
	DTYPE values[] = {3,4,5,9,2,3,1,4,6};
	int columnIndex[] = {0,1,1,2,0,2,3,1,3};
	int rowPtr[] = {0,2,4,7,9};
	DTYPE y[SIZE];

	spmv(rowPtr, columnIndex, values, y, x);
	matrixvector(M, y_sw, x);

	for(int i = 0; i < SIZE; i++)
		if(y_sw[i] != y[i])
			fail = 1;

	if(fail == 1)
		printf("FAILED\n");
	else
		printf("PASS\n");

	return fail;
}
```
![圖6.4 ： 一個簡單spmv函數的簡單測試平台。測試平台生成了一個用例，並且計算矩陣的向量乘法通過稀疏矩陣乘法（spmv）和非係數矩陣乘法(matrixvector)。](images/placeholder.png)

這個測試平台相對簡單並且可能無法充分驗證所有的輸入都能正常輸出。最主要的原因是，它僅僅只用了一個矩陣作為例子，相反，一個好的激勵會測試許多矩陣。通常，會通過隨機的方式產生輸入的測試用例，並且重點測試邊界用例。在這個例子中，我們不僅要保證值正確計算，同時保證通過加速器正確的被執行了，而且編譯相關的參數也會改變會，不同策略會在實現不同加速器。最重要的是在同一段程序中，我們能通過隨機產生很多輸入數據來進行測試。編譯相關的參數每次發生變化，都需要我們重新編譯代碼。


{% hint style='tip' %}
創建一個複雜testbench，通過隨機數方式生成許多組測試數據。稀疏矩陣編譯相關參數應該是可以修改的（例如，**SIZE**，**NNZ** 等）。創建一個HLS綜合腳本，在編譯時間參數合理範圍改變時，能執行代碼很多次。
{% endhint %}




## 6.4 指定循環的屬性

如果直接將上述代碼進行綜合，我們可以得到函數運行的時鐘週期及資源佔用率。但是，我們不能得到模塊執行所需的時鐘週期、任務執行的延遲和任務執行之間的間隔。因為這些都取依賴於輸入數據，由**spmv**函數外部因素決定。最主要的因素是，內層循環執行的次數是由矩陣**M**中非0元素個數決定的。非0元素的個數在代碼中是由常量**NNZ**決定的，雖然可以調用函數計算不同大小的矩陣，但是實際迭代次數是和輸入數據相關的。另外，性能也會因為非0元素的分佈、綜合優化的約束產生不同。更復雜的是，迭代的次數由輸入決定，許多可能的輸入並沒有被遍歷。所以，對於工具而言，不通過複雜的分析和額外的信息，工具是不能知道spmv函數執行需要多少時鐘週期。**Vivado®HLS** 工具也不能進行上述的分析。

{% hint style='info' %}

spmv函數能正常工作的前提條件是什麼？證明給定的前提條件，矩陣中每個非0元素實是不是在對應一次內層循的執行？

{% endhint %}

有幾種方式能幫助工具進行性能的分析，其中一種方式就是想**Vivado®HLS**提供循環邊界的額外信息。這可以通過使用**loop_tripcount** directive實現，它能讓設計者指定最小、最大和平均迭代次數針對特定的循環。通過提供這些值， **Vivado®HLS** 能提供時鐘週期級別的評估。

{% hint style='tip' %}

使用**loop_tripcount** directive 用變量指定循環的最小，最大和平均迭代次數，這樣**Vivado**®HLS 工具能對當前設計時鐘週期數目進行估計。這些不影響最後綜合的結果，只會影響綜合報告。

{% endhint %}

{% hint style='info' %}

對spmv函數使用**loop_tripcount** directive，語法格式 # pragma HLS loop_tripcount min=X, max=Y, avg=Z 其中X，Y，Z正的常量。哪個循環需要使用directive?當改變參數（min、max和avg）以後，綜合報告有什麼不同？這對時鐘週期有影響嗎？這對資源佔用有影響嗎？

{% endhint %}

**loop_tripcount** 引導能幫助設計者對函數的性能有個原始的估計。這樣,相同的函數通過使用不同的directives優化或者重構代碼後的各種方案可以進行比較。但是，這不能確定**min**、**max**和 **avg** 參數。這也很難確定邊界條件min和max的值。如果有測試平台，就有一種更準確的方式用於計算**spmv**函數執行的時鐘週期數，那就是**C/RTL** 協同仿真。



## 6.5  C/RTL 協同仿真

**C/RTL** 協同仿真能自動化測試Vivado®HLS工具生成的RTL代碼，通過已執行綜合的代碼和testbench實現。每次執行綜合以後的代碼和提供的測試平台，記錄輸入和輸出結果。輸入的值按照時鐘轉換成**輸入向量**。這裏的輸入向量用於生成RTL設計的RTL級仿真，同時記錄**輸出向量**。更新綜合後的代碼， 再次運行測試平台並保存輸入和輸出數據。測試平台如果返回值是0，則表示成功；若激勵返回非0值，則表示失敗。

 **C/RTL** 協同仿真流程通過C 測試平台，結合VIvado®HLS 生成的**RTL**代碼，實現時鐘週期級別的仿真。這樣，就能準確對生成的**RTL**代碼進行性能評估，即使性能與輸入數據有關。被綜合的函數運行週期最小值，最大值，平均時鐘週期以及間隔在仿真完成以後都能準確的得到。

注意這些數值對應了時鐘週期，其通過testbench中輸入數據得到的。所以，它們和testbench本身質量息息相關。如果測試平台沒有很好的對函數執行測試，即與實際部署的情況一樣，那麼結果將不準確。另外，輸入測試向量都是基於理想的時序，不能反映模型實際工作時，外部接口對函數的影響。實際的性能可能會比仿真的要低，如果執行過程中阻塞在輸入數據或對外部存儲的訪問上。不過，設計者可以方便地通過協同仿真的方式確定時鐘週期個數，不需要可變循環的循環邊界。

{% hint style='info' %}

C/RTL協同仿真能提供可變循環邊界函數的延遲。它反饋函數運行時延遲的最小值、最大值和平均值以及函數運行間隔。這些延遲和測試平台輸入的數據是強相關的。

{% endhint %}

![圖6.5  spmv函數內部循環流水執行過程和結構](images/spmv_behavior.jpg)

{% hint style='info' %}

當採用圖6.4提供的測試平台時，函數運行的最小值、最大值和平均值以及函數間隔是多少個時鐘週期？

{% endhint %}

## 6.6 循環的優化與數組的分塊

我們可以通過**Vivado®HLS** 工具得到當前函數的性能和麪積的評估結果，然後可以考慮如何對函數進行優化。流水線、循環展開、數組分塊是第一類最常用的優化方法。最典型的方式是從最內層的循環，然後根據需要向外層循環進行。

在這個例子中， 對最內層的**L2**循環進行流水線化也許是我們最先和最容易想到的優化方式。這個連續迭代的循環在執行上流水以後，總體運行會加快。如果不採用流水，**L2** 循環將按照串行執行。注意，**L1** 循環此時還是按照串行的方式執行。

圖6.5演示了**spmv**函數在**L2**循環採用流水方式時運行的步驟。每次**L2**的循環都被$$II=3$$流水化。流水線允許同一外層循環執行一次迭代時，內層循環執行多次循環迭代。此時，內層循環II受限於遞歸（recurrence ）操作。$$II=3$$是因為我們認為加法器有3個時鐘週期的延遲。外部循環沒有采用流水的方式，所以內層的循環必須在下外層L2循環開始執行前，計算完成並輸出結果。

{% hint style='info' %}
對最內層的L2  **for** 循環進行流水化，通過在spmv函數中增加流水directive如圖6.2所示。II(initiation interval)最後是多少？在你指定II的值以後，最終目標的II值是增大了還是減少了？
{% endhint %}

觀察執行步驟，我們可以發現有幾個因素限制了循環執行性能。第一個因素，遞歸（recurrence ）操作限制了循環的 **II**。第二個因素，外層的循環沒有采用流水的方式。一種高效計算稀疏矩陣向量乘法的方式，每個時鐘週期把乘法器和加法器使用起來。當前的設計離這個目標還很遠。

在章節4.3中，我們探究了幾種設計優化技術，其中包括對不同的循環進行流水，循環展開，數組分割。掌握在這些技術之間進行權衡是一項挑戰，因為它們之間經常相互依賴。我們通常聯合使用這些技術，為了得到好的性能謹慎的選擇其中一種而不選擇另一種也許結果會更糟糕。例如，在我們使用循環展開是，設計者需要明白它對數據訪問的影響。增加了對數據訪問的操作但是設計性能又受限於數據訪問時，優化毫無益處。同樣，如果提供了宂餘的存儲端口，實際中使用率不高，這樣對提高性能毫無幫助反而增加了資源的消耗。

仔細思考一下上述優化技術組合後複雜多變的樣式，我們建議你嘗試下面的練習：

{% hint style='info' %}

對spmv設計進行綜合，採用表6.1提供的10種directives，每種都有不同的流水，展開和分割針對不同的循環和數組。這些分割在不同的數組（values、columnIndex、x）上使用。你看到結果的趨勢是如何的？增加了展開和分割，是有利於還是不利於面積？性能如何？為什麼？

{% endhint %}

​     表6.1  稀疏矩陣向量乘法可優化的方式

|        | L1       | L2                         |
| ------ | -------- | -------------------------- |
| case1  | -        | -                          |
| case2  | -        | pipeline                   |
| case3  | pipeline | -                          |
| case4  | unroll=2 | -                          |
| case5  | -        | pipeline,unroll=2          |
| case6  | -        | pipeline,unroll=2,cyclic=2 |
| case7  | -        | pipeline,unroll=4          |
| case8  | -        | pipeline,unroll=4,cyclic=4 |
| case9  | -        | pipeline,unroll=8          |
| case10 | -        | pipeline,unroll=8,cyclic=8 |
| case11 | -        | pipeline,unroll=8,block=8  |


如果你完成了上述練習，你會發現盲目的使用優化directives，可能不會得到你期望的結果。通常在設計時， 在思考下考慮應用的特性，選擇針對設計的特定優化方式。當然，這也需要一些直覺能力和一些專用工具投入使用。雖然，搞清楚像**Vivado®HLS**這樣複雜工具中每一個細節是困難乃至不可能的，但是我們能基於關鍵的方面建立思考模型。

上面我們在用例3和4中考慮對外層循環**L1**進行流水化操作而不是對內層循環。這種變化針對一個任務，可以提高潛在的並行程度。為了完成優化，**Vivado®HLS** 工具必須展開代碼中所有的內層循環**L2** 。如果循環能全部展開，這樣能減少計算循環邊界的時間，同時也能消除遞歸（recurrences）。但是代碼中的內層循環Vivado HLS是無法完全展開的，因為循環邊界不是常量。

{% hint style='info' %}
例如在實現上面提到的例子3，在最外層的循環**L1**使用流水化directive。在不設定目標**II**時，**II** 值是多少？資源佔用率發生了什麼變化？增加了**II**後資源佔用率結果如何？這與之前採對L2循環進行流水化，結果有什麼不同？這和最基本的設計（無 directives）相比有什麼不同？當你對外層循環進行展開時，結果到底如何？（提示：檢查綜合後的日誌信息）
{% endhint %}

另外一種增加並行化的方式是對內層循環進行局部循環展開，就像之前例子5到10。這種變化實現更多的並行化，通過在相同的循環迭代中，執行更多的操作。有些情況，Vivado  HLS 工具在對內層循環進行流水化時，通過實現更多操作來提高性能。但是，這還是很難提高內層循環的II，由於內層循環的遞歸操作。但是，在II大於1的情況下， 許多操作可以共享同一個計算單元。

圖6.6展示了一個局部展開的代碼。在這段代碼中，**L2** 循環被分成2個循環，分別為**L2_1**和**L2_2**。最內層的循環**L2_2**執行的次數由參數**S**確定。內部循環包含了最原始的**L2**循環，其中循環邊界是由最原始的**L2**循環確定的。代碼中，**L2_1** 循環包含了不確定次數的乘法和加法操作，運算次數由參數**S**確定，和一次遞歸完成累加$$y0 += yt$$。

注意圖**6.6**中的代碼和自動循環展開的代碼是由一點點區別的。自動循環展開復制計算，但是保留每次計算先後順序（除了當前的例子）。這就導致了計算順序由內層循環決定，如圖6.7左所示。對計算順序進行調整後，操作上的依賴關係如圖6.7 左邊所示。在當前的代碼中，最後累加求和是一個遞歸（recurrence ）。當使用浮點數據類型時，這種調整計算順序的操作可能對程序產生改變，所以Vivado HLS對這種類型的代碼不進行操作順序自動調整。

這個設計可能會被綜合、實現如圖**6.8**所示的結果。在這個例子中，$$S=3$$與$$II$$最匹配，乘法器的延遲正好是3。所有的運算過程都是在一個乘法器和加法器上執行。比較這個例子與圖**6.5**中的例子，我們可以發現一些缺點。最明顯的是，內層循環的流水線長度很長，實現的時候需要多個更多的週期才能執行下一次外層**L1**循環。處理一行中非零元素和執行塊**S** 相同。一行有個3個元素和一行有一個元素計算的時間是相同的。剩下的運算也需要在循環流水線中執行，即使他們的結果沒有用。為了嚴格的比較兩個設計的特性，我們需要了解設計對矩陣每行非零元素個數的預期。
```c
#include "spmv.h"

const static int S = 7;

void spmv(int rowPtr[NUM_ROWS+1], int columnIndex[NNZ],
          DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE])
{
  L1: for (int i = 0; i < NUM_ROWS; i++) {
	  DTYPE y0 = 0;
    L2_1: for (int k = rowPtr[i]; k < rowPtr[i+1]; k += S) {
#pragma HLS pipeline II=S
		  DTYPE yt = values[k] * x[columnIndex[k]];
	  L2_2: for(int j = 1; j < S; j++) {
			  if(k+j < rowPtr[i+1]) {
				  yt += values[k+j] * x[columnIndex[k+j]];
			  }
		  }
		  y0 += yt;
	  }
    y[i] = y0;
  }
}
```
![圖6.6  局部展開圖6.2中**smpv**函數](images/placeholder.png)

![圖6.7 針對累加的兩種不同方式的局部展開。左邊的版本有3個加法器進行遞歸操作，相反右邊的版本只有1個加法器進行遞歸累加](images/spmv_partial_unroll.jpg)


![圖6.8 圖6.6中 spmv函數基於部分展開和內部流水線處理後執行過程](images/spmv_unrolled_behavior.jpg)


如果矩陣每行非零元素很少，則採用第一種實現方式較優；如果矩陣中每行非零元素較多，則第二種實現方式更好。

需要注意，這裏存在一個關於先有雞還是先有蛋的問題。我們需要知道目標器件和時鐘週期，這樣才能確定流水線中加法器能不能滿足時序要求。只有在我們知道流水線的級數之後（也許S=1時，Vivado HLS才能識別到加法遞歸），我們才能選擇合適版本的參數S，來滿足$$II=1$$。一旦我們確定了**S**，我們能通過**C/RTL**協同仿真來，通過一組測試數據，確定是不是達到了性能上的要求。因為循環邊界是可變的，所以得到的性能參數是依賴於數據的，所以我們需要設定不同的**S**，來找到性能的最大值。改變器件的類型和工作頻率會影響之前所有的設計！儘管看來去高層次綜合（**HLS**）對解決問題提供的幫助不多，相比於RTL開發新版本然後進行驗證，它開發起來快（代碼編寫方便）。
{% hint style='info' %}
圖6.8可以實現時，**S** 與加法器流水線等級相同。如果**S**設定較大，結果會怎樣？如果**S** 設定較小，結果會怎樣？如果目標**II**小於**S**會怎樣？如果目標**II**大於**S**會怎樣？
{% endhint  %}

## 6.7 小結

在本章節中，我們介紹了係數矩陣向量乘法（SpMV），這延續了之前對矩陣運算的研究。SpMV 顯得很有趣，因為它採用了一種特別的數據結構。為了減少大量的存儲，矩陣採用行壓縮的方式存儲，這樣就要求我們以一種非直接的方式對矩陣進行訪問。

這一章節首先我們了**Vivado®HLS**工具測試和仿真的能力。我們採用一個基於SpMV簡單的激勵文件，講解HLS工作流程。另外，我們對**Vivado®HLS**工具中**C/RTL** 協同仿真進行了講解。這對我們得到設計準確性能結果是十分重要。矩陣越不稀疏，則更多的計算需要執行。在測試平台確定以後，協同仿真可以提供程序運行的精確仿真。這樣就可以達到執行週期和性能結果。最後，我們討論了採用循環優化和數組分塊對代碼進行優化。
