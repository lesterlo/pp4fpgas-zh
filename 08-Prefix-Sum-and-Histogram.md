# 第八章 前綴和與直方圖

## 8.1 前綴和

​前綴和是許多應用中經常使用的運算算子，可以應用在遞推關係、壓縮問題、字符串比較、多項式評估、直方圖、基數排序和快速排序中[[11](./BIBLIOGRAPHY.md#11)] 。為了創建高效的FPGA設計，下面我們對前綴和運算進行重新設計。

​前綴和本來是一序列數字的累加和。若給定一序列輸入中$$i{n_n}$$,前綴和中第n項的值是輸入前n項的累加和$$ou{t_n}$$，即$$ou{t_n} = i{n_0} + i{n_1} + i{n_2} +  \cdots  + i{n_{n - 1}} + i{n_n}$$。以下展示的是前四個輸出元素的計算過程。

$$
\begin{aligned}
ou{t_0} &= i{n_0} \\
ou{t_1} &= i{n_0} + i{n_1} \\
ou{t_2} &= i{n_0} + i{n_1} + i{n_2} \\
ou{t_3} &= i{n_0} + i{n_1} + i{n_2} + i{n_3} \\
&\cdots
\end{aligned}
$$

​當然，在實際應用中，我們不希望存儲和重新計算以前所有輸入的累加和，因此我們使用遞推方程式表示：

$$
\begin{aligned}
ou{t_n} &= ou{t_{n - 1}} + i{n_n} \\
\end{aligned}
$$

​遞推方程的劣勢是在計算$$ou{t_n}$$之前必須先計算出$$ou{t_{n-1}}$$,這從根本上限制了計算時的並行性的擴展和吞吐量的提高。相反，計算前綴和的原始方程由於計算每個輸出都可以獨立計算，所以很明顯可以並行執行，但是代價是進行一系列的宂餘計算。使用C語言實現的遞推方程如圖8.1所示。理想情況下，我們期望代碼中循環的II (Initiation interval)= 1，但即使對於這樣簡單的代碼，也是具有挑戰性的。在Vivado@HLS中進行綜合這段代碼運行結果如圖8.1所示。

​這段代碼的編寫方式是將每個輸出數值都寫入輸出寄存器out[]中，然後在下一次迭代中再次從寄存器中讀出上一次輸出的數值。由於讀取寄存器的延遲是1個時鐘週期，因此從寄存器中讀取的數據只有在下一個時鐘週期才能被處理。結果是，這樣的代碼設計只能實現II (Initiation interval)=2 的循環設計。在這種情況下，有一種簡單的改良此代碼的方法：我們可以使用一個單獨的局部變量來進行累加操作，而不是像以前一樣從數組中讀回前一次累加的數值。在CPU處理器代碼設計中，避免使用額外的外部存儲器來替代寄存器作為數據訪問的方式更有優勢，同樣在HLS設計中這樣的數據訪問方式更重要，因為其他的處理操作很少能成為系統的性能瓶頸。該操作方式代碼如圖8.2所示。


![圖8.1 前綴和實現代碼及行為描述](images/8_1.png)

![圖8.2 優化後的前綴和代碼及行為描述](images/8_2.png)

​你可能會問，為什麼編譯器無法自動優化內存負載和存儲以改進II的設計。事實證明，Vivado@hls能夠優化加載和數組存儲，但僅適用於單個基本塊範圍內的讀取和寫入。如果我們展開循環，你可能看到如圖8.3所示。注意，我們也通過添加約束**array_partition**的方式來達到在接口處可以同時讀取和寫入多個數值。在這種情況下，Vivado@HLS能夠消除循環體內大部分out[]數組的讀操作，但我們仍然只能實現循環間隔II=2的設計。在這種情況下，循環中第一次加載讀數仍然存在。但是我們可以通過修改代碼使用局部變量來替代從out[]數組中讀取數據。

​理想情況下，當我們展開內部循環時，則在每個時鐘中就可以執行更多的操作和減少函數運算的時間間隔。如果我們將展開因子設置2，則性能提升一倍。如果展開因子係數設置為4，則性能提升4倍，即循環在展開時，系統性能以線性方式變化。雖然大部分情況是這樣，但是當我們展開內部嵌套循環時，設計中的某些方面是不會變化的。在大多數情況下，例如當循環的迭代間隔是執行很長時間時，展開內部循環對於整個函數性能的提升沒有顯著影響。但是，對着循環迭代次數的減少，展開循環會產生更大的影響。循環流水線設計中最大成分是流水線自身深度。由Vivado@HLS為流水線循環生成的組合邏輯要求在循環執行後刷新流水線。

![圖8.3 使用unroll,pipeline和array_partition指令優化的前綴和代碼](images/8_3.png)

![圖8.4 a)部分展示了與圖8.1中代碼相對應的體系結構。對out[]數組的依賴限制了循環II =1設計的實現。如圖8.2中代碼所示，使用局部變量計算循環能夠減少循環中的延遲並實現II = 1的設計](images/architectures_prefixsum.jpg)

{% hint style='info' %}通過設置不同的展開因子來將對應的圖8.2中前綴和代碼中**for**循環展開，並結合數組分割來達到使循環ii = 1。前綴和函數延遲如何變化？資源利用率如何變化？你為什麼認為是這樣變化的？當循環完全展開時會發生什麼？ {% endhint %}

​圖8.4中展示了圖8.1和圖8.2中的代碼綜合產生的硬件架構。在a)部分中，我們可以看到流程中的‘loop’包含存儲out[]數組的輸出存儲部分，而在b)部分，流程中的循環部分僅包含一個存儲累加值的寄存器和只寫的輸出存儲器。簡化重複並消除不必要的內存訪問是優化HLS代碼的常見做法。

​本節的目標是表明即使代碼中的小改動有時也會對硬件設計產生重大的影響。有些變化可能不一定直觀，但可以通過開發工具的反饋來識別。

![圖8.5 一個直方圖實例](images/histogram_introd.jpg)

```c
void histogram(int in[INPUT_SIZE], int hist[VALUE_SIZE]) {
	int val;
	for(int i = 0; i < INPUT_SIZE; i++) {
		#pragma HLS PIPELINE
		val = in[i];
		hist[val] = hist[val] + 1;
	}
}
```
![圖8.6：計算直方圖的原始代碼。 for循環遍歷輸入數組並遞增hist數組的相應元素。](images/placeholder.png)

## 8.2 直方圖

​直方圖表示離散信號的概率分佈。當給定一系列離散輸入值時，直方圖計算每個值在序列中出現的次數。當通過除以輸入總數進行標準化處理時，直方圖就變成序列的概率分佈函數。直方圖常應用於圖像處理、信號處理、數據庫處理以及許多其他領域。在許多情況下，將高精度的輸入數據量化處理成更小的數量間隔是直方圖中一種常見處理。在本節的內容中，我們將略過數據實際處理過程，而重點關注數據分塊操作。

​圖8.5中是一個直方圖應用的簡單例子。該數據集由一系列[0,4]中整數表示。下面顯示了相應的直方圖，在直方圖中顯示了每個數據塊區間的計數，其中每個數據塊區間的高度對應每個單獨值的在數據集中的個數。圖8.6中顯示了直方圖函數的計算代碼。

![圖8.7：圖中對應的是圖8.6中的代碼產生的體系結構。 數組中的val數據用於索引hist數組。val會增加並存儲回相同的位置。](images/architectures_histogram.jpg)

​代碼最後看起來與前一小節中的前綴和計算代碼非常相似。不同之處在於，前綴和基本上只執行一次累加，而在直方圖函數中我們為每個分塊均計算一次累加。另一個區別是，在前綴和運算中，我們每次都加上一個新的輸入值，而在直方圖運算中，我們只加1。當使用**pipeline**指令對函數內部循環進行約束時，會遇到和圖8.1中代碼同樣問題，由於內存的重複讀寫，系統只能實現II =2的循環。這是因為在每次迭代循環中我們均需要從hist[]數組中讀取數據和寫入數據。圖8.7中顯示了圖8.6中代碼的硬件體系結構。從圖中可以看到針對hist[]數組進行了讀取和寫入操作。其中，val變量用作hist[]數組的索引，並且該索引變量讀取,遞增並寫回到同一個位置。

## 8.3 直方圖優化和錯誤依賴


​讓我們更深入的觀察上面的處理過程。在循環的第一次迭代中，我們讀取位置x0處的hist數組值並將其寫回到相同的位置x0處hist數組中。由於讀操作需要一個時鐘延遲，所以寫入數組操作必須在下一個時鐘週期發生。然後在下一次迭代循環中，我們讀取另一個hist數組中另一個位置x1中數組。x0和x1都取決於輸入值，並可以取任何值。因此我們考慮到綜合成電路時最壞的情況，如果x0 = x1,則在前一個寫入完成前，位置x1處的讀取無法開始。因此，我們必須在讀寫之間進行切換。

​事實證明，只要x0和x1是獨立的，我們就必須在讀寫之間進行切換。如果它們實際上不是獨立的呢？例如，我們可能知道數據源實際不會連續產生兩個完全相同的數據。那我們現在該怎麼做呢？如果我們可以將x0和x1是不同的地址額外信息提供給HLS工具，那麼它就能夠同時在位置x1處讀取，而在位置x0處寫入數據了。在Vivado@HLS中，可以通過設置**dependence**指令來完成。

​修改後的代碼如圖8.8所示。上面我們明確表示該函數使用需要一些前提條件。在代碼中，我們使用assert斷言來完成對第二個前提條件的檢查。在Vivado@HLS中，這個斷言在仿真過程中被啟用，以確保仿真測試過程中向量滿足所需的前提條件。軟件提供的**dependence**指令可以避免前提條件對綜合電路的影響。也就是説，它向Vivado@HLS軟件工具指示使用特定的方式讀取和寫入hist數組。在這種情況下，迭代循環之間讀操作和寫操作間距離是2。在這種情況下，距離為n將表明在迭代次數i+n中的讀操作僅依賴於迭代次數i中的寫操作。因此，斷言in[i+1] != in[i]，但可能出現in[i +2] == in[i]，所以正確距離是2。

```c
#include <assert.h>
#include ”histogram.h”
// Precondition: hist[] is initialized with zeros.
// Precondition: for all x, in[x] != in[x+1]
void histogram(int in[INPUT SIZE], int hist[VALUE SIZE]) {
	#pragma HLS DEPENDENCE variable=hist inter RAW distance=2
	int val;
    int old = −1;
    for(int i = 0; i < INPUT SIZE; i++) {
        #pragma HLS PIPELINE
        val = in[i];
        assert(old != val);
        hist[val] = hist[val] + 1;
        old = val;
	}
}
```

![圖8.8：計算直方圖的替代函數。 通過向Vivado @HLS添加指令約束輸入，就可以在不顯著更改代碼的情況下實現II = 1的設計。](images/placeholder.png)

{% hint style='info' %}在圖8.8中，我們向代碼添加了一個前提條件，使用一個斷言對其進行了檢查，並且使用**dependence**指令指示工具對於前提條件的約束。如果你的測試文件不滿足這個先決條件會發生什麼？如果刪除assert()會發生什麼？Vivado@HLS是否仍檢查前提條件？如果前提條件與**dependence**指令不一致，會發生什麼？ {% endhint %}

​不幸的是，如果我們不願意接受附加的先決條件，那麼**dependence**指令就不能真正幫助我們。同樣清楚的是，因為我們可能需要使用存儲在hist數組中的所有值，所以我們不能直接應用於前綴函數相同的優化。另一種方法是使用不同的技術實現hist數組，例如我們可以完全劃分hist數組，從而使用觸發器（FF）資源實現數組。由於在一個時鐘週期內寫入FF的數據在下一個時鐘週期可立即使用，這解決了重複問題並且在涉及少量分塊時這也是一個不錯的解決方案。圖8.9顯示了這種設計的結構。然而，當需要大量分塊時，這往往是一個糟糕的解決方案。通常的直方圖是用成百上千個分塊進行構建並且對於大數據集可能需要許多位精度來計算所有輸入。這導致大量FF資源和大型多路複用器，其中多路複用器也需要邏輯資源。通常在塊RAM（BRAM）中存儲較大的直方圖是一個更好的解決方案。

​回到圖8.6中的代碼，我們看到，架構必須能夠處理兩種不同的情況。一種情況是輸入包含連續的同一個分塊中的值。在這種情況下，我們希望使用一個簡單的寄存器以最小的延遲執行累加。第二種情況是當輸入中不包含連續的同一個分塊中的值，在這種情況下，我們需要讀取，修改並將結果寫回到內存，並且可以保證hist數組的讀操作不會受到前一個寫操作的影響。我們已經看到，這兩種情況都可以單獨實施，也許我們可以將他們組合成單一設計。圖8.10中所示了完成此操作的代碼。該代碼使用一個本地變量old來存儲上一次迭代分塊的結果，同時使用另一個本地變量accu存儲此次迭代分塊的計數。每次迭代循環時，我們都會檢查當前分塊是否與上次迭代分塊值相同。如果是這樣，那麼我們可以簡單地增加accu。如果不是，那麼我們需要將數值存儲在hist數組中，然後在hist數組中使用當前值更替。無論哪種情況，我們都會使用當前的值更新old和accu值。該代碼對應的體系結構如圖8.11所示。

![圖8.9：當hist數組完全分區時，由圖8.6中的代碼產生的體系結構。](images/architectures_histogram.jpg)

​在這段代碼中，我們仍然需要一個**dependence**指令，就像圖8.8中那樣，但是形式略有不同。在這種情況下，在同一個迭代循環中，讀取和寫入訪問是在不同地址中進行的。這兩個地址都依賴於輸入數據，因此可以指向hist數組中的任何單獨像素。因此，Vivado@HLS假定這兩種訪問都可以訪問相同的位置，並以交替的週期順序對數組進行讀取和寫入操作，則循環的II =2。但是，通過查看代碼，我們可以很容易地看到hist[old]和hist[val]永遠不會訪問相同的位置，因為他們位於條件**if**(old = val )的**else**分支中。在一次迭代（內部依賴）內，寫入操作（RAW）之後的讀取操作永遠不會發生，因此這是錯誤的依賴關係。在這種情況下，我們不使用**dependence**指令來通知工具關於函數的先決條件，而是關於代碼本身的屬性。

{% hint style='info' %}綜合圖8.6和圖8.10中的代碼。這兩種情況下啟動間隔（II）是多少？當你從圖8.10中的代碼中刪除**dependence**指令時會發生什麼？在這兩種情況下，循環間隔怎麼變化？資源使用情況如何？ {% endhint %}

{% hint style='tip' %}對於圖8.10中的代碼，你可能會問為什麼像Vivado@HLS這樣的工具無法確定性能。事實上，雖然在這樣的一些簡單情況下，更好的代碼分析可以將if條件屬性傳播到每個分支，但我們必須接受存在一些代碼段，其中內存訪問的性能是不可判定的。在這種情況下最高的性能只能通過添加用户信息的靜態進程來實現。最近的一些研究工作通過引入一些研究來尋求改進設計中的動態控制邏輯[[60](./BIBLIOGRAPHY.md#60), [40](./BIBLIOGRAPHY.md#40),[19](./BIBLIOGRAPHY.md#19)]。 {% endhint %}

```c
#include ”histogram.h”
    void histogram(int in[INPUT_SIZE], int hist[VALUE_SIZE]) {
    int acc = 0;
    int i, val;
    int old = in[0];
    #pragma HLS DEPENDENCE variable=hist intra RAW false
    for(i = 0; i < INPUT_SIZE; i++) {
      #pragma HLS PIPELINE II=1
      val = in[i];
      if(old == val) {
      acc = acc + 1;
      } else {
        hist[old] = acc;
        acc = hist[val] + 1;
	}
		old = val;
	}
	hist[old] = acc;
}		
```

![圖8.10：從for循環中刪除寫入依賴後的讀取。 這需要一個if /else結構，看起來似乎會增加設計的不必要的複雜性。儘管數據路徑更復雜，但它允許更有效的流水線操作。](images/placeholder.png)

​圖8.11展示的是圖8.10中代碼重構後的圖形化描述。圖中並非所有的操作都在這裏顯示，但實現功能的主要思想都顯示出來。你可以看到兩個單獨的**if**和**else**區域（用虛線表示）。圖中將Acc變量複製了兩次目的是讓圖形更容易理解；在實際設計中只有一個寄存器用於該變量。該圖顯示了對應於計算的**if**子句和對應於數據讀寫的**else**子句的兩個分離的數據路徑。

## 8.4 提高直方圖性能

​通過一些努力，我們已經實現了II =1 的設計。以前我們已經看到通過部分展開內部循環方式可以進一步減少設計的執行時間。但是對於直方圖函數是有點困難的，有幾個原因如下。第一個原因是順序循環執行，即下次循環執行必須在這次循環計算完成的前提下才能開始，除非我們能夠以某種方式分解輸入數據。第二個原因是在迴路II = 1的情況下，電路需要在每個時鐘週期內同時執行讀取和寫入hist數組，這樣就需要佔用FPGA中BRAM資源的兩個端口。之前我們已經考慮過數組分區方法來增加存儲數組內存端口的數量，但是由於訪問順序輸入數據，所以沒有特別好的方式來分割hist數組。

![圖8.11：圖中所示是與圖8.10中的代碼對應的數據路徑的描述。 這裏包含對應於if和else子句兩個獨立的部分。 該圖顯示了計算的重要部分，並省略了一些細節。](images/architectures_histogram_restructured.jpg)

​不過，並不是沒有指望了。因為我們可以通過將直方圖計算分解為兩個階段來達到更多的並行性。在第一階段，我們將輸入數據分成若干獨立的分塊。每個分塊的直方圖可以使用我們之前的直方圖解決方案獨立計算。第二階段，將各個直方圖組合起來生成完整數據集的直方圖。這種分塊（或映射）和合並（或還原）過程與MapReduce框架[[20](./BIBLIOGRAPHY.md#20)]採用的過程非常相似，並且是並行計算的常見模式。Map-reduce模式適用於包含交換和關聯操作的循環，例如這種情況下的加法。完整方案如圖8.12所示。

​圖8.13中式實現這種架構的代碼。直方圖函數實現了Map-reduce模式的’map’部分，並且會多次實例化。該代碼與圖8.10中的代碼非常相似。主要的區別在於我們添加了額外的代碼來初始化hist數組。**Histogram_map** 函數輸入數組是hist數組中一個分區數據。**Histogram_reduce** 函數實現了模式中的“還原”部分。它將分區數據的直方圖作為輸入，並通過將每個直方圖的計數相加，將它們組合成完整的直方圖。在我們的圖8.13的代碼示例中，我們只有兩個處理對象，因此將兩個輸入數組hist1和hist2合併。這可以很容易的擴展以處理更多的元素。

![圖8.12：使用map-reduce模式實現的直方圖計算。 a）部分中的處理單元（PE）與圖8.11所示的結構相同。 in數組是分塊後的，每個分塊由一個單獨的PE處理。合併塊組合各個直方圖以創建最終直方圖。](images/architectures_histogram_parallel.jpg)

​新的直方圖函數將輸入數據分成兩個分區，分別存儲在**inputA**和**inputB**數組中。它使用**histogram_map**函數計算每個分區的直方圖，然後將其存儲在**hist1**和**hist2**數組中。這兩個數組被輸入到**histogram_reduce**函數中。該函數將它們合併後並將結果存儲在hist數組中，其中合併的hist數組是頂層直方圖函數的最終輸出。

{% hint style='info' %}修改圖8.13中的代碼，使得其支持可參數化改變的**PE**數目（變量名記為**NUM_PE**）？提示：你需要根據數組分塊數量**NUM_PE**以及循環將數組合併成一個數組。當你改變PE的數量時，吞吐量和任務間隔會發生什麼變化？{% endhint %}

​我們在**histogram**函數中使用**dataflow**指令來達到任務級流水線設計。在這種情況下有三個模塊：兩個**partial_histogram**函數實例和一個**histogram_reduce**函數實例。在一個任務中，因為兩個**partial_histogram**處理的數據相互獨立，所以可以同時執行。**Histogram_reduce** 函數處理過程必須在 **partial_histogram** 處理完成後才開始。因此，**dataflow** 指令本質上是創建了一個兩階段的任務管道。第一階段執行**partial_histogram**函數，而第二階段執行**histogram_reduce**函數。與任何數據流設計一樣，整個histogram函數的間隔取決於兩個階段的最大啟動間隔。第一個階段的兩個**partial_histogram**函數時相同的，並且具有相同的間隔（$$I{I_{histogram\_map}}$$）。**Histogram_reduce** 函數則是另一個間隔（$$I{I_{histogram\_reduce}}$$）。頂層 **histogram** 函數的啟動間隔$$I{I_{histogram}}$$是max($$I{I_{histogram\_map}}$$ ,$$I{I_{histogram\_reduce}}$$ ).

```c
#include ”histogram parallel.h”
void histogram_map(int in[INPUT_SIZE/2], int hist[VALUE_SIZE]) {
	#pragma HLS DEPENDENCE variable=hist intra RAW false
	for(int i = 0; i < VALUE_SIZE; i++) {
		#pragma HLS PIPELINE II=1
		hist[i] = 0;
    }
    int old = in[0];
    int acc = 0;
    for(int i = 0; i < INPUT_SIZE/2; i++) {
        #pragma HLS PIPELINE II=1
        int val = in[i];
        if(old == val) {
       		 acc = acc + 1;
        } else {
          hist[old] = acc;
          acc = hist[val] + 1;
		}
		old = val;
	}
	hist[old] = acc;
}
void histogram_reduce(int hist1[VALUE_SIZE], int hist2[VALUE_SIZE], int output[VALUE_SIZE]) {
	for(int i = 0; i < VALUE_SIZE; i++) {
		#pragma HLS PIPELINE II=1
		output[i] = hist1[i] + hist2[i];
	}
}
//Top level function
void histogram(int inputA[INPUT_SIZE/2], int inputB[INPUT_SIZE/2], int hist[VALUE_SIZE]){
    #pragma HLS DATAFLOW
    int hist1[VALUE_SIZE];
    int hist2[VALUE_SIZE];

    histogram_map(inputA, hist1);
    histogram_map(inputB, hist2);
    histogram_reduce(hist1, hist2, hist);
}
```

![圖8.13：圖示是使用任務級並行和流水線操作的直方圖的另一種實現。直方圖操作分為兩個子任務，這兩個子任務在兩個histogram_map函數中執行。使用histogram_reduce函數將這些結果合併到最終的直方圖結果中。頂層的histogram函數是將這三個函數連接在一起。](images/placeholder.png)

{% hint style='info' %}當你添加或更改 **pipeline** 指令時，會發生什麼？比如，在histogram_reduce函數中為 **for** 循環添加 **pipeline** 指令是否有益？將**pipeline**指令移動到直方圖映射函數中，也就是將它拉到當前所在 **for** 循環的外部，那麼結果是什麼？{% endhint %}

​本節目標是學習直方圖計算的優化算法，而這也是許多應用程序中另外一個小但重要的核心。關鍵是因為對於我們的程序，工具可以理解的東西通常是有限制的。在某些情況下，我們必須注意如何寫代碼，而在其他情況下，實際上我們必須提供給工具更多關於代碼或代碼執行環境的信息。特別的，內存訪問形式的性能通常會嚴重影響HLS生成正確且高效的硬件。在Vivado@HLS中，可以使用 **dependence** 指令表示這些性能。有些時候這些優化或許與直覺相反，比如在8.10中添加的 **if/else** 結構。一些情況下優化或許要求一些創造性，就像分佈式計算在圖8.12和8.13的應用。

## 8.5 結論

​本節我們學習了前綴和與直方圖內核。儘管這些方法看起來不同，但他們都包含重複的內存訪問。如果內存訪問不是流水線的，這些重複訪問就會限制吞吐量。這兩種情況，我們可以通過重構代碼來去除重複。前綴和會非常容易，因為它的訪問模式就是確定的。直方圖情況下，我們必須重新寫代碼以解決重複訪問的問題，或者確保實踐中不會發生重複。無論是這兩種的哪種情況，我們都需要一種方法來向Vivado®HLS描述一些信息，關於環境或者工具自身無法確定的代碼部分。這些信息會在 **dependece** 指令中被捕獲。最後，我們研究了兩種算法的並行化方法，以便他們可以在每個時鐘週期處理大量數據樣本。
