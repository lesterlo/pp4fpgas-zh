# 第十章 排序算法

## 10.1 簡介

排序是許多系統中最常見的一個通用算法。它的核心算法是在處理大量排序數據時，用二叉樹檢索法進行高效處理，其時間複雜度僅為$$O(logN)$$。比如，數序序列

$$
A = {1, 4, 17, 23, 31, 45, 74, 76}
$$

從這個序列中判斷是否存在一個數，不需要將它與所有8個元素進行比較，僅僅需要從排序序列中間元素選取並檢查需要判斷的數字是否大於或小於元素。如果檢索元素45，第一步，可以從比較`A(4)＝31`來開始，從45到31我們可以消除`A(0...4)`只考慮`A(5...7)`，即

$$
A = {\underline{1, 4, 17, 23, 31},45,74,76}
$$  

下一步，如果與`A(6)＝74`比較，可以得到`45＜74`，可以消除除`A(5)`以外的所有情況，此時

$$
A = {\underline{1, 4, 17, 23, 31}, 45, \underline{74, 76}}
$$

最終確認A(5)確實包含在序列中。



 在上面的例子中，序列A可以代表各種不同的概念。A可以代表一個數學集合，可以搜索元素是否在集合內。在集合中，A也可以表示數據中的一部分，通常稱為關鍵字，用於索引其餘信息。關鍵字可以是一個人的名字，基於關鍵字的搜索，可以獲取該人的其餘數據信息，比如他們的出生日期等等。在有些場合下，關鍵字還可能是更抽象的對象，比如一些數據或密鑰的加密散列。在這種情況下，數據存儲順序可能是隨機的，但只要獲得正確的密碼散列，仍然可以搜索它。不管何種情況，排序和搜索所需的基本操作類似，都要需要比較兩個不同的值，在這一章中將忽略這些問題。

在通用處理器系統中，有各種各樣的排序算法應用，參考[[36](./BIBLIOGRAPHY.md#36)]。它們在空間複雜度和時間複雜度方面有所不同，但絕大數都需要$$O(NlogN)$$次比較才能對$$N$$個元素進行排序。對一個排序序列使用二叉樹插入1個新元素時，搜索$$O(logN)$$次即能找到新值的正確位置；當需要插入$$N$$個元素時，這個過程需要重複$$N$$次。

在實際應用場景下，插入元素的成本可能非常大，這取決於排序的數據結構 。在通用處理器系統中，有各種各樣的因素影響綜合性能，比如處理大數據集或多核之間並行化計算時的局部存儲問題。 HLS中也有類似的考慮，通常以增加資源開銷為代價，來降低計算處理的時間。在很多實際案例中，要取得最佳設計往往要從算法和實現技術方式兩個方面來綜合考慮。算法和實現技術的權衡目前是一個新興的研究領域，參考[[45](./BIBLIOGRAPHY.md#45),[54](./BIBLIOGRAPHY.md#45),[49](./BIBLIOGRAPHY.md#49)]。

性能外的特性也影響排序算法的選擇。例如：

- 穩定： 如果輸入數據有兩個字段具有相同的鍵值，它們以相同的順序輸出，那麼排序是穩定的。例如，對一組記錄進行排序，使用年齡作為排序主鍵，包含人名和年齡。在輸入數據中，兩人都是25歲，John排在Jane前面。一個穩定的排序需要確保John和Jane的位置跟輸入數據保持一致。
- 在線：算法允許數據在接收時進行排序。若遇到數據在排序時不可以訪問，或是必須從外部存儲器順序讀取等情況，在線是非常有必要的措施。
- 原位： 一個包含$$N$$個元素的數組可以使用$$N$$個元素存儲空間進行排序，也有一些算法在排序過程中需要額外的存儲。
- 適應：對於已經排序的數據來説是有效的。如果數據已經排序，一些算法可能會運行得更快，即只需要$$O(N)$$的時間複雜度。

## 10.2 插入排序

插入排序是一種基本的排序算法，其核心思想是將一個新的元素插入到一個有序數組中，並繼續保持有序。每步將一個待排序的記錄，按其關鍵碼值的大小插入前面已經排序的文件中適當位置上，直到全部插入完為止。

例如有一個長度為$$N$$的無序數組，進行$$N-1$$次的插入即能完成排序；第一次，數組第1個數認為是有序的數組，將數組第二個元素插入僅有1個有序的數組中；第二次，數組前兩個元素組成有序的數組，將數組第三個元素插入由兩個元素構成的有序數組中......第$$N-1$$次，數組前`N-1`個元素組成有序的數組，將數組的第N個元素插入由N-1個元素構成的有序數組中，則完成了整個插入排序 。

例如對輸入數組A進行排序，先考慮數組第1個數$$A[0]$$ 視為元素個數為1的有序序列；下一步考慮數組的第二個元素$$A[1]$$ 插入這個有序序列中；然後依次把數組A中的每個元素$$A[i]$$ 插入到這個有序序列中，因此，需要一個外部循環，掃描數組A的每一個元素。在每一次插入過程中，假設這是要將$$A[i]$$ 插入到前面的有序序列中，需要將$$A[i]$$ 和$$A[0...i-1]$$ 進行比較，確定要插入的合適位置，這就需要一個內部循環。圖10.1 展示一個數組插入排序的單步視圖。第一趟第1個元素值3是有序的，因為任何只帶有一個元素的數組都是按順序排列的。第二趟插入數組元素值2，與第一個元素值3比較後，被放置到有序數組中的第一個元素，將之前有序數組中的元素值3移到右邊。第三趟插入數組的第三個元素$$A[2]= 5$$，由於其已經位於正確的位置，因此無需做任何移動操作。第四趟把數組元素4插入到有序數組中元素5前面即可。最後一趟插入數組元素值1時，元素1需要插入到有序數組中的第一個元素位置，前面的有序數組元素全部右移一個位置。

![圖10.1 插入排序算法在數組上操作。初始數組顯示在上面，在算法的每個步驟中，都要比較下劃線元素並將其桉按順序排序在左邊；在每個階段，陰影部分按順序排列。](images/10.1.png)

插入排序是一種穩定、在線、原位、自適應的排序算法。插入排序通常用在處理小批量數組。例如，複雜算法產生的大量數據可以分解為若干個組小批量的數組，然後利用插入排序處理這些小批量的數組，最終結果通過組合排序數組形成。

### 10.2.1 插入排序的基本實現

```c
#include "insertion_sort.h"
void insertion_sort(DTYPE A[SIZE]) {
	L1:
	for(int i = 1; i < SIZE; i++) {
		DTYPE item = A[i];
		int j = i;
    DTYPE t = A[j-1];
		L2:
		while(j > 0 && A[j−1] > item ) {
			#pragma HLS pipeline II=1
			A[j] = A[j−1];
			j−−;
		}
		A[j] = item;
	}
}
```
![圖10.2 : 插入排序的參考代碼。外部循環for用來遍歷數組元素，內部循環while用來遍歷已經排序的序列，將當前元素移動到對應位置。](images/placeholder.png)

圖10.2是插入排序的C參考代碼。外部循環標記為L1，由於單個元素$$A[0]$$已經排序，這裏僅需要從元素$$A[1]$$ 迭代到元素$$A[SIZE-1]$$，其中$$SIZE$$ 表示數組元素的長度。L1的每次循環首先拷貝當前要插入有序序列中的元素$$A[i]$$，然後再執行內部L2循環尋找該值索引的合適位置。內部循環的判斷條件是還沒有循環到數組末尾(即條件為$$j>0$$)，並且數組元素是大於即將要插入的元素(即條件$$A[j-1]>item$$)。只要該判斷條件滿足，排序子數組的元素右移(操作$$A[j]=A[j-1]$$)；當判斷條件不滿足時，即已經查詢到要插入元素的座標位置；此時退出循環，找到索引的正確位置直接插入元素。當第​$$i$$次迭代完成後，從​$$A[0]$$到​$$A[i]$$的元素按排序順序排列。


圖10.2中的插入排序代碼是一個簡單的實現，沒有做任何優化。這裏可以使用Vivado HLS不同的優化指令 ，如**pipeline**, **unroll** 和**array_paration**等進行優化。最簡單的優化策略即是使用**pipeline**指令，使得內部循環L2支持流水功能。對於插入排序算法，內部循環訪問不同的數組元素時，沒有數據相關性，因此設置期望的流水線啟動間隔為1（即II=1）。生成的加速器平均需要 $$N^2/4$$次數據比較，由於每個時鐘週期都需要比較一次，因此流水線的處理延遲大概需要 $$N^2/4$$個時鐘週期, 參考[[58](./BIBLIOGRAPHY.md#58)]。實際上，外部循環的順序執行的計算延遲稍高。為了獲取更好的性能，可以嘗試將**pipeline**指定應用到外部循環L或者函數本身，或者還可以使用部分循環展開組合。插入排序的一些優化選項可以參考表10.1。

表10.1：圖10.2中插入排序的C代碼實現可以嘗試的優化選項

|      | 指令（Directives)                          | 啟動間隔（II） | 週期（period) | 邏輯資源Slices |
| :--: | ------------------------------------------ | :------------: | :-----------: | :------------: |
|  1   | L2: pipeline II=1                          |       ?        |       ?       |       ?        |
|  2   | L2: pipeline II=1                          |       ?        |       ?       |       ?        |
|      | L2: unroll factor=2                        |                |               |                |
|      | array partition variable=A cyclic factor=2 |                |               |                |
|  3   | L1: pipeline II=1                          |       ?        |       ?       |       ?        |
|  4   | L1: pipeline II=1                          |       ?        |       ?       |       ?        |
|      | L1: unroll factor=2                        |                |               |                |
|      | array partition variable=A complete        |                |               |                |
|  5   | function pipeline II=1                     |       ?        |       ?       |       ?        |
|      | array partition variable=A complete        |                |               |                |

{% hint style='info' %}
探索一下表10.1中的優化選項，分別綜合這些優化設計並確定啟動間隔(II)、時鐘週期和所需要的邏輯資源，分析綜合報告，獲取哪些優化選項在改進延遲和吞吐量方面效果最明顯。如果合併這些優化選型到插入排序算法設計裏面會發生什麼?
{% endhint %}

圖10.2所示的插入排序代碼與前面幾章的其他嵌套循環程序比較類似，但是有一些方面確實很難優化。優化選項1嘗試的流水線啟動間隔也無法達到1，雖然數據通路上並沒有重要的相關性，但是在控制通路上循環是否能夠執行的判斷影響了其流水線性能。在這種情況下，必須讀取$$A[i-1]$$來確定循環是否能夠執行，而該循環檢查並不能在讀取數據A的第一級流水線完成。這是典型的遞歸例子，其包含了HLS生成的循環控制邏輯。如果碰到類似的遞歸邏輯，Vivado HLS報告中會指出循環退出條件不能在第一個啟動間隔的時鐘週期中去調度；當然也有可能會發生退出或者保持當前控制邏輯的狀態。一種解決方案是增加一條讀取$$A[i-1]$$的操作，才能保證循環退出檢查在1個啟動間隔週期內調度，其代碼如圖10.3所示。

```c
#include "insertion_sort.h"
void insertion_sort(DTYPE A[SIZE]) {
	L1:
	for(i = 1; i < SIZE; i++) {
		DTYPE item = A[i];
		j = i;
		DTYPE t = A[j−1];
		L2:
		while(j > 0 && t > item) {
			#pragma HLS pipeline II=1
			A[j] = t;
			t = A[j−2];
			j−−;
		}
		A[j] = item;
	}
}
```
![圖10.3 ： 根據表10.1中的優化選項1重構插入排序](images/placeholder.png)

表中的優化選項2是以factor因數為2展開內部循環，即在每一個時鐘週期內完成兩個移位操作，可能會降低插入排序的延遲。由於每次存儲訪問不能分配到不同的存儲區域，因此即使添加數組分區指令優化，Vivado HLS也不能達到啟動間隔為1的循環。

{% hint style='info' %}
在Vivado HLS中，數組分區array_partition優化指令是用來實現多組獨立的存儲塊區域。例如優化指令（array_partition variable=A cyclic factor=4)表示劃分數組A中為4個獨立的子存儲塊，通常這個指令使得每個時鐘週期內存儲訪問速度是未優化前的4倍，但是其限制是一個時鐘週期內的每次存儲訪問必須對應其中的一塊子存儲塊。數組元素A[i]可以存放在任意一個分區，而數組元素A[4*i+2]僅可以訪問第3個子模塊；需要額外的交叉邏輯來解決同一個週期內同時訪問A[i]、A[i+1]、A[i+6]和A[i+7]。在編譯時只能保證靜態偏移量下的訪問可以抵達不同的存儲塊，但是實際的存儲塊直到運行時才能確定。當然在訪問不同存儲塊區域時，還可以使用緩衝邏輯保證那些不能在一個週期內抵達的訪問。要是訪問同一存儲塊區域，緩衝邏輯可以延遲幾個週期直到有所有訪問完成。多端口的架構設計通過一個或兩個物理端口獲取數據副本，保證在每個時鐘週期中有一定數量的訪問可以完成，參考[[62](./BIBLIOGRAPHY.md#62),[1](./BIBLIOGRAPHY.md#1),[37](./BIBLIOGRAPHY.md#37)]。
{% endhint %}

表中的優化選項3也未能實現顯著的改進，主要原因是內部循環L2沒有靜態可計算的環路，Vivado HLS無法重構外部循環L1的流水線。這裏主要關注插入算法在指令優化上的設計空間，好的替代方案還需要進行代碼重構。要設計出最佳的代碼重構不僅需要理解算法，還需要理解HLS的綜合的體系結構，參考[[28](./BIBLIOGRAPHY.md#28),[48](./BIBLIOGRAPHY.md#48)]。接下來的小節會主要對插入排序的代碼進行重構，其代碼結構與圖10.2中的有很大差異。

設計一個最佳基於HLS的算法加速需要考慮下面幾個方面。首先，編寫高效的高層綜合語言需要工程師是必須理解硬件設計，比如循環展開和存儲劃分等一些基本思路。其次，工程師需要對應用程序和硬件實現都有足夠的理解，才能正確評估任何吞吐量問題。第三，也是最重要的，為了達到最佳的設計結果，即高性能和資源的低開銷，通常需要重構代碼才能創建一個高效的硬件結構。這些與軟件設計有很大的差異。

### 10.2.2 並行化插入排序

為了提高插入排序的性能，優化目標是每個時鐘週期插入一個新元素。當最後一個元素插入到排序列表中時，可能會需要改變數組中的所有元素。對於圖10.2中的代碼，意味着內部循環L2實際上順序掃描比較了數組中的所有元素。要想在每個時鐘週期中插入一個新元素，首先需要足夠的硬件操作資源，才可以對數組中的每個元素進行比較。為了保證外部循環的流水線，優化內部循環的變量邊界為常量邊界，才可以使得內部循環體展開並集成到外部循環體中，參考代碼如圖10.4所示。

```c
#include "insertion_sort_parallel.h"
#include "assert.h"
void insertion_sort_parallel(DTYPE A[SIZE], DTYPE B[SIZE]) {
	#pragma HLS array_partition variable=B complete
	L1:
	for(int i = 0; i < SIZE; i++) {
		#pragma HLS pipeline II=1
		DTYPE item = A[i];
		L2:
		for(int j = SIZE−1; j >= 0; j−−) {
			DTYPE t;
			if(j > i) {
				t = B[j];
			} else if(j > 0 && B[j−1] > item) {
				t = B[j−1];
			} else {
				t = item;
				if (j > 0)
					item = B[j−1];
			}
			B[j] = t;
		}
	}
}
```

![圖10.4：重構表10.1中優化選型3的插入排序代碼](images/placeholder.png)

重構圖10.2中的內部循環體的實現代碼，把退出條件優化為if條件，放在新的內部循環體L2中；增加其他分支判斷條件，擴大內部循環的次數；增加的分支判斷條件在原始循環時不執行任何操作，也不會被執行；數組的賦值在循環體L2內部執行，而不是在L2循環體外部執行。內部循環展開時，$$j$$ 都成為常量，數組B的每次讀寫都將在常量索引下執行。另一方面，$$item$$變量是分配給內部循環的一份元素拷貝；在編譯期間Vivado HLS會創建一個獨立的寄存器用來實現電路上的多路複用。

{% hint style='info' %}
將單個變量轉換為多個副本是編譯器裏常用的內部轉換優化機制，這種中間表示形式即是靜態單一賦值（SSA）。要合併來自代碼中不同點的值，SSA中間表示形式包括φ函數都是由希臘字母φ表示。這些φ函數在Vivado HLS產生的電路中生成多路複用器，如果您仔細查看，你可能會發現工具中相關的資源報告。
{% endhint %}

圖10.4中的並行插入排序本質上生成了多組內部循環體，這個內部循環體的結構主要是由幾個多路複用器、一個決定誰最小的比較器和1個存儲數組元素的寄存器等組成。當然，每個階段還可能包括緩衝寄存器，以確保生成的電路邏輯在一個有效的時鐘頻率。若把內部循環體L2看為排序單元，那麼插入排序函數即是由一個一維數組的排序單元和一些在輸入輸出接口層的額外邏輯組成，在這種情況下， 外部迭代體僅需要$$SIZE$$個時鐘週期就可以處理完。這個排序單元的主要特性是每個排序單元只與相鄰的排序單元通信，而不是所有的單元。像這樣的設計被稱為脈動陣列，是一種常見的並行算法優化的技術。在很多情況下，只要在不同的循環之間的通信是有限的，當展開內部循環的優化，包括排序和脈動陣列的實現，都可以稱為隱式脈動陣列。

### 10.2.3 顯式脈動陣列插入排序

脈動陣列已經有了很好的研究，許多並行算法都採用了脈動陣列的技術，特別是使用線性排序單元陣列來實現插入排序，參考[[59](./BIBLIOGRAPHY.md#4=59),[9](./BIBLIOGRAPHY.md#9),[45](./BIBLIOGRAPHY.md#45),[5](./BIBLIOGRAPHY.md#5)]。脈動陣列本身的核心概念就是讓數據在運算單元的陣列中進行流水，減少訪存的次數，並且使得結構更加規整，佈線更加統一，提高頻率。 這裏描述一種顯式的數據流編碼風格，通過**dataflow**優化指令就可以實現脈動陣列的直觀方法。

圖10.5展示了插入排序的脈動陣列的實現方式。每個單元都是相同的，每個單元的輸入端口$$in$$用來接收當前寄存器中的值，較小的值發送到輸出端口$$out$$, 而較大的值存放在本地寄存器$$local$$中, 其實每個單元的功能也就是$$out=min(in, local)$$。第$$i$$號單元的輸出結果傳遞給線性陣列的下一個（即第$$i+1$$號）單元的輸入，當新的輸入到來時，會與存儲在陣列中的本數組進行比較，直到找到正確的位置。如果新的輸入大於陣列中的所有值，排序後的值將向右移動一個單元陣列；如果新的輸入小於陣列中的所有值，此值會在陣列中傳輸，最終會被存放在最右邊的陣列單元中。當所有的數據都處理完時，最小的元素存放在第$$N-1$$個陣列單元，直接從輸出讀出即可。

![圖10.5：插入單元的體系結構。每個單元只存放一個本地值，在每次執行中，獲取輸入值，將其與本地值進行比較，並把較小的值寫入輸出端口。排序N個元素需要N個單元。](images/insertion_cell.jpg)



一個插入單元的核心代碼如圖10.6所示。輸入和輸出變量都聲明為HLS的數據流類型。DTYPE是一個類型參數，允許對不同類型進行操作。本地變量存放陣列中的某一個元素，添加了**static**關鍵字是為了在多個函數調用中保存它的值。這裏需要注意的是使用相同的函數，複製單元功能$$N$$次；每個單元必須有一個單獨的單元靜態變量，一個靜態變量不能跨$$N$$個函數共享。

```c
void cell0(hls::stream<DTYPE> & in, hls::stream<DTYPE> & out)
{
	static DTYPE local = 0;
	DTYPE in_copy = in.read();
	if(in_copy > local) {
		out.write(local);
		local = in_copy;
	}
	else
	{
		out.write(in_copy);
	}
}
```

![圖10.6：一個插入單元cell0對應的Vivado HLS C代碼，其他單元格除了需要具體不同的函數名（比如cell1、cell2等）之外，其他的功能代碼都時相同的。代碼與圖10.5中架構圖所展示的功能相同，輸入和輸出變量採用了HLS的數據流接口，此接口提供了一種抽象層次更高更方便的方法去生成和仿真FIFO。](images/placeholder.png)

圖10.7展示了8個元素進行排序的代碼，實現的主要功能即是將8個插入單元連接在一起。若需要擴展更多的元素，只需要複製更多的單元函數即可。HLS定義並實例化了單元之間的數據流變量類型，並以合適的方式連接每個單元的輸入和輸出接口。

```c
void insertion_cell_sort(hls::stream<DTYPE> &in, hls::stream<DTYPE> &out)
{
	#pragma HLS DATAFLOW
	hls::stream<DTYPE> out0(”out0 stream”);
	hls::stream<DTYPE> out1(”out1 stream”);
	hls::stream<DTYPE> out2(”out2 stream”);
	hls::stream<DTYPE> out3(”out3 stream”);
	hls::stream<DTYPE> out4(”out4 stream”);
	hls::stream<DTYPE> out5(”out5 stream”);
	hls::stream<DTYPE> out6(”out6 stream”);
	// Function calls;
	cell0(in, out0);
	cell1(out0, out1);
	cell2(out1, out2);
	cell3(out2, out3);
	cell4(out3, out4);
	cell5(out4, out5);
	cell6(out5, out6);
	cell7(out6, out);
}
```

![圖10.7：插入單元對8個元素進行排序，函數的輸入是HLS的數據流接口，輸出是通過變量out按順序的輸出元素，輸出順序從最小的元素開始，以最大的元素結束。](images/placeholder.png)

{% hint style='info' %}
上面insertion_cell_sort函數是從最小值開始輸出數據，後面的輸出越來越大的元素。如果要首先輸出最大的元素，後面的輸出越來越小，需要做哪些改進，才可能反轉這個輸出順序？
{% endhint %}

為了對整個元素進行排序，需要多次調用insertion_cell_sort 子函數。每一個插入單元排序的調用都提供了一個數據元素進行排序；第一次調用時，這些數據元素將存放在哪裏呢？這個問題的解決方法是把輸入數據在初始化成局部變量0，這個在所有的單元函數中完成的。

{% hint style='info' %}
將靜態變量local初始化為0是對數據類型的假設。這種假設的成立條件是什麼?換句話説，範圍是多少才能被正確處理輸入數據的值?如果輸入數據在insertion_cell_sort函數這個範圍之外?有沒有更好的方法去初始化局部變量?
{% endhint %}

在調用了插入單元排序函數8次後，所有的數據都存放在每個單元格函數的8個局部變量中。

{% hint style='info' %}
要得到第一個排序元素，需要調用insertion_cell_sort函數多少次?對於所有元素數據的排序，需要調用多少次？如果把數組拆成N個單元，又需要多少次調用insertion_cell_sort函數才能完成整個排序？
{% endhint %}

指令dataflow的作用是實現了8個插入單元函數組成的任務流水線結構。在頂層函數的每個執行過程中都流水地處理一個新的輸入示例，流水線的每個階段都去調用單元函數。當調用單元函數8次時，即只能對序列排序8個值；在單元函數之間不包含遞歸，因此在資源足夠的情況下可以任意擴展和調用單元函數。

{% hint style='info' %}
整個數組的插入排序需要多少個週期?所有排序的數據都是從插入單元函數中的參數輸出的嗎？如果刪除dataflow優化指令，循環計數將如何變化？如何改進資源利用率？
{% endhint %}

圖10.8所示的是testbench的參考代碼，testbench生成要排序的隨機數據存放在input數組中，多次調用insertion_cell_sort函數進行排序，處理結果存放在cell_output數據中。接下來，使用同樣的輸入數據，插入排序處理過程採用圖10.2所示的insertion_sort函數。最後，testbench比較這兩種不同實現方式的結果，如果兩鐘不同實現方式的排序結構相同，則testbench通過。

```c
#include "insertion_cell_sort.h"
#include <iostream>
#include <stdlib.h>

const static int DEBUG=1;
const static int MAX_NUMBER=1000;
int main () {
	int fail = 0;
	DTYPE input[SIZE];
	DTYPE cell_output[SIZE] = {0};
	hls::stream<DTYPE> in, out;

	//generate random data to sort
	if(DEBUG) std::cout << "Random Input Data\n";
	srand(20); //change me if you want different numbers
	for(int i = 0; i < SIZE; i++) {
		input[i] = rand() % MAX_NUMBER + 1;
		if(DEBUG) std::cout << input[i] << "\t";
	}

	//process the data through the insertion_cell_sort function
	for(int i = 0; i < SIZE*2; i++) {
		if(i < SIZE) {
			//feed in the SIZE elements to be sorted
			in.write(input[i]);
			insertion_cell_sort(in, out);
			cell_output[i] = out.read();
		} else {
			//then send in dummy data to flush pipeline
			in.write(MAX_NUMBER);
			insertion_cell_sort(in, out);
			cell_output[i-SIZE] = out.read();
		}
	}

	//sort the data using the insertion_sort function
	insertion_sort(input);

	//compare the results of insertion_sort to insertion_cell_sort; fail if they differ
	if(DEBUG) std::cout << "\nSorted Output\n";
	for(int i = 0; i < SIZE; i++) {
		if(DEBUG) std::cout << cell_output[i] << "\t";
	}
	for(int i = 0; i < SIZE; i++) {
		if(input[i] != cell_output[i]) {
			fail = 1;
			std::cout << "golden=" << input[i] << "hw=" << cell_output[i] << "\n";
		}
	}

	if(fail == 0) std::cout << "PASS\n";
	else std::cout << "FAIL\n";
	return fail;
}

```

![圖10.8：insertion_cell_sort函數的測試平台](images/placeholder.png)

在testbench中，常量$$SIZE$$的值表示要排序元素的數量，在本節的運行示例中即為8。常量DEBUG是用來提供testbench中的一些輸出詳細説明；設置成非0表示打開debug信息，設置成0表示關閉debug信息。輸入數組Input中的數據是由rand函數隨機產生的；如果需要更新產生的數據，可以調用帶參數信息的srand函數。

值得注意的是，testbench中一共調用了$$SIZE*2$$次insertion_cell_sort函數。前面SIZE次調用都會向insertion_cell_sort函數中輸入一個元素，但不會產生有效的結果輸出；後面SIZE次的調用提供虛擬無效的輸入數據，併產生一個已經排序的元素，從最小的元素開始輸出。

{% hint style='info' %}
在排序操作開始進行時，圖10.6中的代碼是在不同的狀態下的本地局部變量，這意味着只能對一個數組進行排序。在大多數實際場景中，不僅需要對多個數組進行排序，還希望在不存在氣泡的情況下，對每個數組進行反向處理。推薦大家改進代碼和testbench，實現對多個數組的排序。
{% endhint %}

## 10.3 歸併排序

歸併操作是 John von Neumann在1945年發明的一種穩定的分治算法，參考[36](./BIBLIOGRAPHY.md#36)。 歸併排序算法的基本思想是將兩個有序序列合併成一個較大的有序序列，可以在$$O(N)$$時間內完成。從概念上講,將已有序的子序列合併，得到完全有序的序列；即先使每個子序列有序，再使子序列段間有序 ，組成最終有序序列。

分治操作是歸併排序中最核心的算法，不需要算術或者數據移動，只需要考慮每個元素的輸入數組是否一個排序的子數組；所有的操作都是需要將兩個已經有序的子數組合併成一個大的有序數組  ，其排序的過程如圖10.9所示。

![圖10.9：歸併排序的操作示例。在頂部，每一個元素的初始狀態是長度為1的排序子數組；操作示例中每一步操作，都是圍繞將兩個已經有序的子數組合併成一個大的有序數組，組成最終的有序序列。](images/10.9.jpg)

將兩個排序數組組合成一個較大的排序數組的過程通常稱為two-finger算法。圖10.10展示了兩個已經排序的輸入數組in1和in2合併到一個大的輸出數組out中。two-finger操作初始化時指向每個數組第一個元素（數值in1中的元素3和數組in2中的元素1），在算法執行的過程中，兩個指針會指向數組中的不同元素。

![圖10.10：合併兩個有序數組的操作示例。頂部是初始狀態，算法的每一步都需要考慮下劃線的元素，並將其中的一個元素排序在輸出有序數組中。](images/10.10.jpg)



圖10.10的第一步是初始化狀態，輸入的兩個數組各有四個元素，輸出數組是空的。第二步，比較兩個數組中的第一個元素，並且把最小的元素寫入輸出數組中（即比較3和1中小元素1並排序到數組out中）；此時數組in2的指針指向下一個元素。第三步，繼續比較兩個數組中當前指針所指向元素的大小，並把小的元素排序到輸出數組中（即比較3和2中的小元素2並排序到數組out中）。繼續類似的操作，直到其中一個數組元素移空；最後只需要拷貝未處理完的數組中剩下的元素到輸出數組out中。

歸併排序算法是遞歸函數調用的典型示例 。大多數的高層綜合語言不支持遞歸，或者以有邊界的方式支持遞歸。這裏我們關注歸併排序算法的非遞歸實現方式，代碼看起來與通常CPU架構下的完全不同，但是算法的核心思想是完全相同的。

### 10.3.1 歸併排序的基本操作

圖10.11展示了非遞歸方式實現的歸併排序的基本代碼，處理數組排序大概需要$$N log N$$ 次比較，並且需要額外的臨時存儲空間。代碼裏首先考慮數組中的每個元素作為一個排序子數組，外部循環的每次迭代都將排序子數組合併成較大的排序子數組。第一次迭代，對最大$$SIZE$$為2的子數組進行排序；第二次迭代，對最大$$SIZE$$為4的子數組進行排序；然後是8，以此類推。需要注意的是，這裏的輸入數組的長度並不是2的冪次方，也可能有一些子數組小於最大尺寸。

```c
#include "merge_sort.h"
#include "assert.h"

// subarray1 is in[i1..i2-1], subarray2 is in[i2..i3-1], result is in out[i1..i3-1]
void merge(DTYPE in[SIZE], int i1, int i2, int i3, DTYPE out[SIZE]) {
    int f1 = i1, f2 = i2;
    // Foreach element that needs to be sorted...
    for(int index = i1; index < i3; index++) {
        // Select the smallest available element.
        if((f1 < i2 && in[f1] <= in[f2]) || f2 == i3) {
            out[index] = in[f1];
            f1++;
        } else {
            assert(f2 < i3);
            out[index] = in[f2];
            f2++;
        }
    }
}

void merge_sort(DTYPE A[SIZE]) {
    DTYPE temp[SIZE];
    // Each time through the loop, we try to merge sorted subarrays of width elements
    // into a sorted subarray of 2*width elements.
 stage:
    for (int width = 1; width < SIZE; width = 2 * width) {
    merge_arrays:
        for (int i1 = 0; i1 < SIZE; i1 = i1 + 2 * width) {
            // Try to merge two sorted subarrays:
            // A[i1..i1+width-1] and A[i1+width..i1+2*width-1] to temp[i1..2*width-1]
            int i2 = i1 + width;
            int i3 = i1 + 2*width;
            if(i2 >= SIZE) i2 = SIZE;
            if(i3 >= SIZE) i3 = SIZE;
            merge(A, i1, i2, i3, temp);
        }

        // Copy temp[] back to A[] for next iteration
    copy:
        for(int i = 0; i < SIZE; i++) {
            A[i] = temp[i];
        }
    }
}

```

![圖10.11：非遞歸方式的歸併排序實現。merge_sort函數每一步都將兩個已經有序的子數組合併成一個大的有序數組 ，直到整個數組有序](images/placeholder.png)

歸併排序算法的主入口函數為merge_sort，函數的數組為A，需要內部存儲存放數組temp；參數SIZE決定兩個數組的大小，參數DTYPE決定數據的排序類型。merge_sort函數主要有兩個嵌套的for循環構成，外部循環體主要跟蹤每個排序子數組中的元素數量；初始化時將每個元素作為單獨的子數組，因此width寬度初始化為1。每次循環都會生成較大的排序子數組，這些新的子數組絕大多數情況下都是兩倍的元素。但寬度大於或者等於參數SIZE的值時，循環終止，此時所有的元素都在一個有序數組中。

內部循環體merge_arrays的主要功能時歸併兩個有序數組 ，這些有序數組最多有width個元素，從索引i1和i2開始。然後調用merge函數將有序子數組合並並複製到內部存儲temp數組中。這裏需要處理循環末尾的邊界情況，若參數SIZE不是2的冪次方，子數組可能包含小於寬度的元素。在完成子數組的歸併到temp數組後，需要把當前temp數組中的元素按順序存放在數組A中，以便開展下一輪的循環迭代。

{% hint style='info' %}
通過不斷調整SIZE的值，獲取那些值比較合適？當調用merge函數是，i1、i2和i3之間的可能關係有哪些？如果限定參數SIZE，HLS產生的電路又有什麼影響？
{% endhint %}

merge函數對數組in中的兩個子數組採用了two-finger算法。數組in作為函數的輸入數組，數組out作為函數的輸出數組；而且還需要輸入變量i1、i2和i3，來描述需要合併的兩個子數組的邊界範圍。一個子數組從第i1座標索引開始，到第i2個座標索引之前截止；還有一個子數組從第i2個座標索引開始，到第i3個座標索引截止；合併後輸出子數組將存儲在數組out的座標索引i1到i3之間。

merge函數包含一個遍歷數組排序輸出的循環；每一個循環迭代都將一個元素放在輸出數組out中的正確排序的位置。函數中的變量f1和f2對應每個子數組的座標索引。if條件裏面的主要功能即是選擇in[f1]和in[f2]中相對小的元素，並拷貝到輸出數組out下一個排序的位置中。而if條件裏面還需要處理幾種特殊的情況；一種情況是f1等於 i2，此時in[f1]已經超過子數組的邊界，需要在in[f2]裏面選擇最小的元素；同樣地。如果f2等於i3，此時in[f2]已經超過子數組的邊界，需要在in[f1]裏面選擇最小的元素。

{% hint style='info' %}
在處理過程中數組in會發生什麼變化？在外部循環的每次迭代之後數組in的元素排序會是什麼？當merge_sort函數返回時，數組in的元素排序會是什麼？
{% endhint %}

{% hint style='info' %}
綜合後的性能報告可能無法確定歸併排序的延遲和間隔，為什麼會出現這種情況？如何評估loop tripcount指令值，哪一個才是合適的最小值、最大值和平均值？
{% endhint %}

圖10.11中的代碼並沒有使用Vivado HLS的一些特定優化指令。對多層嵌套for循環的優化，通常先從內部循環優化開始，然後再進行外部循環的優化。常用的循環優化指令有流水線指令pipeline和展開指令unroll。

{% hint style='info' %}
使用pipeline指令設置不同的優化參數，還可以使用unroll指令展開for循環，哪一種方式提供了最好性能？性能和資源利用率之間的最佳權衡又是什麼？代碼方面的設計缺陷阻礙了更高的性能？這些方面都是算法設計考慮的因素，不能僅關注代碼實現層面。
{% endhint %}

pipeline和unroll往往會受到資源上面的限制，因此需要考慮數組輸入輸出的端口數量。圖10.11中的數組都是一維的，此時設計者還需要仔細考慮數組的訪問模式，以確保性能優化與資源限制匹配。

{% hint style='info' %}
建議使用array_partition、pipeline和unroll指令來優化循環，探索出最佳的策略。只考慮性能方面，最佳的設計是什麼？在考慮資源利用率和性能之間的權衡後，最佳的設計是什麼？
{% endhint %}

最佳設計往往只有通過重構代碼才能實現。雖然Vivado HLS提供了許多指令來啟動一個常規的公共代碼優化，但是為每一個優化提供一個指令的做法是不切實際的。在下一節中，將描述一種方法重構歸併排序的代碼，以增加排序的吞吐量。

### 10.3.2 重構歸併排序

圖10.11實現的內部循環merge函數要取得1個時鐘週期的循環啟動間隔是非常有挑戰的。一方面數組in有四次讀操作，且有兩個不同的讀操作基地址。HLS綜合工具需要分析出其中有些讀取操作是宂餘的，但是FPGA的片上BRAM資源只能支持每個時鐘週期進行兩次訪問，再加上這些讀操作在不同的基本塊中，編譯器更難消除宂餘負載。 通過重構代碼來消除宂餘讀取，編譯器只需要更少的優化來實現1個時鐘週期的循環啟動間隔，重構後的代碼如圖10.12所示。另外一方面，在變量f1和f2有遞歸關係，這些變量在if條件內部遞增，並且確定了下一次循環時數組in中的需要比較元素的位置信息。這種動態浮動的比較方式也會影響時鐘頻率和循環的啟動間隔。

```c
#include "merge_sort.h"
#include "assert.h"

// subarray1 is in[ii..i2-1]; subarray2 is in[i2..i3-1]
// sorted merge is stored in out[i1..i3-1]
void merge(DTYPE in[SIZE], int i1, int i2, int i3, DTYPE out[SIZE]) {
    int f1 = i1, f2 = i2;
    // Foreach element that needs to be sorted...
    for(int index = i1; index < i3; index++) {
#pragma HLS pipeline II=1
        DTYPE t1 = in[f1];
        DTYPE t2 = in[f2];
        // Select the smallest available element.
        if((f1 < i2 && t1 <= t2) || f2 == i3) {
            out[index] = t1;
            f1++;
        } else {
            assert(f2 < i3);
            out[index] = t2;
            f2++;
        }
    }
}
```

![圖10.12：重構merge函數的代碼實現：在Vivado HLS中循環的啟動間隔可以達到1](images/placeholder.png)

圖10.13描述了重構代碼的行為結構，雖然內部循環實現了1個時鐘週期的啟動間隔，但是在內部循環結束時，在下一個階段的流水線執行之前，中間的緩衝數據必須先清空。一旦循環的次數增加，中間的氣泡問題還是影響流水線性能的關鍵因素。由於循環靜態分析的侷限性，影響性能的代碼部分很難可視化，而且內部循環的次數是有變量參數決定的。

![圖10.13： 圖10.12中重構代碼的行為結構](images/10.13.jpg)



常見的方法是將多層循環嵌套優化成一個單一循環，減少流水線中循環退出時的刷新次數，Vivado HLS工具也支持了多層循環嵌套的自動優化。然而，圖10.11中的代碼實現並不是一個完美的循環嵌套，需要重構merge函數以支持循環嵌套的完美合併，重構後的代碼如圖10.14所示。其最大的變化就是merge_arrays函數循環次數也是確定的，使得編譯器更好地理解實現。

```c
#include "merge_sort.h"
#include "assert.h"

void merge_sort(DTYPE A[SIZE]) {
    DTYPE temp[SIZE];
 stage:
    for (int width = 1; width < SIZE; width = 2 * width) {
        int f1 = 0;
        int f2 = width;
        int i2 = width;
        int i3 = 2*width;
        if(i2 >= SIZE) i2 = SIZE;
        if(i3 >= SIZE) i3 = SIZE;
    merge_arrays:
        for (int i = 0; i < SIZE; i++) {
#pragma HLS pipeline II=1
            DTYPE t1 = A[f1];
            DTYPE t2 = A[f2];
            if((f1 < i2 && t1 <= t2) || f2 == i3) {
                temp[i] = t1;
                f1++;
            } else {
                assert(f2 < i3);
                temp[i] = t2;
                f2++;
            }
            if(f1 == i2 && f2 == i3) {
                f1 = i3;
                i2 += 2*width;
                i3 += 2*width;
                if(i2 >= SIZE) i2 = SIZE;
                if(i3 >= SIZE) i3 = SIZE;
                f2 = i2;
            }
        }

    copy:
        for(int i = 0; i < SIZE; i++) {
#pragma HLS pipeline II=1
            A[i] = temp[i];
        }
    }
}
```

![圖10.14：重構merge函數的代碼實現：在Vivado HLS中循環的啟動間隔可以達到1，而且流水線的氣泡很少](images/placeholder.png)

{% hint style='info' %}
評估圖10.14中代碼的性能，即使內部循環已經實現了1個時鐘週期的啟動間隔，該設計是否有效合理地利用了硬件加速？有沒有進一步改進merge_sort函數延遲的方法，使得整個延遲在大約在NlogN個時鐘週期？
{% endhint %}

前面重點介紹瞭如何優化merge_sort函數，在不大幅增加資源利用率的情況下，降低計算處理的延遲，提高了加速器的計算效率。提高加速器並行計算能力的方法主要是進一步降低延遲或者提高吞吐量。前面介紹的內部循環的展開優化和數組分區優化可以在每一個時鐘週期內同時執行更多的任務。還有一種提高並行計算能力的方法是尋找粗粒度的任務級流水線。這裏可以把歸併排序的內部迭代體merge_arrarys創建多份硬件資源，以達到粗粒度的任務級流水。如圖10.15所示，通過展開連續的內部循環體merge_arrays，可以同時處理不同的數據集，以提高整個加速器的計算性能。

![圖10.15：歸併排序中任務級流水線的體系結構，可以容納16個元素的排序](images/10.15.jpg)



圖10.16是加入任務級流水和數據流優化後的代碼實現。雖然有很多方面都與原始代碼類似，但是有幾個重要的區別。第一個區別是merge_arrays 函數的循環都提取到一個函數中，方便了頂層函數的代碼重構；第二個區別是merge_sort_parallel函數的輸入和輸出分別在一個獨立的數組中，通過Vivado HLS的dataflow指令就能夠構建一個數據流水線的體系結構；第三，temp數組用在merge_arrays函數之間的乒乓操作數據流中，減少中間緩存的不必要的拷貝信息；同時重構為一個二維數組，使得通道數的表示參數化。

```c
#include "merge_sort_parallel.h"
#include "assert.h"

void merge_arrays(DTYPE in[SIZE], int width, DTYPE out[SIZE]) {
  int f1 = 0;
  int f2 = width;
  int i2 = width;
  int i3 = 2*width;
  if(i2 >= SIZE) i2 = SIZE;
  if(i3 >= SIZE) i3 = SIZE;
 merge_arrays:
  for (int i = 0; i < SIZE; i++) {
#pragma HLS pipeline II=1
      DTYPE t1 = in[f1];
      DTYPE t2 = in[f2];
	if((f1 < i2 && t1 <= t2) || f2 == i3) {
	  out[i] = t1;
	  f1++;
	} else {
	  assert(f2 < i3);
	  out[i] = t2;
	  f2++;
	}
	if(f1 == i2 && f2 == i3) {
      f1 = i3;
	  i2 += 2*width;
	  i3 += 2*width;
	  if(i2 >= SIZE) i2 = SIZE;
	  if(i3 >= SIZE) i3 = SIZE;
      f2 = i2;
 	}
  }
}

void merge_sort_parallel(DTYPE A[SIZE], DTYPE B[SIZE]) {
#pragma HLS dataflow

	DTYPE temp[STAGES-1][SIZE];
#pragma HLS array_partition variable=temp complete dim=1
	int width = 1;

	merge_arrays(A, width, temp[0]);
	width * = 2;

	for (int stage = 1; stage < STAGES-1; stage++) {
#pragma HLS unroll
		merge_arrays(temp[stage-1], width, temp[stage]);
		width * = 2;
	}

	merge_arrays(temp[STAGES-2], width, B);
}
```

![圖10.16：重構歸併排序的代碼實現：利用了Vivado HLS的dataflow和pipeline的指令優化](images/placeholder.png)

merge_sort_parallel函數裏面包含多個階段的merge_arrays函數調用；第一次調用時從輸入端讀取數據，並把處理完的結果寫入temp數組中；在循環執行過程中，多次調用merge_arrays，並寫入temp數組的其他分區；最後一個調用時寫入排序後的結果到數組B中。在資源足夠的情況下，參數SIZE和STAGES可以支持更大的吞吐。

{% hint style='info' %}
評估圖10.16中重構後的代碼性能,分析其實現的延遲和啟動間隔，大概需要多大的片上存儲？
{% endhint %}

## 10.4 總結

本章介紹了一些基本的排序算法。插入排序操作平均需要$$N^2/4$$次數據比較，極端下需要$$N^2$$次比較，但是僅需要少量的存儲資源；展示了插入排序中的幾種提升性能的不同方式；由於流水線的氣泡問題，N個比較器大約需要N個時鐘週期的間隔才能完成插入排序。歸併排序的比較次數相對插入排序較少，大約僅需要$$N log N$$ 次比較，但是需要額外的片上存儲開銷來存儲中間緩存。一種高效的設計方案是通過重構優化代碼，取得在1個比較器的情況下，歸併排序大概僅需$$N log N$$ 個時鐘週期即可完成。另外一種高效的設計方案是採用任務級流水線，每一個時鐘週期有$$ log N$$ 個比較，N個時鐘週期的間隔才能完成歸併排序。與插入排序相比，同樣的計算處理週期，歸併排序需要較少的比較器，但是帶來的代價是額外的存儲資源開銷。歸併排序如果需要更多的片上存儲，其整體的延遲也會變大。

在實際系統中，基於FPGA的排序設計方案都必須解決資源和時間性能之間的權衡問題。還有一種使用不同折中方案的排序算法叫基數排序，與本章的排序算法不太一樣，其更關注數據的有效範圍作為元素之間的比較項。基數排序的一部分實現在下一章的Huffman編碼會有更詳細的介紹。

排序算法的並行結構通常被描述為排序網絡，排序網絡有時可以是脈動陣列或者流水線。通過研究這些現有的並行結構來獲得HLS的設計靈感，然後通過C代碼來實現它。在Vivado HLS中，可以使用任意一種方法來描述這些循環流水線、數據流水線或者兩者的組合。
